% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/eqc_calibrate.R
\name{eqc_calibrate}
\alias{eqc_calibrate}
\title{Empirical Quadrature Calibration (Algorithm 1: EQC/SQC)}
\usage{
eqc_calibrate(
  target_rho,
  n_items,
  model = c("rasch", "2pl"),
  latent_shape = "normal",
  item_source = "irw",
  latent_params = list(),
  item_params = list(),
  reliability_metric = c("msem", "info", "bar", "tilde"),
  M = 10000L,
  c_bounds = c(0.3, 3),
  tol = 1e-04,
  seed = NULL,
  verbose = FALSE
)
}
\arguments{
\item{target_rho}{Numeric in (0, 1). Target marginal reliability \eqn{\rho^*}.}

\item{n_items}{Integer. Number of items in the test form.}

\item{model}{Character. Measurement model: \code{"rasch"} or \code{"2pl"}.
For \code{"rasch"}, all baseline discriminations are set to 1 before scaling.}

\item{latent_shape}{Character. Shape argument passed to \code{sim_latentG()}
(e.g. \code{"normal"}, \code{"bimodal"}, \code{"heavy_tail"}, ...).}

\item{item_source}{Character. Source argument passed to \code{sim_item_params()}
(e.g. \code{"irw"}, \code{"parametric"}, \code{"hierarchical"}, \code{"custom"}).}

\item{latent_params}{List. Additional arguments passed to \code{sim_latentG()}.}

\item{item_params}{List. Additional arguments passed to \code{sim_item_params()}.}

\item{reliability_metric}{Character. Reliability definition used inside EQC:
\describe{
\item{\code{"msem"}}{MSEM-based marginal reliability (default, theoretically exact).}
\item{\code{"info"}}{Average-information reliability (faster, more stable).}
}
Synonyms: \code{"bar"} for \code{"msem"}, \code{"tilde"} for \code{"info"}.}

\item{M}{Integer. Size of the empirical quadrature sample (default: 10000).}

\item{c_bounds}{Numeric length-2 vector. Search bounds for \eqn{c}. Default: c(0.3, 3).}

\item{tol}{Numeric. Tolerance for \code{uniroot()}. Default: 1e-4.}

\item{seed}{Optional integer for reproducibility.}

\item{verbose}{Logical. If TRUE, print progress messages.}
}
\value{
An object of class \code{"eqc_result"} (a list) with elements:
\describe{
\item{\code{c_star}}{Calibrated discrimination scale \eqn{c^*}.}
\item{\code{target_rho}}{Target reliability \eqn{\rho^*}.}
\item{\code{achieved_rho}}{Empirical quadrature estimate \eqn{\hat\rho_M(c^*)}.}
\item{\code{metric}}{Reliability metric used.}
\item{\code{theta_quad}}{Length-M vector of quadrature abilities.}
\item{\code{theta_var}}{Sample variance of theta_quad.}
\item{\code{items_base}}{item_params object with scale = 1 (baseline).}
\item{\code{items_calib}}{item_params object with discriminations scaled by c_star.}
}
}
\description{
\code{eqc_calibrate()} implements Algorithm 1 (Empirical / Stochastic
Quadrature Calibration, EQC/SQC) for reliability-targeted IRT simulation.

Given a target marginal reliability \eqn{\rho^*}, a latent distribution
generator \code{sim_latentG()} (for \eqn{G}) and an item parameter generator
\code{sim_item_params()} (for \eqn{H}), the function searches for a global
discrimination scale \eqn{c^* > 0} such that the population reliability
\eqn{\rho(c)} of the Rasch/2PL model is approximately equal to \eqn{\rho^*}.

The key idea is to:
\enumerate{
\item Draw a large fixed "quadrature" sample
\eqn{\{\theta_m\}_{m=1}^M \sim G} and item parameters
\eqn{\{(\beta_i, \lambda_{i,0})\}_{i=1}^I \sim H} once.
\item For any scale \eqn{c}, form \eqn{\lambda_i(c) = c \cdot \lambda_{i,0}}
and compute the empirical approximation to population reliability
\eqn{\hat\rho_M(c)} from the test information function.
\item Solve the scalar equation \eqn{\hat\rho_M(c^*) = \rho^*} using
deterministic root-finding (Brent's method via \code{uniroot()}).
}
}
\details{
\subsection{Reliability Metrics}{

The function supports two reliability definitions:
\itemize{
\item \strong{MSEM-based} (\code{"msem"}/\code{"bar"}): Uses the harmonic mean of test information,
\eqn{\bar{w}(c) = \sigma^2_\theta / (\sigma^2_\theta + E[1/\mathcal{J}(\theta;c)])}.
This is theoretically exact but may have a lower ceiling for high reliability.
\item \strong{Average-information} (\code{"info"}/\code{"tilde"}): Uses the arithmetic mean,
\eqn{\tilde{\rho}(c) = \sigma^2_\theta \bar{\mathcal{J}}(c) / (\sigma^2_\theta \bar{\mathcal{J}}(c) + 1)}.
By Jensen's inequality, \eqn{\tilde{\rho} \geq \bar{w}}, so this metric typically
yields higher reliability values.
}
}

\subsection{WLE vs EAP Reliability Interpretation}{

When validating with TAM, note that EAP reliability is systematically higher than
WLE reliability. This is not a bug but a mathematical property of TAM's definitions.
EAP reliability more directly corresponds to the MSEM-based population reliability
targeted by EQC. For conservative inference, treat WLE as a lower bound and EAP
as an upper bound for true measurement precision.
}
}
\examples{
\dontrun{
# Basic EQC calibration
eqc_result <- eqc_calibrate(
  target_rho = 0.80,
  n_items = 25,
  model = "rasch",
  latent_shape = "normal",
  item_source = "irw",
  seed = 42,
  verbose = TRUE
)
print(eqc_result)
}

}
\seealso{
\code{\link{spc_calibrate}} for the stochastic approximation alternative,
\code{\link{compute_rho_bar}} and \code{\link{compute_rho_tilde}} for
reliability computation utilities,
\code{\link{compute_reliability_tam}} for TAM validation.
}
