[{"path":"https://joonho112.github.io/IRTsimrel/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 JoonHo Lee Permission hereby granted, free charge, person obtaining copy software associated documentation files (‚ÄúSoftware‚Äù), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED ‚Äú‚Äù, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/eqc_algorithm.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"Empirical Quadrature Calibration (EQC) primary algorithm IRTsimrel reliability-targeted simulation. Given target marginal reliability œÅ*\\rho^*, EQC finds global discrimination scaling factor c*c^* population reliability equals target.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/eqc_algorithm.html","id":"why-eqc-is-recommended","dir":"Articles","previous_headings":"Overview","what":"Why EQC is Recommended","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"simulation studies, EQC need. Use SPC (Algorithm 2) validation specialized applications.","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/eqc_algorithm.html","id":"the-inverse-problem","dir":"Articles","previous_headings":"Mathematical Foundation","what":"The Inverse Problem","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"Forward problem: Given item parameters scaling factor cc, compute reliability œÅ(c)\\rho(c). Inverse problem: Given target reliability œÅ*\\rho^*, find c*c^* œÅ(c*)=œÅ*\\rho(c^*) = \\rho^*.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/eqc_algorithm.html","id":"discrimination-scaling","dir":"Articles","previous_headings":"Mathematical Foundation","what":"Discrimination Scaling","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"EQC solves inverse problem scaling item discriminations common factor: Œªi(c)=c‚ãÖŒªi(0)\\lambda_i(c) = c \\cdot \\lambda_i^{(0)} Œªi(0)\\lambda_i^{(0)} baseline discriminations item generator. works: Separates informativeness structure: Changing cc modifies reliability without altering item difficulty distributions latent trait shape Monotonic relationship: Reliability strictly increasing cc Reduces dimensionality: Multi-dimensional design space becomes 1D root-finding problem","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/eqc_algorithm.html","id":"monotonicity-guarantee","dir":"Articles","previous_headings":"Mathematical Foundation","what":"Monotonicity Guarantee","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"Key Property: mild regularity conditions, œÅ(c)\\rho(c) strictly monotonically increasing cc: ‚àÇœÅ(c)‚àÇc>0for c>0\\frac{\\partial \\rho(c)}{\\partial c} > 0 \\quad \\text{} c > 0 guarantees: c‚Üí0c \\0: œÅ(c)‚Üí0\\rho(c) \\0 c‚Üí‚àûc \\\\infty: œÅ(c)‚Üí1\\rho(c) \\1 Existence uniqueness: œÅ*‚àà(0,1)\\rho^* \\(0, 1), exists unique c*c^*","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/eqc_algorithm.html","id":"algorithm-steps","dir":"Articles","previous_headings":"","what":"Algorithm Steps","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"EQC operates three steps:","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/eqc_algorithm.html","id":"step-1-generate-quadrature-samples","dir":"Articles","previous_headings":"Algorithm Steps","what":"Step 1: Generate Quadrature Samples","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"Draw large fixed samples latent item parameter distributions: {Œ∏m}m=1M‚àºG\\{\\theta_m\\}_{m=1}^M \\sim G (latent abilities) {(Œ≤i,Œªi(0))}=1I‚àºH\\{(\\beta_i, \\lambda_i^{(0)})\\}_{=1}^\\sim H (item parameters) samples serve empirical quadrature rule approximating population expectations.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/eqc_algorithm.html","id":"step-2-define-the-reliability-function","dir":"Articles","previous_headings":"Algorithm Steps","what":"Step 2: Define the Reliability Function","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"scale cc, compute empirical reliability: œÅÃÇM(c)=1M‚àëm=1MœÅ(c;Œ∏m,ùõÉ,ùõå(c))\\hat{\\rho}_M(c) = \\frac{1}{M} \\sum_{m=1}^{M} \\rho(c; \\theta_m, \\boldsymbol{\\beta}, \\boldsymbol{\\lambda}(c)) approximates population reliability ùîº[œÅ(c)]\\mathbb{E}[\\rho(c)] Law Large Numbers.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/eqc_algorithm.html","id":"step-3-root-finding","dir":"Articles","previous_headings":"Algorithm Steps","what":"Step 3: Root-Finding","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"Solve scalar equation: g(c)=œÅÃÇM(c)‚àíœÅ*=0g(c) = \\hat{\\rho}_M(c) - \\rho^* = 0 using Brent‚Äôs method (uniroot() R), combines bisection, secant, inverse quadratic interpolation robust convergence.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/eqc_algorithm.html","id":"basic-usage","dir":"Articles","previous_headings":"","what":"Basic Usage","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"","code":"# Basic EQC calibration eqc_result <- eqc_calibrate(   target_rho = 0.80,   n_items = 25,   model = \"rasch\",   latent_shape = \"normal\",   item_source = \"irw\",   seed = 42 ) #> Note: Target rho* = 0.800 is near the achievable maximum (0.824) for this configuration.  print(eqc_result) #>  #> ======================================================= #>   Empirical Quadrature Calibration (EQC) Results #> ======================================================= #>  #> Calibration Summary: #>   Model                        : RASCH #>   Target reliability (rho*)    : 0.8000 #>   Achieved reliability         : 0.8000 #>   Absolute error               : 2.27e-06 #>   Scaling factor (c*)          : 0.9082 #>  #> Design Parameters: #>   Number of items (I)          : 25 #>   Quadrature points (M)        : 10000 #>   Reliability metric           : MSEM-based (bar/w) #>   Latent variance              : 1.0123 #>  #> Convergence: #>   Root status                  : uniroot_success #>   Search bracket               : [0.300, 3.000] #>   Bracket reliabilities        : [0.3555, 0.8240] #>  #> Parameter Summaries: #>   theta:        mean = -0.011, sd = 1.006 #>   beta:         mean = 0.000, sd = 0.670, range = [-1.48, 1.06] #>   lambda_base:  mean = 1.000, sd = 0.000 #>   lambda_scaled: mean = 0.908, sd = 0.000"},{"path":"https://joonho112.github.io/IRTsimrel/articles/eqc_algorithm.html","id":"understanding-the-output","dir":"Articles","previous_headings":"","what":"Understanding the Output","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"eqc_result object contains:","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/eqc_algorithm.html","id":"accessing-calibrated-parameters","dir":"Articles","previous_headings":"Understanding the Output","what":"Accessing Calibrated Parameters","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"","code":"# The calibrated scaling factor cat(sprintf(\"c* = %.4f\\n\", eqc_result$c_star)) #> c* = 0.9082  # Item difficulties head(eqc_result$beta_vec) #> [1]  0.1312995 -1.2945477  0.3836801 -0.6358214  0.5071690  0.4314725  # Calibrated discriminations head(eqc_result$lambda_scaled) #> [1] 0.9082186 0.9082186 0.9082186 0.9082186 0.9082186 0.9082186  # Full calibrated item parameters head(eqc_result$items_calib$data) #>   form_id item_id       beta    lambda lambda_unscaled #> 1       1       1  0.1312995 0.9082186               1 #> 2       1       2 -1.2945477 0.9082186               1 #> 3       1       3  0.3836801 0.9082186               1 #> 4       1       4 -0.6358214 0.9082186               1 #> 5       1       5  0.5071690 0.9082186               1 #> 6       1       6  0.4314725 0.9082186               1"},{"path":"https://joonho112.github.io/IRTsimrel/articles/eqc_algorithm.html","id":"convergence-information","dir":"Articles","previous_headings":"Understanding the Output","what":"Convergence Information","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"","code":"# Root-finding status cat(sprintf(\"Root status: %s\\n\", eqc_result$misc$root_status)) #> Root status: uniroot_success  # Achievable reliability range cat(sprintf(\"Reliability at c_lower (%.2f): %.4f\\n\",              eqc_result$misc$c_bounds[1],              eqc_result$misc$rho_bounds[\"rho_L\"])) #> Reliability at c_lower (0.30): 0.3555 cat(sprintf(\"Reliability at c_upper (%.2f): %.4f\\n\",              eqc_result$misc$c_bounds[2],              eqc_result$misc$rho_bounds[\"rho_U\"])) #> Reliability at c_upper (3.00): 0.8240"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/eqc_algorithm.html","id":"target-reliability-target_rho","dir":"Articles","previous_headings":"Key Parameters","what":"Target Reliability (target_rho)","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"desired marginal reliability, typically 0.50 0.90:","code":"# Low reliability (formative assessment) eqc_low <- eqc_calibrate(target_rho = 0.60, n_items = 20, seed = 1)  # Moderate reliability (typical research) eqc_mod <- eqc_calibrate(target_rho = 0.75, n_items = 20, seed = 1)  # High reliability (standardized test) eqc_high <- eqc_calibrate(target_rho = 0.85, n_items = 20, seed = 1)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/eqc_algorithm.html","id":"quadrature-size-m","dir":"Articles","previous_headings":"Key Parameters","what":"Quadrature Size (M)","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"number latent ability samples empirical integration. Larger MM reduces Monte Carlo error: Recommendation: M‚â•10,000M \\geq 10,000 routine use; M‚â•50,000M \\geq 50,000 high-precision work.","code":"# Default: M = 10,000 eqc_default <- eqc_calibrate(   target_rho = 0.80, n_items = 25, M = 10000, seed = 42 ) #> Note: Target rho* = 0.800 is near the achievable maximum (0.824) for this configuration.  # Higher precision: M = 50,000 eqc_precise <- eqc_calibrate(   target_rho = 0.80, n_items = 25, M = 50000, seed = 42 )  cat(sprintf(\"M = 10,000: c* = %.6f\\n\", eqc_default$c_star)) #> M = 10,000: c* = 0.908219 cat(sprintf(\"M = 50,000: c* = %.6f\\n\", eqc_precise$c_star)) #> M = 50,000: c* = 1.156505"},{"path":"https://joonho112.github.io/IRTsimrel/articles/eqc_algorithm.html","id":"search-bounds-c_bounds","dir":"Articles","previous_headings":"Key Parameters","what":"Search Bounds (c_bounds)","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"interval [cmin,cmax][c_{\\min}, c_{\\max}] root-finding: extend bounds: Target reliability near achievable maximum ‚Üí increase c_bounds[2] low target reliability ‚Üí decrease c_bounds[1]","code":"# Default bounds eqc_default <- eqc_calibrate(   target_rho = 0.80, n_items = 25,   c_bounds = c(0.3, 3),  # Default   seed = 42 ) #> Note: Target rho* = 0.800 is near the achievable maximum (0.824) for this configuration.  # Extended bounds for high reliability eqc_extended <- eqc_calibrate(   target_rho = 0.85, n_items = 25,   c_bounds = c(0.1, 5),   seed = 42 ) #> Warning in eqc_calibrate(target_rho = 0.85, n_items = 25, c_bounds = c(0.1, : Target rho* = 0.850 exceeds the maximum achievable reliability for this configuration. #>   - Items: 25 #>   - At c = 5.00 (upper bound): rho = 0.0440 #>   - Gap: 0.8060 #>  #> Suggestions: #>   1. Use reliability_metric = 'info' (typically yields higher values) #>   2. Increase c_bounds[2] beyond 5.0 #>   3. Increase n_items for higher achievable reliability #>   4. Accept achieved rho = 0.0440 as maximum for this design #>  #> Returning c_star = 5.00 (upper bound)."},{"path":"https://joonho112.github.io/IRTsimrel/articles/eqc_algorithm.html","id":"reliability-metrics","dir":"Articles","previous_headings":"","what":"Reliability Metrics","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"EQC supports two reliability definitions:","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/eqc_algorithm.html","id":"msem-based-reliability-barw","dir":"Articles","previous_headings":"Reliability Metrics","what":"MSEM-Based Reliability (w‚Äæ\\bar{w})","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"theoretically exact marginal reliability based harmonic mean test information: w‚Äæ(c)=œÉŒ∏2œÉŒ∏2+ùîº[1/ùí•(Œ∏;c)]\\bar{w}(c) = \\frac{\\sigma^2_\\theta}{\\sigma^2_\\theta + \\mathbb{E}[1/\\mathcal{J}(\\theta; c)]}","code":"eqc_msem <- eqc_calibrate(   target_rho = 0.80,   n_items = 25,   reliability_metric = \"msem\",  # Default, or use \"bar\"   seed = 42 ) #> Note: Target rho* = 0.800 is near the achievable maximum (0.824) for this configuration."},{"path":"https://joonho112.github.io/IRTsimrel/articles/eqc_algorithm.html","id":"average-information-reliability-tilderho","dir":"Articles","previous_headings":"Reliability Metrics","what":"Average-Information Reliability (œÅÃÉ\\tilde{\\rho})","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"Based arithmetic mean test information: œÅÃÉ(c)=œÉŒ∏2ùí•‚Äæ(c)œÉŒ∏2ùí•‚Äæ(c)+1\\tilde{\\rho}(c) = \\frac{\\sigma^2_\\theta \\bar{\\mathcal{J}}(c)}{\\sigma^2_\\theta \\bar{\\mathcal{J}}(c) + 1}","code":"eqc_info <- eqc_calibrate(   target_rho = 0.80,   n_items = 25,   reliability_metric = \"info\",  # Or use \"tilde\"   seed = 42 )"},{"path":"https://joonho112.github.io/IRTsimrel/articles/eqc_algorithm.html","id":"key-relationship","dir":"Articles","previous_headings":"Reliability Metrics","what":"Key Relationship","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"Jensen‚Äôs inequality, œÅÃÉ‚â•w‚Äæ\\tilde{\\rho} \\geq \\bar{w} always holds: info metric typically requires smaller c*c^* achieve target, yields higher reliability values given cc. Recommendation: Use \"msem\" (default) theoretical correctness Use \"info\" targeting high reliability \"msem\" achieve","code":"cat(sprintf(\"MSEM metric c*: %.4f\\n\", eqc_msem$c_star)) #> MSEM metric c*: 0.9082 cat(sprintf(\"Info metric c*: %.4f\\n\", eqc_info$c_star)) #> Info metric c*: 0.8830"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/eqc_algorithm.html","id":"rasch-model","dir":"Articles","previous_headings":"Working with Different Models","what":"Rasch Model","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"","code":"eqc_rasch <- eqc_calibrate(   target_rho = 0.75,   n_items = 30,   model = \"rasch\",   seed = 42 )  # All baseline discriminations are 1 unique(eqc_rasch$lambda_base) #> [1] 1"},{"path":"https://joonho112.github.io/IRTsimrel/articles/eqc_algorithm.html","id":"pl-model","dir":"Articles","previous_headings":"Working with Different Models","what":"2PL Model","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"","code":"eqc_2pl <- eqc_calibrate(   target_rho = 0.75,   n_items = 30,   model = \"2pl\",   item_source = \"irw\",   item_params = list(     discrimination_params = list(       mu_log = 0,       sigma_log = 0.3,       rho = -0.3     )   ),   seed = 42 )  # Discriminations vary across items summary(eqc_2pl$lambda_base) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>  0.6887  0.7896  0.9104  1.0097  1.2525  1.6613"},{"path":"https://joonho112.github.io/IRTsimrel/articles/eqc_algorithm.html","id":"working-with-different-latent-distributions","dir":"Articles","previous_headings":"","what":"Working with Different Latent Distributions","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"Different latent shapes require different c*c^* values achieve target reliability:","code":"# Normal distribution eqc_normal <- eqc_calibrate(   target_rho = 0.80, n_items = 25,   latent_shape = \"normal\",   seed = 42 )  # Bimodal distribution eqc_bimodal <- eqc_calibrate(   target_rho = 0.80, n_items = 25,   latent_shape = \"bimodal\",   latent_params = list(delta = 0.8),   seed = 42 )  # Heavy-tailed distribution eqc_heavy <- eqc_calibrate(   target_rho = 0.80, n_items = 25,   latent_shape = \"heavy_tail\",   latent_params = list(df = 5),   seed = 42 ) cat(sprintf(\"Normal:     c* = %.4f\\n\", eqc_normal$c_star)) cat(sprintf(\"Bimodal:    c* = %.4f\\n\", eqc_bimodal$c_star)) cat(sprintf(\"Heavy-tail: c* = %.4f\\n\", eqc_heavy$c_star))"},{"path":"https://joonho112.github.io/IRTsimrel/articles/eqc_algorithm.html","id":"generating-response-data","dir":"Articles","previous_headings":"","what":"Generating Response Data","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"calibration, generate item response data:","code":"# Generate response data sim_data <- simulate_response_data(   eqc_result = eqc_result,   n_persons = 1000,   latent_shape = \"normal\",   seed = 123 )  # Response matrix dimensions dim(sim_data$response_matrix) #> [1] 1000   25  # First few responses head(sim_data$response_matrix[, 1:6]) #>      item1 item2 item3 item4 item5 item6 #> [1,]     0     1     0     1     0     1 #> [2,]     0     0     1     0     0     0 #> [3,]     1     1     1     1     1     1 #> [4,]     1     1     1     1     0     1 #> [5,]     0     1     0     1     0     0 #> [6,]     1     1     1     1     1     0  # True abilities head(sim_data$theta) #> [1] -0.56047565 -0.23017749  1.55870831  0.07050839  0.12928774  1.71506499"},{"path":"https://joonho112.github.io/IRTsimrel/articles/eqc_algorithm.html","id":"validation-with-tam","dir":"Articles","previous_headings":"","what":"Validation with TAM","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"Validate achieved reliability using TAM package:","code":"# Compute WLE and EAP reliability tam_rel <- compute_reliability_tam(   resp = sim_data$response_matrix,   model = \"rasch\" )  cat(sprintf(\"Target reliability:  %.4f\\n\", eqc_result$target_rho)) cat(sprintf(\"EQC achieved rho:    %.4f\\n\", eqc_result$achieved_rho)) cat(sprintf(\"TAM WLE reliability: %.4f\\n\", tam_rel$rel_wle)) cat(sprintf(\"TAM EAP reliability: %.4f\\n\", tam_rel$rel_eap))"},{"path":"https://joonho112.github.io/IRTsimrel/articles/eqc_algorithm.html","id":"understanding-wle-vs-eap-reliability","dir":"Articles","previous_headings":"Validation with TAM","what":"Understanding WLE vs EAP Reliability","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"important validation finding: TAM‚Äôs EAP reliability systematically higher WLE reliability. bug reflects different mathematical definitions: Practical interpretation: WLE reliability ‚âà lower bound true measurement precision EAP reliability ‚âà upper bound true measurement precision EQC‚Äôs theoretical reliability falls bounds","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/eqc_algorithm.html","id":"target-too-high","dir":"Articles","previous_headings":"Handling Boundary Cases","what":"Target Too High","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"target reliability exceeds ‚Äôs achievable given configuration: function returns c_star = c_bounds[2] (upper bound) warning. Solutions: Use reliability_metric = \"info\" (yields higher values) Increase c_bounds[2] Increase n_items Accept achievable maximum","code":"# Try to achieve very high reliability with few items eqc_high <- eqc_calibrate(   target_rho = 0.95,   n_items = 15,   model = \"rasch\",   c_bounds = c(0.3, 3),   seed = 42 ) #> Warning in eqc_calibrate(target_rho = 0.95, n_items = 15, model = \"rasch\", : Target rho* = 0.950 exceeds the maximum achievable reliability for this configuration. #>   - Items: 15 #>   - At c = 3.00 (upper bound): rho = 0.7054 #>   - Gap: 0.2446 #>  #> Suggestions: #>   1. Use reliability_metric = 'info' (typically yields higher values) #>   2. Increase c_bounds[2] beyond 3.0 #>   3. Increase n_items for higher achievable reliability #>   4. Accept achieved rho = 0.7054 as maximum for this design #>  #> Returning c_star = 3.00 (upper bound)."},{"path":"https://joonho112.github.io/IRTsimrel/articles/eqc_algorithm.html","id":"target-too-low","dir":"Articles","previous_headings":"Handling Boundary Cases","what":"Target Too Low","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"target minimum achievable: function returns c_star = c_bounds[1] (lower bound) warning. Solution: Decrease c_bounds[1].","code":"# Very low target with high discrimination items eqc_low <- eqc_calibrate(   target_rho = 0.30,   n_items = 50,   model = \"2pl\",   c_bounds = c(0.3, 3),   seed = 42 )"},{"path":"https://joonho112.github.io/IRTsimrel/articles/eqc_algorithm.html","id":"verbose-mode","dir":"Articles","previous_headings":"","what":"Verbose Mode","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"Enable verbose output see algorithm progress:","code":"eqc_verbose <- eqc_calibrate(   target_rho = 0.80,   n_items = 25,   model = \"rasch\",   seed = 42,   verbose = TRUE ) #> Step 1: Generating quadrature samples... #>   M (quad persons) = 10000 #>   I (items)        = 25 #>   theta: mean = -0.011, sd = 1.006, var = 1.012 #>   beta:  mean = 0.000, sd = 0.670 #>   lambda_base: mean = 1.000, sd = 0.000 #>   metric = msem #> Step 2: Running root-finding algorithm... #>   At c = 0.300: rho = 0.3555, g = -0.4445 #>   At c = 3.000: rho = 0.8240, g = 0.0240 #> Note: Target rho* = 0.800 is near the achievable maximum (0.824) for this configuration. #>   c* = 0.908219 #>   Target rho    = 0.8000 #>   Achieved rho  = 0.8000 #>   Root status   = uniroot_success"},{"path":"https://joonho112.github.io/IRTsimrel/articles/eqc_algorithm.html","id":"validation-with-spc","dir":"Articles","previous_headings":"","what":"Validation with SPC","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"rigorous validation, compare EQC results SPC algorithm: EQC SPC agree (typically within 5%), can confident calibration.","code":"# Run EQC eqc_result <- eqc_calibrate(   target_rho = 0.80,   n_items = 25,   model = \"rasch\",   seed = 42 )  # Validate with SPC (warm start from EQC) spc_result <- spc_calibrate(   target_rho = 0.80,   n_items = 25,   model = \"rasch\",   c_init = eqc_result,  # Use EQC for warm start   n_iter = 200,   seed = 42 )  # Compare compare_eqc_spc(eqc_result, spc_result)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/eqc_algorithm.html","id":"complete-workflow-example","dir":"Articles","previous_headings":"","what":"Complete Workflow Example","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"","code":"# ==== 1. Define simulation parameters ==== target_rho <- 0.80 n_items <- 25 n_persons <- 1000 n_replications <- 100  # ==== 2. Calibrate once using EQC ==== eqc_result <- eqc_calibrate(   target_rho = target_rho,   n_items = n_items,   model = \"rasch\",   latent_shape = \"normal\",   item_source = \"irw\",   M = 20000,   seed = 42,   verbose = TRUE )  cat(sprintf(\"\\nCalibrated c* = %.4f for target rho* = %.2f\\n\\n\",             eqc_result$c_star, target_rho))  # ==== 3. Run simulation replications ==== results <- vector(\"list\", n_replications)  for (r in 1:n_replications) {   # Generate data   sim_data <- simulate_response_data(     eqc_result = eqc_result,     n_persons = n_persons,     latent_shape = \"normal\",     seed = r   )      # Your analysis here...   # results[[r]] <- your_analysis(sim_data)      if (r %% 10 == 0) cat(sprintf(\"Completed replication %d\\n\", r)) }  # ==== 4. Summarize results ==== # summary_stats <- summarize_results(results)"},{"path":[]},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/eqc_algorithm.html","id":"convergence-rate","dir":"Articles","previous_headings":"Theoretical Properties","what":"Convergence Rate","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"EQC uses Brent‚Äôs method, achieves superlinear convergence: |cn‚àíc*|=O(122n)|c_n - c^*| = O\\left(\\frac{1}{2^{2^n}}\\right) practice, convergence machine precision typically requires < 50 function evaluations.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/eqc_algorithm.html","id":"monte-carlo-error","dir":"Articles","previous_headings":"Theoretical Properties","what":"Monte Carlo Error","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"empirical reliability estimate error: |œÅÃÇM(c)‚àíœÅ(c)|=O(1M)|\\hat{\\rho}_M(c) - \\rho(c)| = O\\left(\\frac{1}{\\sqrt{M}}\\right) M=10,000M = 10,000, Monte Carlo standard error approximately 0.01.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/eqc_algorithm.html","id":"consistency","dir":"Articles","previous_headings":"Theoretical Properties","what":"Consistency","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"M‚Üí‚àûM \\\\infty, EQC solution converges true population solution: cÃÇM*‚Üí.s.c*M‚Üí‚àû\\hat{c}^*_M \\xrightarrow{\\text{.s.}} c^* \\quad \\text{} M \\\\infty","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/eqc_algorithm.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"EQC fast, accurate, reliable algorithm reliability-targeted IRT simulation: use: Routine simulation studies, initial calibration Key parameters: target_rho, n_items, M, reliability_metric Validation: Compare TAM reliability /SPC algorithm Typical accuracy: Within ¬±0.01 target reliability specialized applications independent validation, see SPC algorithm vignette.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/eqc_algorithm.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"Lee, J.-H. (2025). Reliability-targeted simulation item response data. Manuscript preparation. Brent, R. P. (1973). Algorithms Minimization Without Derivatives. Prentice-Hall.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction_to_irtsimrel.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Introduction to IRTsimrel","text":"IRTsimrel package provides principled framework reliability-targeted simulation Item Response Theory (IRT) data. Instead treating reliability implicit outcome simulation design choices, IRTsimrel allows researchers specify target reliability level explicit input parameter.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction_to_irtsimrel.html","id":"why-reliability-targeted-simulation","dir":"Articles","previous_headings":"Overview","what":"Why Reliability-Targeted Simulation?","title":"Introduction to IRTsimrel","text":"Monte Carlo simulation studies IRT, researchers routinely vary: Sample size (NN) Test length (II, number items) Item parameter distributions (ùõå\\boldsymbol{\\lambda}, ùõÉ\\boldsymbol{\\beta}) Latent trait distribution shape (GG) However, marginal reliability‚Äîfundamental measure data informativeness‚Äîalmost never directly controlled reported. creates several problems: Ecological validity threat: Real-world assessments often reliabilities 0.5‚Äì0.7, simulation studies may implicitly assume higher values. Confounded model comparisons: Conclusions model superiority may hold within certain reliability regimes. Limited replicability: Without knowing implied reliability, exact replication impossible.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction_to_irtsimrel.html","id":"the-multilevel-modeling-analogy","dir":"Articles","previous_headings":"Overview","what":"The Multilevel Modeling Analogy","title":"Introduction to IRTsimrel","text":"multilevel/hierarchical linear modeling, intraclass correlation (ICC) always primary design factor simulation studies. ICC determines signal--noise ratio‚Äîproportion variance cluster level versus residual level. Marginal reliability IRT serves conceptual role ICC multilevel models. quantify proportion variance attributable latent construct versus measurement error. IRTsimrel brings IRT simulation methodology alignment best practice.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction_to_irtsimrel.html","id":"the-key-idea-separation-of-structure-and-scale","dir":"Articles","previous_headings":"","what":"The Key Idea: Separation of Structure and Scale","title":"Introduction to IRTsimrel","text":"IRTsimrel implements fundamental principle: separate structure scale. Structure: Realistic item characteristics (difficulty distributions, discrimination patterns, difficulty-discrimination correlations) flexible latent trait distributions come empirically-grounded generators. Scale: global discrimination scaling factor cc calibrated achieve target reliability. calibrated item discriminations : Œªi*=c*‚ãÖŒªi,0\\lambda_i^* = c^* \\cdot \\lambda_{,0} Œªi,0\\lambda_{,0} baseline discriminations generator c*c^* calibrated scaling factor.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction_to_irtsimrel.html","id":"two-calibration-algorithms","dir":"Articles","previous_headings":"","what":"Two Calibration Algorithms","title":"Introduction to IRTsimrel","text":"IRTsimrel provides two complementary algorithms:","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction_to_irtsimrel.html","id":"algorithm-1-empirical-quadrature-calibration-eqc","dir":"Articles","previous_headings":"Two Calibration Algorithms","what":"Algorithm 1: Empirical Quadrature Calibration (EQC)","title":"Introduction to IRTsimrel","text":"eqc_calibrate() recommended method routine use. : Draws large fixed ‚Äúquadrature‚Äù sample latent item parameter distributions Computes empirical approximation population reliability function cc Solves c*c^* using deterministic root-finding (Brent‚Äôs method) Advantages: Fast, deterministic, highly accurate (typically within ¬±0.01 target).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction_to_irtsimrel.html","id":"algorithm-2-stochastic-approximation-calibration-spc","dir":"Articles","previous_headings":"Two Calibration Algorithms","what":"Algorithm 2: Stochastic Approximation Calibration (SPC)","title":"Introduction to IRTsimrel","text":"spc_calibrate() uses Robbins-Monro stochastic approximation algorithm. ‚Äôs useful : Independent validation EQC results Complex data-generating processes Exact MSEM-based reliability targeting Advantages: general, targets exact marginal reliability, applicable complex DGPs.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction_to_irtsimrel.html","id":"quick-start-example","dir":"Articles","previous_headings":"","what":"Quick Start Example","title":"Introduction to IRTsimrel","text":"Let‚Äôs walk basic example. Suppose want generate Rasch model data : 25 items Target reliability 0.80 Normal latent trait distribution Realistic item difficulties Item Response Warehouse (IRW)","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction_to_irtsimrel.html","id":"step-1-calibrate-using-eqc","dir":"Articles","previous_headings":"Quick Start Example","what":"Step 1: Calibrate Using EQC","title":"Introduction to IRTsimrel","text":"output shows: c*: calibrated scaling factor Achieved reliability: close target 0.80 Absolute error: Typically < 0.001","code":"# Basic EQC calibration eqc_result <- eqc_calibrate(   target_rho = 0.80,   n_items = 25,   model = \"rasch\",   latent_shape = \"normal\",   item_source = \"irw\",   seed = 42,   verbose = TRUE ) #> Note: Target rho* = 0.800 is near the achievable maximum (0.824) for this configuration. # View the results print(eqc_result) #>  #> ======================================================= #>   Empirical Quadrature Calibration (EQC) Results #> ======================================================= #>  #> Calibration Summary: #>   Model                        : RASCH #>   Target reliability (rho*)    : 0.8000 #>   Achieved reliability         : 0.8000 #>   Absolute error               : 2.27e-06 #>   Scaling factor (c*)          : 0.9082 #>  #> Design Parameters: #>   Number of items (I)          : 25 #>   Quadrature points (M)        : 10000 #>   Reliability metric           : MSEM-based (bar/w) #>   Latent variance              : 1.0123 #>  #> Convergence: #>   Root status                  : uniroot_success #>   Search bracket               : [0.300, 3.000] #>   Bracket reliabilities        : [0.3555, 0.8240] #>  #> Parameter Summaries: #>   theta:        mean = -0.011, sd = 1.006 #>   beta:         mean = 0.000, sd = 0.670, range = [-1.48, 1.06] #>   lambda_base:  mean = 1.000, sd = 0.000 #>   lambda_scaled: mean = 0.908, sd = 0.000"},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction_to_irtsimrel.html","id":"step-2-generate-response-data","dir":"Articles","previous_headings":"Quick Start Example","what":"Step 2: Generate Response Data","title":"Introduction to IRTsimrel","text":"Now use calibrated parameters generate item response data:","code":"# Generate response data sim_data <- simulate_response_data(   eqc_result = eqc_result,   n_persons = 1000,   latent_shape = \"normal\",   seed = 123 )  # Examine the response matrix dim(sim_data$response_matrix) #> [1] 1000   25 head(sim_data$response_matrix[, 1:6]) #>      item1 item2 item3 item4 item5 item6 #> [1,]     0     1     0     1     0     1 #> [2,]     0     0     1     0     0     0 #> [3,]     1     1     1     1     1     1 #> [4,]     1     1     1     1     0     1 #> [5,]     0     1     0     1     0     0 #> [6,]     1     1     1     1     1     0"},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction_to_irtsimrel.html","id":"step-3-validate-with-tam-optional","dir":"Articles","previous_headings":"Quick Start Example","what":"Step 3: Validate with TAM (Optional)","title":"Introduction to IRTsimrel","text":"rigorous validation, can estimate reliability using TAM package: Note WLE vs EAP Reliability: TAM‚Äôs EAP reliability typically higher WLE reliability. bug reflects different mathematical definitions. conservative inference, treat WLE lower bound EAP upper bound true measurement precision.","code":"# Compute WLE and EAP reliability tam_rel <- compute_reliability_tam(   resp = sim_data$response_matrix,   model = \"rasch\" )  cat(sprintf(\"Target reliability: %.3f\\n\", eqc_result$target_rho)) cat(sprintf(\"WLE reliability:    %.3f\\n\", tam_rel$rel_wle)) cat(sprintf(\"EAP reliability:    %.3f\\n\", tam_rel$rel_eap))"},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction_to_irtsimrel.html","id":"understanding-reliability-metrics","dir":"Articles","previous_headings":"","what":"Understanding Reliability Metrics","title":"Introduction to IRTsimrel","text":"IRTsimrel supports two reliability definitions: ### MSEM-Based Reliability (w‚Äæ\\bar{w}) theoretically exact marginal reliability based harmonic mean test information: w‚Äæ(c)=œÉŒ∏2œÉŒ∏2+ùîº[1/ùí•(Œ∏;c)]\\bar{w}(c) = \\frac{\\sigma^2_\\theta}{\\sigma^2_\\theta + \\mathbb{E}[1/\\mathcal{J}(\\theta; c)]} ùí•(Œ∏;c)\\mathcal{J}(\\theta; c) test information function ability Œ∏\\theta.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction_to_irtsimrel.html","id":"average-information-reliability-tilderho","dir":"Articles","previous_headings":"Understanding Reliability Metrics","what":"Average-Information Reliability (œÅÃÉ\\tilde{\\rho})","title":"Introduction to IRTsimrel","text":"Based arithmetic mean test information: œÅÃÉ(c)=œÉŒ∏2ùí•‚Äæ(c)œÉŒ∏2ùí•‚Äæ(c)+1\\tilde{\\rho}(c) = \\frac{\\sigma^2_\\theta \\bar{\\mathcal{J}}(c)}{\\sigma^2_\\theta \\bar{\\mathcal{J}}(c) + 1} ùí•‚Äæ(c)=ùîº[ùí•(Œ∏;c)]\\bar{\\mathcal{J}}(c) = \\mathbb{E}[\\mathcal{J}(\\theta; c)]. Key relationship: Jensen‚Äôs inequality, œÅÃÉ‚â•w‚Äæ\\tilde{\\rho} \\geq \\bar{w} always holds. can choose metrics:","code":"# MSEM-based (default, theoretically exact) eqc_msem <- eqc_calibrate(   target_rho = 0.80,   n_items = 25,   model = \"rasch\",   reliability_metric = \"msem\",  # or \"bar\"   seed = 42 )  # Average-information (faster, higher values) eqc_info <- eqc_calibrate(   target_rho = 0.80,   n_items = 25,   model = \"rasch\",   reliability_metric = \"info\",  # or \"tilde\"   seed = 42 )"},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction_to_irtsimrel.html","id":"working-with-different-latent-distributions","dir":"Articles","previous_headings":"","what":"Working with Different Latent Distributions","title":"Introduction to IRTsimrel","text":"sim_latentG() function generates latent abilities various distributional shapes, pre-standardized mean 0 variance 1:","code":"# Compare different shapes compare_shapes(   n = 3000,   shapes = c(\"normal\", \"bimodal\", \"trimodal\",               \"skew_pos\", \"heavy_tail\", \"uniform\"),   seed = 42 )"},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction_to_irtsimrel.html","id":"using-non-normal-latent-distributions","dir":"Articles","previous_headings":"Working with Different Latent Distributions","what":"Using Non-Normal Latent Distributions","title":"Introduction to IRTsimrel","text":"can specify shape calibration: Available shapes include:","code":"# Calibrate for a bimodal population eqc_bimodal <- eqc_calibrate(   target_rho = 0.75,   n_items = 20,   model = \"rasch\",   latent_shape = \"bimodal\",   latent_params = list(delta = 0.8),  # Mode separation   seed = 42 )"},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction_to_irtsimrel.html","id":"working-with-the-2pl-model","dir":"Articles","previous_headings":"","what":"Working with the 2PL Model","title":"Introduction to IRTsimrel","text":"two-parameter logistic (2PL) model, discriminations vary across items: copula method generating item parameters preserves: Realistic difficulty distributions IRW Log-normal marginal discriminations empirically-observed negative correlation difficulty discrimination","code":"# 2PL calibration with IRW-based difficulties and copula method eqc_2pl <- eqc_calibrate(   target_rho = 0.80,   n_items = 30,   model = \"2pl\",   latent_shape = \"normal\",   item_source = \"irw\",   item_params = list(     discrimination_params = list(       mu_log = 0,        # Mean of log-discrimination       sigma_log = 0.3,   # SD of log-discrimination       rho = -0.3         # Correlation between difficulty and log-discrimination     )   ),   seed = 42 )"},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction_to_irtsimrel.html","id":"validating-with-the-spc-algorithm","dir":"Articles","previous_headings":"","what":"Validating with the SPC Algorithm","title":"Introduction to IRTsimrel","text":"rigorous validation, use SPC independently verify EQC results: results agree (typically within 5%), can confident calibration.","code":"# First run EQC eqc_result <- eqc_calibrate(   target_rho = 0.80,   n_items = 25,   model = \"rasch\",   seed = 42 )  # Validate with SPC (warm start from EQC) spc_result <- spc_calibrate(   target_rho = 0.80,   n_items = 25,   model = \"rasch\",   c_init = eqc_result,  # Use EQC result for warm start   n_iter = 200,   seed = 42 )  # Compare results compare_eqc_spc(eqc_result, spc_result)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction_to_irtsimrel.html","id":"typical-workflow-summary","dir":"Articles","previous_headings":"","what":"Typical Workflow Summary","title":"Introduction to IRTsimrel","text":"complete reliability-targeted simulation workflow:","code":"# 1. Define target reliability target_rho <- 0.80  # 2. Calibrate using EQC eqc_result <- eqc_calibrate(   target_rho = target_rho,   n_items = 25,   model = \"rasch\",   latent_shape = \"normal\",   item_source = \"irw\",   seed = 42 )  # 3. (Optional) Validate with SPC spc_result <- spc_calibrate(   target_rho = target_rho,   n_items = 25,   model = \"rasch\",   c_init = eqc_result,   n_iter = 200,   seed = 42 )  # 4. Generate response data sim_data <- simulate_response_data(   eqc_result = eqc_result,   n_persons = 1000,   seed = 123 )  # 5. (Optional) Validate achieved reliability with TAM tam_rel <- compute_reliability_tam(sim_data$response_matrix, model = \"rasch\")  # 6. Use the data for your simulation study # ... your analysis code here ..."},{"path":[]},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction_to_irtsimrel.html","id":"setting-target-reliability","dir":"Articles","previous_headings":"Practical Recommendations","what":"Setting Target Reliability","title":"Introduction to IRTsimrel","text":"Low reliability (0.50‚Äì0.65): Typical short formative assessments Moderate reliability (0.70‚Äì0.80): Common educational research High reliability (0.85+): Standardized tests; may require many items high discriminations","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction_to_irtsimrel.html","id":"when-target-reliability-cannot-be-achieved","dir":"Articles","previous_headings":"Practical Recommendations","what":"When Target Reliability Cannot Be Achieved","title":"Introduction to IRTsimrel","text":"EQC reports hitting upper bound, consider: Using reliability_metric = \"info\" (yields higher values) Increasing c_bounds[2] beyond default 3 Increasing n_items Accepting achievable maximum design","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction_to_irtsimrel.html","id":"further-resources","dir":"Articles","previous_headings":"","what":"Further Resources","title":"Introduction to IRTsimrel","text":"detailed information, see: vignette(\"latent-distributions\"): Working different latent trait distributions vignette(\"item-parameters\"): Generating realistic item parameters vignette(\"spc-algorithm\"): Advanced usage SPC algorithm vignette(\"validation\"): Comprehensive validation procedures","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction_to_irtsimrel.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Introduction to IRTsimrel","text":"Lee, J.-H. (2025). Reliability-targeted simulation item response data. arXiv Preprint. Robbins, H., & Monro, S. (1951). stochastic approximation method. Annals Mathematical Statistics, 22(3), 400‚Äì407. Zhang, L., Fellinghauer, C., Geerlings, H., & Sijtsma, K. (2025). Realistic simulation item difficulties using Item Response Warehouse. PsyArXiv. https://doi.org/10.31234/osf.io/r5mxv","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/item_parameters.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Generating Realistic Item Parameters","text":"sim_item_params() function generates item parameters (difficulty Œ≤\\beta discrimination Œª\\lambda) IRT simulation studies. designed four key principles: Realistic difficulties: Integration Item Response Warehouse (IRW) empirically-grounded difficulty distributions Correlated parameters: Support empirically-observed negative correlation difficulty discrimination Marginal preservation: copula method preserves exact marginal distributions Reliability targeting: scale factor enables subsequent calibration target reliability vignette covers: Sources difficulty generation Methods discrimination generation difficulty-discrimination correlation Generating multiple test forms Integration reliability-targeted calibration","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/item_parameters.html","id":"the-difficulty-discrimination-correlation","dir":"Articles","previous_headings":"","what":"The Difficulty-Discrimination Correlation","title":"Generating Realistic Item Parameters","text":"critical finding psychometric research item difficulty discrimination negatively correlated real assessments (Sweeney et al., 2022). : Easy items (Œ≤\\beta low) tend higher discrimination (Œª\\lambda high) Difficult items (Œ≤\\beta high) tend lower discrimination (Œª\\lambda low) correlation, typically around œÅ‚âà‚àí0.3\\rho \\approx -0.3, important implications: Ignoring produces unrealistic simulation data Standard independent generation misses structural feature correlation affects test information functions sim_item_params() handles default using copula method rho = -0.3.","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/item_parameters.html","id":"rasch-model","dir":"Articles","previous_headings":"Basic Usage","what":"Rasch Model","title":"Generating Realistic Item Parameters","text":"Rasch model, discriminations set 1:","code":"# Generate 25 Rasch items with IRW difficulties items_rasch <- sim_item_params(   n_items = 25,   model = \"rasch\",   source = \"irw\",   seed = 42 )  print(items_rasch) #> Item Parameters Object #> ====================== #>   Model          : RASCH #>   Source         : irw #>   Items per form : 25 #>   Number of forms: 1 #>   Scale factor   : 1.000 #>   Centered       : Yes #>  #> Difficulty (beta): #>   Mean: -0.0000, SD: 0.7992, Range: [-1.484, 1.469]"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item_parameters.html","id":"pl-model","dir":"Articles","previous_headings":"Basic Usage","what":"2PL Model","title":"Generating Realistic Item Parameters","text":"2PL model, difficulties discriminations generated: Notice achieved correlation Œ≤\\beta log(Œª)\\log(\\lambda) close target -0.3.","code":"# Generate 30 2PL items with correlated parameters items_2pl <- sim_item_params(   n_items = 30,   model = \"2pl\",   source = \"irw\",   method = \"copula\",   seed = 42 )  print(items_2pl) #> Item Parameters Object #> ====================== #>   Model          : 2PL #>   Source         : irw #>   Method         : copula #>   Items per form : 30 #>   Number of forms: 1 #>   Scale factor   : 1.000 #>   Centered       : Yes #>  #> Difficulty (beta): #>   Mean: -0.0000, SD: 0.8357, Range: [-1.607, 1.463] #>  #> Discrimination (lambda, scaled): #>   Mean: 1.0865, SD: 0.4031, Range: [0.590, 2.107] #>  #> Correlation (beta, log-lambda): #>   Target (rho): -0.300 #>   Achieved Pearson : -0.330 #>   Achieved Spearman: -0.466"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item_parameters.html","id":"sources-for-difficulty-generation","dir":"Articles","previous_headings":"","what":"Sources for Difficulty Generation","title":"Generating Realistic Item Parameters","text":"sim_item_params() supports four sources generating item difficulties:","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/item_parameters.html","id":"irw-item-response-warehouse","dir":"Articles","previous_headings":"Sources for Difficulty Generation","what":"1. IRW (Item Response Warehouse)","title":"Generating Realistic Item Parameters","text":"recommended source realistic simulations. IRW provides empirically-grounded difficulty distributions based thousands real assessment items. Requirements: irw package must installed:","code":"items_irw <- sim_item_params(   n_items = 25,   model = \"rasch\",   source = \"irw\",   seed = 42 )  # Examine difficulty distribution summary(items_irw$data$beta) #>     Min.  1st Qu.   Median     Mean  3rd Qu.     Max.  #> -1.48424 -0.54581 -0.08185  0.00000  0.48541  1.46931 # Install IRW package from GitHub devtools::install_github(\"itemresponsewarehouse/irw\")"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item_parameters.html","id":"parametric","dir":"Articles","previous_headings":"Sources for Difficulty Generation","what":"2. Parametric","title":"Generating Realistic Item Parameters","text":"Generate difficulties parametric distribution:","code":"# Normal distribution items_normal <- sim_item_params(   n_items = 25,   model = \"rasch\",   source = \"parametric\",   difficulty_params = list(     mu = 0,     sigma = 1,     distribution = \"normal\"   ),   seed = 42 )  # Uniform distribution items_uniform <- sim_item_params(   n_items = 25,   model = \"rasch\",   source = \"parametric\",   difficulty_params = list(     mu = 0,     sigma = 1,     distribution = \"uniform\"   ),   seed = 42 )"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item_parameters.html","id":"hierarchical","dir":"Articles","previous_headings":"Sources for Difficulty Generation","what":"3. Hierarchical","title":"Generating Realistic Item Parameters","text":"Joint bivariate normal generation following Glas & van der Linden (2003). log(Œª)\\log(\\lambda) Œ≤\\beta drawn multivariate normal: (log(Œªi)Œ≤i)‚àºN((ŒºŒªŒºŒ≤),(œÑŒª2œÅœÑŒªœÑŒ≤œÅœÑŒªœÑŒ≤œÑŒ≤2))\\begin{pmatrix} \\log(\\lambda_i) \\\\ \\beta_i \\end{pmatrix} \\sim N\\left( \\begin{pmatrix} \\mu_\\lambda \\\\ \\mu_\\beta \\end{pmatrix}, \\begin{pmatrix} \\tau_\\lambda^2 & \\rho \\tau_\\lambda \\tau_\\beta \\\\ \\rho \\tau_\\lambda \\tau_\\beta & \\tau_\\beta^2 \\end{pmatrix} \\right)","code":"items_hier <- sim_item_params(   n_items = 25,   model = \"2pl\",   source = \"hierarchical\",   hierarchical_params = list(     mu = c(0, 0),      # Means: (log-lambda, beta)     tau = c(0.25, 1),  # SDs     rho = -0.3         # Correlation   ),   seed = 42 )  print(items_hier) #> Item Parameters Object #> ====================== #>   Model          : 2PL #>   Source         : hierarchical #>   Items per form : 25 #>   Number of forms: 1 #>   Scale factor   : 1.000 #>   Centered       : Yes #>  #> Difficulty (beta): #>   Mean: -0.0000, SD: 1.3077, Range: [-2.863, 2.109] #>  #> Discrimination (lambda, scaled): #>   Mean: 1.0776, SD: 0.2710, Range: [0.720, 1.812] #>  #> Correlation (beta, log-lambda): #>   Target (rho): -0.300 #>   Achieved Pearson : -0.345 #>   Achieved Spearman: -0.375"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item_parameters.html","id":"custom","dir":"Articles","previous_headings":"Sources for Difficulty Generation","what":"4. Custom","title":"Generating Realistic Item Parameters","text":"Supply parameters directly: can also provide functions generate parameters:","code":"# Custom difficulties and discriminations items_custom <- sim_item_params(   n_items = 10,   model = \"2pl\",   source = \"custom\",   custom_params = list(     beta = seq(-2, 2, length.out = 10),     lambda = rep(1.2, 10)   ),   seed = 42 ) #> Warning in cor(df$beta, log(df$lambda_unscaled)): the standard deviation is #> zero #> Warning in cor(df$beta, log(df$lambda_unscaled), method = \"spearman\"): the #> standard deviation is zero #> Warning in cor(data$beta, log(data$lambda_unscaled)): the standard deviation is #> zero #> Warning in cor(data$beta, log(data$lambda_unscaled), method = \"spearman\"): the #> standard deviation is zero  items_custom$data #>    form_id item_id       beta lambda lambda_unscaled #> 1        1       1 -2.0000000    1.2             1.2 #> 2        1       2 -1.5555556    1.2             1.2 #> 3        1       3 -1.1111111    1.2             1.2 #> 4        1       4 -0.6666667    1.2             1.2 #> 5        1       5 -0.2222222    1.2             1.2 #> 6        1       6  0.2222222    1.2             1.2 #> 7        1       7  0.6666667    1.2             1.2 #> 8        1       8  1.1111111    1.2             1.2 #> 9        1       9  1.5555556    1.2             1.2 #> 10       1      10  2.0000000    1.2             1.2 items_custom_fn <- sim_item_params(   n_items = 20,   model = \"2pl\",   source = \"custom\",   custom_params = list(     beta = function(n) rnorm(n, 0, 1.5),     lambda = function(n) rlnorm(n, 0, 0.3)   ),   seed = 42 )"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item_parameters.html","id":"methods-for-discrimination-generation","dir":"Articles","previous_headings":"","what":"Methods for Discrimination Generation","title":"Generating Realistic Item Parameters","text":"using source = \"irw\" source = \"parametric\" model = \"2pl\", need specify discriminations generated. Three methods available:","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/item_parameters.html","id":"copula-method-recommended","dir":"Articles","previous_headings":"Methods for Discrimination Generation","what":"1. Copula Method (Recommended)","title":"Generating Realistic Item Parameters","text":"Gaussian copula method preserves exact marginal distributions achieving target correlation: Algorithm: Transform Œ≤\\beta uniform via empirical CDF: u=rank(Œ≤)/(n+1)u = \\text{rank}(\\beta) / (n+1) Transform normal: zŒ≤=Œ¶‚àí1(u)z_\\beta = \\Phi^{-1}(u) Generate correlated normal: zŒª=œÅ‚ãÖzŒ≤+1‚àíœÅ2‚ãÖzindepz_\\lambda = \\rho \\cdot z_\\beta + \\sqrt{1-\\rho^2} \\cdot z_{\\text{indep}} Transform uniform: v=Œ¶(zŒª)v = \\Phi(z_\\lambda) Transform log-normal: Œª=exp(Œº+œÉ‚ãÖŒ¶‚àí1(v))\\lambda = \\exp(\\mu + \\sigma \\cdot \\Phi^{-1}(v)) Copula Recommended: Preserves exact IRW difficulty distribution Guarantees log-normal marginal discriminations Achieves target Spearman correlation (robust non-normality) Works well difficulty distribution shape","code":"items_copula <- sim_item_params(   n_items = 100,   model = \"2pl\",   source = \"irw\",   method = \"copula\",   discrimination_params = list(     mu_log = 0,       # Mean of log(lambda)     sigma_log = 0.3,  # SD of log(lambda)     rho = -0.3        # Target correlation   ),   seed = 42 )  # Check achieved correlation cat(sprintf(\"Target rho: -0.30\\n\")) #> Target rho: -0.30 cat(sprintf(\"Achieved Spearman: %.3f\\n\",              items_copula$achieved$overall$cor_spearman_pooled)) #> Achieved Spearman: -0.191"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item_parameters.html","id":"conditional-method","dir":"Articles","previous_headings":"Methods for Discrimination Generation","what":"2. Conditional Method","title":"Generating Realistic Item Parameters","text":"Uses conditional normal regression: log(Œªi)‚à£Œ≤i‚àºN(Œºlog+œÅ‚ãÖœÉlog‚ãÖzŒ≤i,œÉlog1‚àíœÅ2)\\log(\\lambda_i) \\mid \\beta_i \\sim N\\left(\\mu_{\\log} + \\rho \\cdot \\sigma_{\\log} \\cdot z_{\\beta_i}, \\; \\sigma_{\\log}\\sqrt{1-\\rho^2}\\right) Note: conditional method assumes linear relationships normal errors. IRW difficulties non-normal, achieved correlations may differ targets.","code":"items_cond <- sim_item_params(   n_items = 100,   model = \"2pl\",   source = \"irw\",   method = \"conditional\",   discrimination_params = list(rho = -0.3),   seed = 42 )  cat(sprintf(\"Achieved Pearson:  %.3f\\n\",              items_cond$achieved$overall$cor_pearson_pooled)) #> Achieved Pearson:  -0.248 cat(sprintf(\"Achieved Spearman: %.3f\\n\",              items_cond$achieved$overall$cor_spearman_pooled)) #> Achieved Spearman: -0.207"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item_parameters.html","id":"independent-method","dir":"Articles","previous_headings":"Methods for Discrimination Generation","what":"3. Independent Method","title":"Generating Realistic Item Parameters","text":"Generates discriminations independently difficulties (correlation):","code":"items_indep <- sim_item_params(   n_items = 100,   model = \"2pl\",   source = \"irw\",   method = \"independent\",   seed = 42 )  cat(sprintf(\"Achieved correlation: %.3f (expected: ~0)\\n\",             items_indep$achieved$overall$cor_spearman_pooled)) #> Achieved correlation: 0.051 (expected: ~0)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item_parameters.html","id":"customizing-discrimination-parameters","dir":"Articles","previous_headings":"","what":"Customizing Discrimination Parameters","title":"Generating Realistic Item Parameters","text":"discrimination_params list controls log-normal distribution discriminations:","code":"# Higher average discrimination items_high_disc <- sim_item_params(   n_items = 30,   model = \"2pl\",   source = \"irw\",   method = \"copula\",   discrimination_params = list(     mu_log = 0.3,     # E[lambda] ‚âà exp(0.3) ‚âà 1.35     sigma_log = 0.25, # Less variation     rho = -0.3   ),   seed = 42 )  cat(sprintf(\"Mean lambda: %.3f\\n\", mean(items_high_disc$data$lambda))) #> Mean lambda: 1.435 cat(sprintf(\"SD lambda:   %.3f\\n\", sd(items_high_disc$data$lambda))) #> SD lambda:   0.435"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/item_parameters.html","id":"generating-multiple-test-forms","dir":"Articles","previous_headings":"","what":"Generating Multiple Test Forms","title":"Generating Realistic Item Parameters","text":"Generate multiple parallel forms independent item samples:","code":"items_5forms <- sim_item_params(   n_items = 20,   model = \"2pl\",   source = \"irw\",   method = \"copula\",   n_forms = 5,   seed = 42 )  # Check structure cat(sprintf(\"Total items: %d\\n\", nrow(items_5forms$data))) #> Total items: 100 cat(sprintf(\"Items per form: %d\\n\", items_5forms$n_items)) #> Items per form: 20 cat(sprintf(\"Number of forms: %d\\n\", items_5forms$n_forms)) #> Number of forms: 5  # View first few rows head(items_5forms$data, 10) #>    form_id item_id        beta    lambda lambda_unscaled #> 1        1       1 -0.31979479 0.9134159       0.9134159 #> 2        1       2 -0.13448739 1.1691256       1.1691256 #> 3        1       3  1.21101694 0.6461936       0.6461936 #> 4        1       4  0.07285940 1.2932730       1.2932730 #> 5        1       5 -1.41375360 1.2920870       1.2920870 #> 6        1       6  0.49929409 0.9477748       0.9477748 #> 7        1       7 -0.86741035 1.0869113       1.0869113 #> 8        1       8  0.71169376 0.9945658       0.9945658 #> 9        1       9  0.58379081 0.7129531       0.7129531 #> 10       1      10 -0.04531184 1.0322409       1.0322409"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item_parameters.html","id":"per-form-statistics","dir":"Articles","previous_headings":"Generating Multiple Test Forms","what":"Per-Form Statistics","title":"Generating Realistic Item Parameters","text":"","code":"# Access per-form statistics for (f in 1:3) {   stats <- items_5forms$achieved$by_form[[f]]   cat(sprintf(\"Form %d: beta_mean=%.3f, lambda_mean=%.3f, cor=%.3f\\n\",               f, stats$beta_mean, stats$lambda_mean, stats$cor_spearman)) } #> Form 1: beta_mean=0.000, lambda_mean=1.027, cor=-0.540 #> Form 2: beta_mean=0.000, lambda_mean=1.152, cor=-0.202 #> Form 3: beta_mean=0.000, lambda_mean=1.109, cor=-0.320"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item_parameters.html","id":"the-scale-parameter","dir":"Articles","previous_headings":"","what":"The Scale Parameter","title":"Generating Realistic Item Parameters","text":"scale parameter crucial reliability-targeted simulation. multiplies discriminations constant factor: Œªi*=c‚ãÖŒªi,0\\lambda_i^* = c \\cdot \\lambda_{,0} Œªi,0\\lambda_{,0} baseline discrimination cc scale factor.","code":"# Baseline (scale = 1) items_base <- sim_item_params(   n_items = 25,   model = \"2pl\",   source = \"irw\",   scale = 1,   seed = 42 )  # Scaled up (scale = 1.5) items_scaled <- sim_item_params(   n_items = 25,   model = \"2pl\",   source = \"irw\",   scale = 1.5,   seed = 42 )  cat(sprintf(\"Baseline mean lambda: %.3f\\n\", mean(items_base$data$lambda))) #> Baseline mean lambda: 1.026 cat(sprintf(\"Scaled mean lambda:   %.3f\\n\", mean(items_scaled$data$lambda))) #> Scaled mean lambda:   1.539 cat(sprintf(\"Ratio: %.2f\\n\",              mean(items_scaled$data$lambda) / mean(items_base$data$lambda))) #> Ratio: 1.50"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item_parameters.html","id":"unscaled-lambda","dir":"Articles","previous_headings":"The Scale Parameter","what":"Unscaled Lambda","title":"Generating Realistic Item Parameters","text":"output always includes lambda_unscaled reference:","code":"# Both are stored head(items_scaled$data[, c(\"lambda\", \"lambda_unscaled\")]) #>     lambda lambda_unscaled #> 1 1.556978       1.0379855 #> 2 1.496971       0.9979810 #> 3 1.501281       1.0008540 #> 4 1.152807       0.7685377 #> 5 1.852231       1.2348209 #> 6 1.592726       1.0618176  # Verify relationship all.equal(   items_scaled$data$lambda,   items_scaled$data$lambda_unscaled * items_scaled$scale ) #> [1] TRUE"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item_parameters.html","id":"centering-difficulties","dir":"Articles","previous_headings":"","what":"Centering Difficulties","title":"Generating Realistic Item Parameters","text":"default, difficulties centered sum zero (model identification):","code":"# Default: centered items_centered <- sim_item_params(   n_items = 25,   model = \"rasch\",   source = \"irw\",   center_difficulties = TRUE,   seed = 42 )  # Uncentered items_uncentered <- sim_item_params(   n_items = 25,   model = \"rasch\",   source = \"irw\",   center_difficulties = FALSE,   seed = 42 )  cat(sprintf(\"Centered mean:   %.6f\\n\", mean(items_centered$data$beta))) #> Centered mean:   -0.000000 cat(sprintf(\"Uncentered mean: %.6f\\n\", mean(items_uncentered$data$beta))) #> Uncentered mean: 0.018108"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item_parameters.html","id":"visualization","dir":"Articles","previous_headings":"","what":"Visualization","title":"Generating Realistic Item Parameters","text":"plot() method provides diagnostic visualizations:","code":"items_viz <- sim_item_params(   n_items = 50,   model = \"2pl\",   source = \"irw\",   method = \"copula\",   seed = 42 )  # Scatter plot with regression line plot(items_viz, type = \"scatter\") #> `geom_smooth()` using formula = 'y ~ x' # Density plots plot(items_viz, type = \"density\") # Combined view (requires patchwork package) plot(items_viz, type = \"both\")"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item_parameters.html","id":"integration-with-eqc_calibrate","dir":"Articles","previous_headings":"","what":"Integration with eqc_calibrate","title":"Generating Realistic Item Parameters","text":"reliability-targeted simulation framework, sim_item_params() called internally eqc_calibrate(). specify item generation settings item_source item_params arguments:","code":"# EQC automatically calls sim_item_params internally eqc_result <- eqc_calibrate(   target_rho = 0.80,   n_items = 25,   model = \"2pl\",   latent_shape = \"normal\",   item_source = \"irw\",   item_params = list(     discrimination_params = list(       mu_log = 0,       sigma_log = 0.3,       rho = -0.3     )   ),   seed = 42 )  # The calibrated items are accessible print(eqc_result$items_calib)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item_parameters.html","id":"accessing-calibrated-items","dir":"Articles","previous_headings":"Integration with eqc_calibrate","what":"Accessing Calibrated Items","title":"Generating Realistic Item Parameters","text":"calibration, can access baseline calibrated item parameters:","code":"# Baseline items (scale = 1) items_base <- eqc_result$items_base  # Calibrated items (scale = c*) items_calib <- eqc_result$items_calib  # The calibration factor c_star <- eqc_result$c_star"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item_parameters.html","id":"working-with-the-output-object","dir":"Articles","previous_headings":"","what":"Working with the Output Object","title":"Generating Realistic Item Parameters","text":"item_params object contains rich information:","code":"items <- sim_item_params(n_items = 25, model = \"2pl\", source = \"irw\", seed = 42)  # Structure names(items) #>  [1] \"data\"     \"model\"    \"source\"   \"method\"   \"n_items\"  \"n_forms\"  #>  [7] \"scale\"    \"centered\" \"params\"   \"achieved\"  # Extract as data frame df <- as.data.frame(items) head(df) #>   form_id item_id         beta    lambda lambda_unscaled #> 1       1       1 -0.390285351 1.0379855       1.0379855 #> 2       1       2 -0.204977951 0.9979810       0.9979810 #> 3       1       3  1.140526381 1.0008540       1.0008540 #> 4       1       4  0.002368838 0.7685377       0.7685377 #> 5       1       5 -1.484244154 1.2348209       1.2348209 #> 6       1       6  0.428803529 1.0618176       1.0618176  # Achieved statistics items$achieved$overall #> $n_total #> [1] 25 #>  #> $beta_mean #> [1] -2.664535e-17 #>  #> $beta_sd #> [1] 0.7991656 #>  #> $lambda_mean #> [1] 1.025717 #>  #> $lambda_sd #> [1] 0.3127527 #>  #> $cor_pearson_pooled #> [1] -0.2009709 #>  #> $cor_spearman_pooled #> [1] -0.3484615"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item_parameters.html","id":"comparison-of-methods","dir":"Articles","previous_headings":"","what":"Comparison of Methods","title":"Generating Realistic Item Parameters","text":"Let‚Äôs compare three discrimination generation methods: copula method achieves target Spearman correlation reliably.","code":"set.seed(123)  methods <- c(\"copula\", \"conditional\", \"independent\") results <- list()  for (m in methods) {   results[[m]] <- sim_item_params(     n_items = 200,     model = \"2pl\",     source = \"irw\",     method = m,     discrimination_params = list(rho = -0.4),     seed = 123   ) }  # Compare achieved correlations cat(\"Method Comparison (target rho = -0.4):\\n\") #> Method Comparison (target rho = -0.4): cat(\"======================================\\n\") #> ====================================== for (m in methods) {   cat(sprintf(\"%-12s: Pearson = %+.3f, Spearman = %+.3f\\n\",               m,               results[[m]]$achieved$overall$cor_pearson_pooled,               results[[m]]$achieved$overall$cor_spearman_pooled)) } #> copula      : Pearson = -0.526, Spearman = -0.527 #> conditional : Pearson = -0.495, Spearman = -0.466 #> independent : Pearson = -0.077, Spearman = -0.045"},{"path":[]},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/item_parameters.html","id":"for-realistic-simulations","dir":"Articles","previous_headings":"Practical Recommendations","what":"For Realistic Simulations","title":"Generating Realistic Item Parameters","text":"","code":"items <- sim_item_params(   n_items = 30,   model = \"2pl\",   source = \"irw\",           # Use IRW   method = \"copula\",        # Preserve marginals   discrimination_params = list(     mu_log = 0,     sigma_log = 0.3,     rho = -0.3              # Empirical correlation   ),   seed = 42 )"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item_parameters.html","id":"for-controlled-experiments","dir":"Articles","previous_headings":"Practical Recommendations","what":"For Controlled Experiments","title":"Generating Realistic Item Parameters","text":"","code":"items <- sim_item_params(   n_items = 25,   model = \"2pl\",   source = \"parametric\",   difficulty_params = list(mu = 0, sigma = 1),   method = \"conditional\",   discrimination_params = list(     mu_log = 0,     sigma_log = 0.25,     rho = 0                 # No correlation for clean design   ),   seed = 42 )"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item_parameters.html","id":"for-bayesian-frameworks","dir":"Articles","previous_headings":"Practical Recommendations","what":"For Bayesian Frameworks","title":"Generating Realistic Item Parameters","text":"","code":"items <- sim_item_params(   n_items = 25,   model = \"2pl\",   source = \"hierarchical\",   hierarchical_params = list(     mu = c(0, 0),     tau = c(0.3, 1),     rho = -0.3   ),   seed = 42 )"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item_parameters.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Generating Realistic Item Parameters","text":"Glas, C. . W., & van der Linden, W. J. (2003). Computerized adaptive testing item cloning. Applied Psychological Measurement, 27(4), 247-261. Sweeney, S. M., et al.¬†(2022). investigation nature consequence relationship IRT difficulty discrimination. Educational Measurement: Issues Practice, 41(4), 50-67. Zhang, L., Fellinghauer, C., Geerlings, H., & Sijtsma, K. (2025). Realistic simulation item difficulties using Item Response Warehouse. PsyArXiv. https://doi.org/10.31234/osf.io/r5mxv","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent_distributions.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Working with Latent Distributions","text":"sim_latentG() function generates latent abilities (person parameters Œ∏\\theta) IRT simulation studies. implements population model: Œ∏p‚àºG\\theta_p \\sim G GG flexible distribution family can take many different shapes. vignette covers: pre-standardization principle Available distribution shapes Customizing shape parameters Creating custom mixture distributions Adding covariate effects Visualization tools","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent_distributions.html","id":"the-pre-standardization-principle","dir":"Articles","previous_headings":"","what":"The Pre-Standardization Principle","title":"Working with Latent Distributions","text":"key design feature sim_latentG() pre-standardization: every built-distribution shape mathematically constructed mean 0 variance 1 scaling applied. ensures : Changing shape inadvertently change scale sigma parameter directly controls standard deviation Comparisons across shapes meaningful generated abilities follow: Œ∏p=Œº+Xp‚ä§Œ≤+œÉ‚ãÖzp\\theta_p = \\mu + X_p^\\top \\beta + \\sigma \\cdot z_p zp‚àºG0z_p \\sim G_0 ùîº[z]=0\\mathbb{E}[z] = 0 Var[z]=1\\text{Var}[z] = 1.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent_distributions.html","id":"why-this-matters","dir":"Articles","previous_headings":"The Pre-Standardization Principle","what":"Why This Matters","title":"Working with Latent Distributions","text":"traditional simulation approaches, changing latent distribution often changes shape scale simultaneously. example, switching N(0,1)N(0, 1) Gamma(4,1)\\text{Gamma}(4, 1) changes just shape also variance. pre-standardization, can study effect distributional shape IRT estimation holding variance constant‚Äîcleaner experimental design.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent_distributions.html","id":"basic-usage","dir":"Articles","previous_headings":"","what":"Basic Usage","title":"Working with Latent Distributions","text":"output shows: Target mu/sigma: requested location scale Sample Moments: Empirical mean, SD, skewness, excess kurtosis","code":"# Generate 1000 standard normal abilities sim_normal <- sim_latentG(n = 1000, shape = \"normal\", seed = 42)  # Examine the result print(sim_normal) #> Latent Ability Distribution (G-family) #> ======================================= #>   Shape     : normal #>   n         : 1000 #>   Target mu : 0.000 #>   Target sigma: 1.000 #>  #> Sample Moments: #>   Mean      : -0.0258 #>   SD        : 1.0025 #>   Skewness  : -0.0038 #>   Kurtosis  : 0.1286 (excess) # Verify standardization cat(sprintf(\"Sample mean: %.4f (target: 0)\\n\", mean(sim_normal$theta))) #> Sample mean: -0.0258 (target: 0) cat(sprintf(\"Sample SD:   %.4f (target: 1)\\n\", sd(sim_normal$theta))) #> Sample SD:   1.0025 (target: 1)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent_distributions.html","id":"available-distribution-shapes","dir":"Articles","previous_headings":"","what":"Available Distribution Shapes","title":"Working with Latent Distributions","text":"sim_latentG() provides 12 built-shapes, pre-standardized mean 0 variance 1.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent_distributions.html","id":"standard-normal","dir":"Articles","previous_headings":"Available Distribution Shapes","what":"Standard Normal","title":"Working with Latent Distributions","text":"baseline case: z‚àºN(0,1)z \\sim N(0, 1)","code":"sim_normal <- sim_latentG(n = 2000, shape = \"normal\", seed = 1) plot(sim_normal, show_normal = TRUE)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent_distributions.html","id":"bimodal-distribution","dir":"Articles","previous_headings":"Available Distribution Shapes","what":"Bimodal Distribution","title":"Working with Latent Distributions","text":"symmetric two-component Gaussian mixture, useful representing populations two distinct subgroups (e.g., native vs.¬†non-native speakers). Mathematical construction: z=s‚ãÖŒ¥+œµ,s‚àºRademacher(¬±1),œµ‚àºN(0,1‚àíŒ¥2)z = s \\cdot \\delta + \\epsilon, \\quad s \\sim \\text{Rademacher}(\\pm 1), \\quad \\epsilon \\sim N(0, 1 - \\delta^2) component variance 1‚àíŒ¥21 - \\delta^2 ensures Var[z]=Œ¥2+(1‚àíŒ¥2)=1\\text{Var}[z] = \\delta^2 + (1 - \\delta^2) = 1.  Customizing mode separation: delta parameter controls far apart modes (0 < delta < 1):","code":"sim_bimodal <- sim_latentG(n = 2000, shape = \"bimodal\", seed = 1) plot(sim_bimodal, show_normal = TRUE) # Wider separation sim_bimodal_wide <- sim_latentG(   n = 2000,    shape = \"bimodal\",    shape_params = list(delta = 0.95),   seed = 1 ) plot(sim_bimodal_wide, show_normal = TRUE)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent_distributions.html","id":"trimodal-distribution","dir":"Articles","previous_headings":"Available Distribution Shapes","what":"Trimodal Distribution","title":"Working with Latent Distributions","text":"symmetric three-component mixture central peak two side peaks. Mathematical construction: Components {‚àím,0,+m}\\{-m, 0, +m\\} weights (wL,w0,wR)(w_L, w_0, w_R) wL=wR=(1‚àíw0)/2w_L = w_R = (1 - w_0)/2. Component variance: œÉc2=1‚àí(1‚àíw0)m2\\sigma_c^2 = 1 - (1 - w_0) m^2  Customizing:","code":"sim_trimodal <- sim_latentG(n = 2000, shape = \"trimodal\", seed = 1) plot(sim_trimodal, show_normal = TRUE) # Stronger central peak sim_trimodal_central <- sim_latentG(   n = 2000,   shape = \"trimodal\",   shape_params = list(     w0 = 0.5,   # Weight of central component (default: 1/3)     m = 1.3     # Location of side components (default: 1.2)   ),   seed = 1 ) plot(sim_trimodal_central, show_normal = TRUE)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent_distributions.html","id":"multimodal-four-components","dir":"Articles","previous_headings":"Available Distribution Shapes","what":"Multimodal (Four Components)","title":"Working with Latent Distributions","text":"symmetric four-component mixture modes {‚àím2,‚àím1,+m1,+m2}\\{-m_2, -m_1, +m_1, +m_2\\}.","code":"sim_multi <- sim_latentG(n = 2000, shape = \"multimodal\", seed = 1) plot(sim_multi, show_normal = TRUE)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent_distributions.html","id":"skewed-distributions","dir":"Articles","previous_headings":"Available Distribution Shapes","what":"Skewed Distributions","title":"Working with Latent Distributions","text":"Right-skewed (skew_pos): Based standardized Gamma distribution: z=Œì(k,1)‚àíkkz = \\frac{\\Gamma(k, 1) - k}{\\sqrt{k}} ùîº[z]=0\\mathbb{E}[z] = 0 Var[z]=1\\text{Var}[z] = 1 k>0k > 0.  Left-skewed (skew_neg): Simply negation right-skewed distribution.  Controlling skewness magnitude: k parameter (Gamma shape) controls skewness‚Äîsmaller values = skewed:","code":"sim_skew_pos <- sim_latentG(n = 2000, shape = \"skew_pos\", seed = 1) plot(sim_skew_pos, show_normal = TRUE) sim_skew_neg <- sim_latentG(n = 2000, shape = \"skew_neg\", seed = 1) plot(sim_skew_neg, show_normal = TRUE) # More extreme skewness (k = 2) sim_very_skew <- sim_latentG(   n = 2000,   shape = \"skew_pos\",   shape_params = list(k = 2),   seed = 1 )  cat(sprintf(\"Default k=4 skewness: %.3f\\n\", sim_skew_pos$sample_moments$skewness)) #> Default k=4 skewness: 0.812 cat(sprintf(\"k=2 skewness:         %.3f\\n\", sim_very_skew$sample_moments$skewness)) #> k=2 skewness:         1.244"},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent_distributions.html","id":"heavy-tailed-distribution","dir":"Articles","previous_headings":"Available Distribution Shapes","what":"Heavy-Tailed Distribution","title":"Working with Latent Distributions","text":"Based standardized Student-t: z=tŒΩŒΩ/(ŒΩ‚àí2)z = \\frac{t_\\nu}{\\sqrt{\\nu / (\\nu - 2)}} Var[z]=1\\text{Var}[z] = 1 ŒΩ>2\\nu > 2.  Controlling tail heaviness: df parameter (degrees freedom) controls tail weight‚Äîsmaller values = heavier tails:","code":"sim_heavy <- sim_latentG(n = 2000, shape = \"heavy_tail\", seed = 1) plot(sim_heavy, show_normal = TRUE) # Very heavy tails (df = 3) sim_very_heavy <- sim_latentG(   n = 2000,   shape = \"heavy_tail\",   shape_params = list(df = 3),   seed = 1 )  cat(sprintf(\"Default df=5 kurtosis: %.3f\\n\", sim_heavy$sample_moments$kurtosis)) #> Default df=5 kurtosis: 2.924 cat(sprintf(\"df=3 kurtosis:         %.3f\\n\", sim_very_heavy$sample_moments$kurtosis)) #> df=3 kurtosis:         7.956"},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent_distributions.html","id":"light-tailed-platykurtic-distribution","dir":"Articles","previous_headings":"Available Distribution Shapes","what":"Light-Tailed (Platykurtic) Distribution","title":"Working with Latent Distributions","text":"mixture distribution approximating platykurtic shape (negative excess kurtosis).","code":"sim_light <- sim_latentG(n = 2000, shape = \"light_tail\", seed = 1) plot(sim_light, show_normal = TRUE)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent_distributions.html","id":"uniform-distribution","dir":"Articles","previous_headings":"Available Distribution Shapes","what":"Uniform Distribution","title":"Working with Latent Distributions","text":"Uniform [‚àí3,+3][-\\sqrt{3}, +\\sqrt{3}], mean 0 variance 1.","code":"sim_uniform <- sim_latentG(n = 2000, shape = \"uniform\", seed = 1) plot(sim_uniform, show_normal = TRUE)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent_distributions.html","id":"floor-and-ceiling-effects","dir":"Articles","previous_headings":"Available Distribution Shapes","what":"Floor and Ceiling Effects","title":"Working with Latent Distributions","text":"represent situations ‚Äôs concentration examinees one end ability distribution. Floor effect: Heavy component near lower bound (e.g., many low-ability students difficult test)  Ceiling effect: Heavy component near upper bound (e.g., many high-ability students easy test)","code":"sim_floor <- sim_latentG(n = 2000, shape = \"floor\", seed = 1) plot(sim_floor, show_normal = TRUE) sim_ceiling <- sim_latentG(n = 2000, shape = \"ceiling\", seed = 1) plot(sim_ceiling, show_normal = TRUE)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent_distributions.html","id":"comparing-multiple-shapes","dir":"Articles","previous_headings":"","what":"Comparing Multiple Shapes","title":"Working with Latent Distributions","text":"compare_shapes() function provides convenient way visualize multiple distributions side--side:","code":"compare_shapes(   n = 3000,   shapes = c(\"normal\", \"bimodal\", \"trimodal\",               \"skew_pos\", \"heavy_tail\", \"uniform\"),   sigma = 1,   seed = 42 )"},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent_distributions.html","id":"custom-mixture-distributions","dir":"Articles","previous_headings":"","what":"Custom Mixture Distributions","title":"Working with Latent Distributions","text":"maximum flexibility, use shape = \"custom\" mixture_spec:  default, custom mixtures automatically post-standardized mean 0 variance 1. disable :","code":"# Define a custom 3-component mixture sim_custom <- sim_latentG(  n = 2000,   shape = \"custom\",   mixture_spec = list(     weights = c(0.3, 0.5, 0.2),   # Must sum to 1     means = c(-1.5, 0, 2),        # Component means     sds = c(0.5, 0.7, 0.5)        # Component SDs   ),   seed = 1 )  plot(sim_custom, show_normal = TRUE) # Keep raw mixture parameters sim_raw <- sim_latentG(   n = 2000,   shape = \"custom\",   mixture_spec = list(     weights = c(0.5, 0.5),     means = c(-1, 1),     sds = c(0.5, 0.5)   ),   standardize_custom = FALSE,   seed = 1 )"},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent_distributions.html","id":"adjusting-location-and-scale","dir":"Articles","previous_headings":"","what":"Adjusting Location and Scale","title":"Working with Latent Distributions","text":"mu sigma parameters allow shift scale distribution: works shape:","code":"# Generate abilities with mean 100 and SD 15 (like IQ scores) sim_iq <- sim_latentG(   n = 1000,   shape = \"normal\",   mu = 100,   sigma = 15,   seed = 42 )  summary(sim_iq) #> Summary: Latent Ability Distribution #> ==================================== #>   Shape      : normal #>   n          : 1000 #>   Target     : mu = 100.00, sigma = 15.00 #>   Covariates : No #>  #> Sample Statistics: #>   Mean       : 99.6126 #>   SD         : 15.0378 #>   Median     : 99.8030 #>   Skewness   : -0.0038 #>   Kurtosis   : 0.1286 (excess) #>   Range      : [49.4239, 152.4296] #>  #> Quantiles: #>     2.5%       5%      25%      50%      75%      95%    97.5%  #>  69.8816  75.3193  89.8681  99.8030 109.9601 123.0023 128.1655 # Bimodal with different scale sim_bimodal_scaled <- sim_latentG(   n = 1000,   shape = \"bimodal\",   mu = 0,   sigma = 1.5,  # Larger spread   seed = 42 )  cat(sprintf(\"Sample SD: %.3f (target: 1.5)\\n\", sd(sim_bimodal_scaled$theta))) #> Sample SD: 1.481 (target: 1.5)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent_distributions.html","id":"adding-covariate-effects","dir":"Articles","previous_headings":"","what":"Adding Covariate Effects","title":"Working with Latent Distributions","text":"can incorporate person-level covariates affect ability: full model : Œ∏p=Œº+Xp‚ä§Œ≤+œÉ‚ãÖzp\\theta_p = \\mu + X_p^\\top \\beta + \\sigma \\cdot z_p XpX_p covariate vector person pp.","code":"# Create covariate data n <- 1000 set.seed(42) group <- rbinom(n, 1, 0.5)           # Binary group indicator ses <- rnorm(n)                       # Continuous SES measure  # Generate abilities with covariate effects sim_cov <- sim_latentG(   n = n,   shape = \"normal\",   xcov = data.frame(group = group, ses = ses),   beta = c(0.5, 0.3),  # Group effect = 0.5, SES effect = 0.3   seed = 42 )  # Verify covariate effects cat(\"Mean ability by group:\\n\") #> Mean ability by group: cat(sprintf(\"  Group 0: %.3f\\n\", mean(sim_cov$theta[group == 0]))) #>   Group 0: -0.084 cat(sprintf(\"  Group 1: %.3f\\n\", mean(sim_cov$theta[group == 1]))) #>   Group 1: 0.519 cat(sprintf(\"  Difference: %.3f (expected: 0.5)\\n\",              mean(sim_cov$theta[group == 1]) - mean(sim_cov$theta[group == 0]))) #>   Difference: 0.602 (expected: 0.5)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent_distributions.html","id":"working-with-the-output-object","dir":"Articles","previous_headings":"","what":"Working with the Output Object","title":"Working with Latent Distributions","text":"sim_latentG() function returns latent_G object containing:","code":"sim <- sim_latentG(n = 100, shape = \"bimodal\", seed = 1)  # Available components names(sim) #> [1] \"theta\"          \"mu\"             \"sigma\"          \"eta_cov\"        #> [5] \"shape\"          \"shape_params\"   \"n\"              \"sample_moments\" #> [9] \"z\"  # The theta vector head(sim$theta) #> [1] -0.5611365  0.4327842 -0.5953282 -1.4776179  1.6598142  0.3882399  # The standardized z values (before scaling) head(sim$z) #> [1] -0.5611365  0.4327842 -0.5953282 -1.4776179  1.6598142  0.3882399  # Sample moments sim$sample_moments #> $mean #> [1] 0.005452304 #>  #> $sd #> [1] 0.9591602 #>  #> $skewness #> [1] -0.1115873 #>  #> $kurtosis #> [1] -1.109185"},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent_distributions.html","id":"extracting-theta-for-other-uses","dir":"Articles","previous_headings":"Working with the Output Object","what":"Extracting theta for Other Uses","title":"Working with Latent Distributions","text":"","code":"# Get theta as a numeric vector theta_vec <- sim$theta  # Use in your own analysis mean(theta_vec) #> [1] 0.005452304"},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent_distributions.html","id":"connection-to-irt-framework","dir":"Articles","previous_headings":"","what":"Connection to IRT Framework","title":"Working with Latent Distributions","text":"Rasch/2PL model, latent distribution GG affects key quantities:","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent_distributions.html","id":"marginal-reliability","dir":"Articles","previous_headings":"Connection to IRT Framework","what":"Marginal Reliability","title":"Working with Latent Distributions","text":"w‚Äæ=œÉŒ∏2œÉŒ∏2+MSEM\\bar{w} = \\frac{\\sigma^2_\\theta}{\\sigma^2_\\theta + \\text{MSEM}} MSEM mean squared error measurement.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent_distributions.html","id":"expected-test-information","dir":"Articles","previous_headings":"Connection to IRT Framework","what":"Expected Test Information","title":"Working with Latent Distributions","text":"ùí•‚Äæ=ùîºG[ùí•(Œ∏)]\\bar{\\mathcal{J}} = \\mathbb{E}_G[\\mathcal{J}(\\theta)] Different latent shapes produce different expected information profiles, even identical item parameters.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent_distributions.html","id":"identifiability","dir":"Articles","previous_headings":"Connection to IRT Framework","what":"Identifiability","title":"Working with Latent Distributions","text":"model identification Rasch model, typically fix either: ùîº[Œ∏]=0\\mathbb{E}[\\theta] = 0 (location constraint), ‚àëiŒ≤i=0\\sum_i \\beta_i = 0 (item constraint) sim_latentG() function generates abilities mean 0 default, supporting first identification approach.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent_distributions.html","id":"using-sim_latentg-with-eqc_calibrate","dir":"Articles","previous_headings":"","what":"Using sim_latentG with eqc_calibrate","title":"Working with Latent Distributions","text":"using sim_latentG() part reliability-targeted simulation, specify parameters eqc_calibrate():","code":"# Calibrate for a bimodal population eqc_result <- eqc_calibrate(   target_rho = 0.80,   n_items = 25,   model = \"rasch\",   latent_shape = \"bimodal\",   latent_params = list(delta = 0.8),   seed = 42 )  # Generate response data with the same distribution sim_data <- simulate_response_data(   eqc_result = eqc_result,   n_persons = 1000,   latent_shape = \"bimodal\",   latent_params = list(delta = 0.8),   seed = 123 )"},{"path":[]},{"path":[]},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent_distributions.html","id":"sample-size-considerations","dir":"Articles","previous_headings":"Practical Recommendations","what":"Sample Size Considerations","title":"Working with Latent Distributions","text":"stable Monte Carlo estimates: M = 10,000 eqc_calibrate() quadrature n = 500‚Äì2000 per replication simulation studies Increase n heavy-tailed highly multimodal shapes","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent_distributions.html","id":"reproducibility","dir":"Articles","previous_headings":"Practical Recommendations","what":"Reproducibility","title":"Working with Latent Distributions","text":"Always set seed reproducible results:","code":"sim1 <- sim_latentG(n = 100, shape = \"normal\", seed = 42) sim2 <- sim_latentG(n = 100, shape = \"normal\", seed = 42) identical(sim1$theta, sim2$theta)  # TRUE #> [1] TRUE"},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent_distributions.html","id":"further-reading","dir":"Articles","previous_headings":"","what":"Further Reading","title":"Working with Latent Distributions","text":"theoretical background latent distributions IRT, see: Baker, F. B., & Kim, S.-H. (2004). Item Response Theory: Parameter Estimation Techniques (2nd ed.). Marcel Dekker. Paganin, S., et al.¬†(2023). Computational strategies estimation performance Bayesian semiparametric item response theory models. Journal Educational Behavioral Statistics, 48(2), 147-188. information pre-standardization mathematics, see Appendix F IRTsimrel paper.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/spc_algorithm.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Algorithm 2: Stochastic Approximation Calibration (SPC)","text":"Stochastic Approximation Calibration (SPC) secondary algorithm IRTsimrel, designed complement EQC (Algorithm 1). SPC uses Robbins-Monro stochastic approximation framework find discrimination scaling factor c*c^* achieves target reliability.","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/spc_algorithm.html","id":"the-robbins-monro-algorithm","dir":"Articles","previous_headings":"Mathematical Foundation","what":"The Robbins-Monro Algorithm","title":"Algorithm 2: Stochastic Approximation Calibration (SPC)","text":"SPC implements classic Robbins-Monro (1951) stochastic approximation solving equation: g(c)=ùîº[œÅÃÇ(c)]‚àíœÅ*=0g(c) = \\mathbb{E}[\\hat{\\rho}(c)] - \\rho^* = 0 iterative update rule : cn+1=cn‚àí‚ãÖ(œÅÃÇn‚àíœÅ*)c_{n+1} = c_n - a_n \\cdot (\\hat{\\rho}_n - \\rho^*) : cnc_n current scaling factor estimate œÅÃÇn\\hat{\\rho}_n noisy reliability estimate iteration nn œÅ*\\rho^* target reliability ana_n decreasing step size sequence","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/spc_algorithm.html","id":"step-size-sequence","dir":"Articles","previous_headings":"Mathematical Foundation","what":"Step Size Sequence","title":"Algorithm 2: Stochastic Approximation Calibration (SPC)","text":"step sizes follow: =(n+)Œ≥a_n = \\frac{}{(n + )^\\gamma} : >0a > 0 base step size ‚â•0A \\geq 0 stabilization constant Œ≥‚àà(0.5,1]\\gamma \\(0.5, 1] decay exponent sequence satisfies Robbins-Monro conditions: ‚àën=1‚àû=‚àû‚àën=1‚àûan2<‚àû\\sum_{n=1}^{\\infty} a_n = \\infty \\quad \\text{} \\quad \\sum_{n=1}^{\\infty} a_n^2 < \\infty","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/spc_algorithm.html","id":"polyak-ruppert-averaging","dir":"Articles","previous_headings":"Mathematical Foundation","what":"Polyak-Ruppert Averaging","title":"Algorithm 2: Stochastic Approximation Calibration (SPC)","text":"Instead using final iterate cNc_N, SPC computes Polyak-Ruppert average post-burn-iterates: c*=1N‚àíB‚àën=B+1Ncnc^* = \\frac{1}{N - B} \\sum_{n=B+1}^{N} c_n BB burn-period. averaging accelerates convergence reduces variance.","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/spc_algorithm.html","id":"simple-spc-calibration","dir":"Articles","previous_headings":"Basic Usage","what":"Simple SPC Calibration","title":"Algorithm 2: Stochastic Approximation Calibration (SPC)","text":"","code":"# Basic SPC calibration spc_result <- spc_calibrate(   target_rho = 0.75,   n_items = 20,   model = \"rasch\",   n_iter = 200,   seed = 42,   verbose = FALSE ) #> Warning in regularize.values(x, y, ties, missing(ties), na.rm = na.rm): #> collapsing to unique 'x' values  print(spc_result) #>  #> ======================================================= #>   Stochastic Approximation Calibration (SPC) Results #> ======================================================= #>  #> Calibration Summary: #>   Model                        : RASCH #>   Target reliability (rho*)    : 0.7500 #>   Achieved reliability         : 0.7352 #>   Absolute error               : 1.48e-02 #>   Scaling factor (c*)          : 1.0441 #>  #> Algorithm Settings: #>   Number of items (I)          : 20 #>   M per iteration              : 500 #>   M for variance pre-calc      : 10000 #>   Total iterations             : 200 #>   Burn-in                      : 100 #>   Reliability metric           : MSEM-based (bar/w) #>   Step params: a=1.00, A=50, gamma=0.67 #>  #> Convergence Diagnostics: #>   Initialization method        : apc_warm_start #>   Initial c_0                  : 1.2853 #>   Final iterate c_n            : 1.0198 #>   Polyak-Ruppert c*            : 1.0441 #>   Pre-calculated theta_var     : 1.0123 #>   Converged                    : Yes #>   Post-burn-in SD              : 0.0158 #>   Final gradient (rho - rho*)  : +0.0397"},{"path":"https://joonho112.github.io/IRTsimrel/articles/spc_algorithm.html","id":"recommended-warm-start-from-eqc","dir":"Articles","previous_headings":"Basic Usage","what":"Recommended: Warm Start from EQC","title":"Algorithm 2: Stochastic Approximation Calibration (SPC)","text":"best results, use EQC initialize SPC:","code":"# Step 1: Run EQC eqc_result <- eqc_calibrate(   target_rho = 0.80,   n_items = 25,   model = \"rasch\",   seed = 42 ) #> Note: Target rho* = 0.800 is near the achievable maximum (0.824) for this configuration.  # Step 2: Validate with SPC (warm start) spc_result <- spc_calibrate(   target_rho = 0.80,   n_items = 25,   model = \"rasch\",   c_init = eqc_result,  # Pass EQC result directly!   n_iter = 200,   seed = 42 )  # Compare results compare_eqc_spc(eqc_result, spc_result) #>  #> ======================================================= #>   EQC vs SPC Comparison #> ======================================================= #>  #>   Target reliability  : 0.8000 #>   EQC c*              : 0.908219 #>   SPC c*              : 0.987060 #>   Absolute difference : 0.078841 #>   Percent difference  : 8.68% #>   Agreement (< 5%)    : NO"},{"path":"https://joonho112.github.io/IRTsimrel/articles/spc_algorithm.html","id":"understanding-the-output","dir":"Articles","previous_headings":"","what":"Understanding the Output","title":"Algorithm 2: Stochastic Approximation Calibration (SPC)","text":"spc_result object contains:","code":"names(spc_result) #>  [1] \"c_star\"         \"c_final\"        \"target_rho\"     \"achieved_rho\"   #>  [5] \"theta_var\"      \"trajectory\"     \"rho_trajectory\" \"metric\"         #>  [9] \"model\"          \"n_items\"        \"n_iter\"         \"burn_in\"        #> [13] \"M_per_iter\"     \"M_pre\"          \"step_params\"    \"c_bounds\"       #> [17] \"c_init\"         \"init_method\"    \"convergence\"    \"call\""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/spc_algorithm.html","id":"accessing-results","dir":"Articles","previous_headings":"Understanding the Output","what":"Accessing Results","title":"Algorithm 2: Stochastic Approximation Calibration (SPC)","text":"","code":"# Calibrated scaling factor cat(sprintf(\"Polyak-Ruppert c*: %.4f\\n\", spc_result$c_star)) #> Polyak-Ruppert c*: 0.9871 cat(sprintf(\"Final iterate c_N: %.4f\\n\", spc_result$c_final)) #> Final iterate c_N: 0.9881  # Convergence status cat(sprintf(\"Converged: %s\\n\", spc_result$convergence$converged)) #> Converged: TRUE cat(sprintf(\"Post-burn-in SD: %.4f\\n\", spc_result$convergence$sd_post_burn)) #> Post-burn-in SD: 0.0037"},{"path":"https://joonho112.github.io/IRTsimrel/articles/spc_algorithm.html","id":"visualizing-convergence","dir":"Articles","previous_headings":"","what":"Visualizing Convergence","title":"Algorithm 2: Stochastic Approximation Calibration (SPC)","text":"SPC provides plot() method visualizing iteration trajectory:","code":"# Plot convergence trajectory plot(spc_result, type = \"c\") # Plot reliability estimates plot(spc_result, type = \"rho\") # Both plots combined (requires patchwork) plot(spc_result, type = \"both\")"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/spc_algorithm.html","id":"iteration-control","dir":"Articles","previous_headings":"Key Parameters","what":"Iteration Control","title":"Algorithm 2: Stochastic Approximation Calibration (SPC)","text":"Recommendations: n_iter = 200-300 usually sufficient warm start n_iter = 500+ cold start difficult problems burn_in least 50% n_iter","code":"spc_result <- spc_calibrate(   target_rho = 0.80,   n_items = 25,   n_iter = 300,       # Total iterations (default: 300)   burn_in = 150,      # Discard first 150 for averaging (default: n_iter/2)   seed = 42 )"},{"path":"https://joonho112.github.io/IRTsimrel/articles/spc_algorithm.html","id":"monte-carlo-sample-sizes","dir":"Articles","previous_headings":"Key Parameters","what":"Monte Carlo Sample Sizes","title":"Algorithm 2: Stochastic Approximation Calibration (SPC)","text":"Critical: M_pre controls stability latent variance estimate œÉŒ∏2\\sigma^2_\\theta, fixed throughout iterations. Use M_pre >= 10000 numerical stability.","code":"spc_result <- spc_calibrate(   target_rho = 0.80,   n_items = 25,   M_per_iter = 500,   # Samples per iteration (default: 500)   M_pre = 10000,      # Samples for variance pre-calculation (default: 10000)   seed = 42 )"},{"path":"https://joonho112.github.io/IRTsimrel/articles/spc_algorithm.html","id":"step-size-parameters","dir":"Articles","previous_headings":"Key Parameters","what":"Step Size Parameters","title":"Algorithm 2: Stochastic Approximation Calibration (SPC)","text":"Guidance:","code":"spc_result <- spc_calibrate(   target_rho = 0.80,   n_items = 25,   step_params = list(     a = 1.0,      # Base step size (default: 1.0)     A = 50,       # Stabilization constant (default: 50)     gamma = 0.67  # Decay exponent (default: 0.67 = 2/3)   ),   seed = 42 )"},{"path":"https://joonho112.github.io/IRTsimrel/articles/spc_algorithm.html","id":"item-resampling","dir":"Articles","previous_headings":"Key Parameters","what":"Item Resampling","title":"Algorithm 2: Stochastic Approximation Calibration (SPC)","text":"resample_items = TRUE: robust, accounts item parameter uncertainty resample_items = FALSE: Lower variance, faster convergence","code":"# Resample item parameters each iteration (default) spc_resample <- spc_calibrate(   target_rho = 0.80,   n_items = 25,   resample_items = TRUE,   seed = 42 )  # Fix item parameters across iterations spc_fixed <- spc_calibrate(   target_rho = 0.80,   n_items = 25,   resample_items = FALSE,   seed = 42 )"},{"path":"https://joonho112.github.io/IRTsimrel/articles/spc_algorithm.html","id":"initialization-methods","dir":"Articles","previous_headings":"","what":"Initialization Methods","title":"Algorithm 2: Stochastic Approximation Calibration (SPC)","text":"SPC supports three initialization strategies:","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/spc_algorithm.html","id":"eqc-warm-start-recommended","dir":"Articles","previous_headings":"Initialization Methods","what":"1. EQC Warm Start (Recommended)","title":"Algorithm 2: Stochastic Approximation Calibration (SPC)","text":"","code":"eqc_result <- eqc_calibrate(target_rho = 0.80, n_items = 25, seed = 42)  spc_result <- spc_calibrate(   target_rho = 0.80,   n_items = 25,   c_init = eqc_result,  # Pass eqc_result object   seed = 42 ) # init_method = \"eqc_warm_start\""},{"path":"https://joonho112.github.io/IRTsimrel/articles/spc_algorithm.html","id":"analytic-pre-calibration-apc","dir":"Articles","previous_headings":"Initialization Methods","what":"2. Analytic Pre-Calibration (APC)","title":"Algorithm 2: Stochastic Approximation Calibration (SPC)","text":"c_init = NULL, SPC uses closed-form approximation: APC formula (Gaussian Rasch assumptions): cinit=œÅ*‚ãÖŒ∫‚ãÖ(1‚àíœÅ*)c_{\\text{init}} = \\sqrt{\\frac{\\rho^*}{\\cdot \\kappa \\cdot (1 - \\rho^*)}} Œ∫‚âà0.25/1+œÉ2œÄ2/3\\kappa \\approx 0.25 / \\sqrt{1 + \\sigma^2 \\pi^2/3} logistic-normal convolution.","code":"spc_result <- spc_calibrate(   target_rho = 0.80,   n_items = 25,   c_init = NULL,  # Uses APC warm start   seed = 42 ) # init_method = \"apc_warm_start\""},{"path":"https://joonho112.github.io/IRTsimrel/articles/spc_algorithm.html","id":"user-specified-value","dir":"Articles","previous_headings":"Initialization Methods","what":"3. User-Specified Value","title":"Algorithm 2: Stochastic Approximation Calibration (SPC)","text":"","code":"spc_result <- spc_calibrate(   target_rho = 0.80,   n_items = 25,   c_init = 1.0,  # User-specified starting value   seed = 42 ) # init_method = \"user_specified\""},{"path":"https://joonho112.github.io/IRTsimrel/articles/spc_algorithm.html","id":"convergence-diagnostics","dir":"Articles","previous_headings":"","what":"Convergence Diagnostics","title":"Algorithm 2: Stochastic Approximation Calibration (SPC)","text":"SPC provides automatic convergence assessment:","code":"# Access convergence information conv <- spc_result$convergence  cat(\"Convergence Diagnostics:\\n\") #> Convergence Diagnostics: cat(sprintf(\"  Converged: %s\\n\", conv$converged)) #>   Converged: TRUE cat(sprintf(\"  Mean (first half):  %.4f\\n\", conv$mean_first_half)) #>   Mean (first half):  0.9842 cat(sprintf(\"  Mean (second half): %.4f\\n\", conv$mean_second_half)) #>   Mean (second half): 0.9900 cat(sprintf(\"  SD (post-burn-in):  %.4f\\n\", conv$sd_post_burn)) #>   SD (post-burn-in):  0.0037 cat(sprintf(\"  Final gradient:     %+.4f\\n\", conv$final_gradient)) #>   Final gradient:     +0.0167 cat(sprintf(\"  Hit lower bound:    %s\\n\", conv$hit_lower_bound)) #>   Hit lower bound:    FALSE cat(sprintf(\"  Hit upper bound:    %s\\n\", conv$hit_upper_bound)) #>   Hit upper bound:    FALSE"},{"path":"https://joonho112.github.io/IRTsimrel/articles/spc_algorithm.html","id":"convergence-criteria","dir":"Articles","previous_headings":"Convergence Diagnostics","what":"Convergence Criteria","title":"Algorithm 2: Stochastic Approximation Calibration (SPC)","text":"algorithm considered converged : |c‚Äæfirst half‚àíc‚Äæsecond half|<0.05|\\bar{c}_{\\text{first half}} - \\bar{c}_{\\text{second half}}| < 0.05","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/spc_algorithm.html","id":"handling-non-convergence","dir":"Articles","previous_headings":"Convergence Diagnostics","what":"Handling Non-Convergence","title":"Algorithm 2: Stochastic Approximation Calibration (SPC)","text":"SPC doesn‚Äôt converge:","code":"# Increase iterations spc_result <- spc_calibrate(   target_rho = 0.80,   n_items = 25,   n_iter = 500,     # More iterations   burn_in = 250,   seed = 42 )  # Adjust step sizes spc_result <- spc_calibrate(   target_rho = 0.80,   n_items = 25,   step_params = list(a = 0.5, A = 100, gamma = 0.67),  # Smaller, more stable steps   seed = 42 )  # Use EQC warm start eqc_result <- eqc_calibrate(target_rho = 0.80, n_items = 25, seed = 42) spc_result <- spc_calibrate(   target_rho = 0.80,   n_items = 25,   c_init = eqc_result,  # Start near solution   n_iter = 150,         # Fewer iterations needed   seed = 42 )"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/spc_algorithm.html","id":"why-do-they-differ","dir":"Articles","previous_headings":"Understanding EQC vs SPC Differences","what":"Why Do They Differ?","title":"Algorithm 2: Stochastic Approximation Calibration (SPC)","text":"comparing EQC SPC results, may notice systematic differences. expected reflects theoretical distinctions: EQC targets average-information reliability: œÅÃÉ(c)=œÉŒ∏2ùí•‚Äæ(c)œÉŒ∏2ùí•‚Äæ(c)+1\\tilde{\\rho}(c) = \\frac{\\sigma^2_\\theta \\bar{\\mathcal{J}}(c)}{\\sigma^2_\\theta \\bar{\\mathcal{J}}(c) + 1} SPC targets MSEM-based reliability (default): œÅ‚Äæ(c)=œÉŒ∏2œÉŒ∏2+ùîº[1/ùí•(Œ∏;c)]\\bar{\\rho}(c) = \\frac{\\sigma^2_\\theta}{\\sigma^2_\\theta + \\mathbb{E}[1/\\mathcal{J}(\\theta; c)]} Jensen‚Äôs inequality guarantees: œÅÃÉ(c)‚â•œÅ‚Äæ(c)c\\tilde{\\rho}(c) \\geq \\bar{\\rho}(c) \\quad \\text{} c Therefore, achieve target œÅ*\\rho^*: cSPC*>cEQC*c^*_{\\text{SPC}} > c^*_{\\text{EQC}}","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/spc_algorithm.html","id":"empirical-example","dir":"Articles","previous_headings":"Understanding EQC vs SPC Differences","what":"Empirical Example","title":"Algorithm 2: Stochastic Approximation Calibration (SPC)","text":"","code":"# Both targeting rho* = 0.80 eqc_result <- eqc_calibrate(   target_rho = 0.80, n_items = 25,   reliability_metric = \"msem\",  # Same metric   seed = 42 )  spc_result <- spc_calibrate(   target_rho = 0.80, n_items = 25,   reliability_metric = \"msem\",  # Same metric   c_init = eqc_result,   seed = 42 )  # SPC's c* will be slightly higher cat(sprintf(\"EQC c*: %.4f\\n\", eqc_result$c_star)) cat(sprintf(\"SPC c*: %.4f\\n\", spc_result$c_star))"},{"path":"https://joonho112.github.io/IRTsimrel/articles/spc_algorithm.html","id":"making-them-comparable","dir":"Articles","previous_headings":"Understanding EQC vs SPC Differences","what":"Making Them Comparable","title":"Algorithm 2: Stochastic Approximation Calibration (SPC)","text":"maximize agreement, use reliability metric:","code":"# Both use \"info\" metric eqc_info <- eqc_calibrate(   target_rho = 0.80, n_items = 25,   reliability_metric = \"info\",   seed = 42 )  spc_info <- spc_calibrate(   target_rho = 0.80, n_items = 25,   reliability_metric = \"info\",   c_init = eqc_info,   seed = 42 )  compare_eqc_spc(eqc_info, spc_info)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/spc_algorithm.html","id":"verbose-mode","dir":"Articles","previous_headings":"","what":"Verbose Mode","title":"Algorithm 2: Stochastic Approximation Calibration (SPC)","text":"Enable detailed output monitor progress:","code":"# Level 1: Progress updates spc_result <- spc_calibrate(   target_rho = 0.80,   n_items = 25,   verbose = TRUE,   # or verbose = 1   seed = 42 )  # Level 2: Iteration-by-iteration details spc_result <- spc_calibrate(   target_rho = 0.80,   n_items = 25,   verbose = 2,   seed = 42 )"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/spc_algorithm.html","id":"rasch-model","dir":"Articles","previous_headings":"Working with Different Models","what":"Rasch Model","title":"Algorithm 2: Stochastic Approximation Calibration (SPC)","text":"","code":"spc_rasch <- spc_calibrate(   target_rho = 0.75,   n_items = 30,   model = \"rasch\",   seed = 42 )"},{"path":"https://joonho112.github.io/IRTsimrel/articles/spc_algorithm.html","id":"pl-model","dir":"Articles","previous_headings":"Working with Different Models","what":"2PL Model","title":"Algorithm 2: Stochastic Approximation Calibration (SPC)","text":"","code":"spc_2pl <- spc_calibrate(   target_rho = 0.80,   n_items = 25,   model = \"2pl\",   item_source = \"irw\",   item_params = list(     discrimination_params = list(       mu_log = 0,       sigma_log = 0.3,       rho = -0.3     )   ),   seed = 42 )"},{"path":"https://joonho112.github.io/IRTsimrel/articles/spc_algorithm.html","id":"alias-sac_calibrate","dir":"Articles","previous_headings":"","what":"Alias: sac_calibrate()","title":"Algorithm 2: Stochastic Approximation Calibration (SPC)","text":"nomenclature consistency manuscript, sac_calibrate() provided alias:","code":"# These are identical spc_result <- spc_calibrate(target_rho = 0.80, n_items = 25, seed = 42) sac_result <- sac_calibrate(target_rho = 0.80, n_items = 25, seed = 42)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/spc_algorithm.html","id":"complete-validation-workflow","dir":"Articles","previous_headings":"","what":"Complete Validation Workflow","title":"Algorithm 2: Stochastic Approximation Calibration (SPC)","text":"","code":"# ==== 1. Run EQC (primary calibration) ==== eqc_result <- eqc_calibrate(   target_rho = 0.80,   n_items = 25,   model = \"rasch\",   latent_shape = \"normal\",   item_source = \"irw\",   M = 20000,   seed = 42,   verbose = TRUE )  # ==== 2. Validate with SPC ==== spc_result <- spc_calibrate(   target_rho = 0.80,   n_items = 25,   model = \"rasch\",   latent_shape = \"normal\",   item_source = \"irw\",   c_init = eqc_result,   n_iter = 200,   seed = 42,   verbose = TRUE )  # ==== 3. Compare results ==== comparison <- compare_eqc_spc(eqc_result, spc_result)  # ==== 4. Check convergence ==== if (!spc_result$convergence$converged) {   warning(\"SPC did not converge. Consider increasing n_iter.\") }  # ==== 5. Visualize ==== plot(spc_result, type = \"both\")  # ==== 6. Final validation with TAM ==== sim_data <- simulate_response_data(   eqc_result = eqc_result,   n_persons = 1000,   seed = 123 )  tam_rel <- compute_reliability_tam(sim_data$response_matrix, model = \"rasch\")  cat(\"\\nFinal Validation Summary:\\n\") cat(sprintf(\"  Target reliability:  %.3f\\n\", eqc_result$target_rho)) cat(sprintf(\"  EQC c*:              %.4f\\n\", eqc_result$c_star)) cat(sprintf(\"  SPC c*:              %.4f\\n\", spc_result$c_star)) cat(sprintf(\"  Agreement:           %.2f%%\\n\", comparison$diff_pct)) cat(sprintf(\"  TAM WLE reliability: %.3f\\n\", tam_rel$rel_wle)) cat(sprintf(\"  TAM EAP reliability: %.3f\\n\", tam_rel$rel_eap))"},{"path":[]},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/spc_algorithm.html","id":"convergence-guarantee","dir":"Articles","previous_headings":"Theoretical Properties","what":"Convergence Guarantee","title":"Algorithm 2: Stochastic Approximation Calibration (SPC)","text":"standard Robbins-Monro conditions, SPC iterate converges almost surely: cn‚Üí.s.c*n‚Üí‚àûc_n \\xrightarrow{\\text{.s.}} c^* \\quad \\text{} n \\\\infty","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/spc_algorithm.html","id":"asymptotic-normality","dir":"Articles","previous_headings":"Theoretical Properties","what":"Asymptotic Normality","title":"Algorithm 2: Stochastic Approximation Calibration (SPC)","text":"Polyak-Ruppert averaging: n(cn*‚àíc*)‚ÜídN(0,œÉ2/g‚Ä≤(c*)2)\\sqrt{n}(c^*_n - c^*) \\xrightarrow{d} N(0, \\sigma^2 / g'(c^*)^2) œÉ2\\sigma^2 variance gradient noise g‚Ä≤(c*)g'(c^*) derivative reliability function solution.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/spc_algorithm.html","id":"rate-of-convergence","dir":"Articles","previous_headings":"Theoretical Properties","what":"Rate of Convergence","title":"Algorithm 2: Stochastic Approximation Calibration (SPC)","text":"Final iterate: O(n‚àíŒ≥)O(n^{-\\gamma}) convergence Polyak-Ruppert average: O(n‚àí1/2)O(n^{-1/2}) convergence (optimal rate)","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/spc_algorithm.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Algorithm 2: Stochastic Approximation Calibration (SPC)","text":"SPC flexible, theoretically-grounded algorithm reliability-targeted calibration: Best practice: Use EQC primary calibration, SPC validation Warm start: Always use EQC result available Convergence: Check spc_result$convergence$converged Visualization: Use plot(spc_result) inspect trajectory Differences EQC: Expected due reliability metric definitions routine simulation work, EQC alone typically sufficient. Use SPC need independent validation working complex scenarios EQC‚Äôs assumptions may hold.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/spc_algorithm.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Algorithm 2: Stochastic Approximation Calibration (SPC)","text":"Robbins, H., & Monro, S. (1951). stochastic approximation method. Annals Mathematical Statistics, 22(3), 400‚Äì407. Polyak, B. T., & Juditsky, . B. (1992). Acceleration stochastic approximation averaging. SIAM Journal Control Optimization, 30(4), 838‚Äì855. Kushner, H. J., & Yin, G. G. (2003). Stochastic Approximation Recursive Algorithms Applications (2nd ed.). Springer.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Validating Calibration Results","text":"calibrating item parameters using EQC SPC, essential validate achieved reliability matches target. IRTsimrel provides several validation tools: vignette covers: Generating response data calibrated parameters External validation using TAM package Understanding WLE vs EAP reliability Comparing EQC SPC results Monte Carlo validation workflow Troubleshooting common validation issues","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"generating-response-data","dir":"Articles","previous_headings":"","what":"Generating Response Data","title":"Validating Calibration Results","text":"simulate_response_data() function generates item response matrices using calibrated parameters EQC.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"basic-usage","dir":"Articles","previous_headings":"Generating Response Data","what":"Basic Usage","title":"Validating Calibration Results","text":"","code":"# First, run EQC calibration eqc_result <- eqc_calibrate( target_rho = 0.80,   n_items = 25,   model = \"rasch\",   latent_shape = \"normal\",   item_source = \"irw\",   seed = 42 ) #> Note: Target rho* = 0.800 is near the achievable maximum (0.824) for this configuration.  # Generate response data sim_data <- simulate_response_data(   eqc_result = eqc_result,   n_persons = 1000,   latent_shape = \"normal\",   seed = 123 )  # Examine the output names(sim_data) #> [1] \"response_matrix\" \"theta\"           \"beta\"            \"lambda\""},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"output-structure","dir":"Articles","previous_headings":"Generating Response Data","what":"Output Structure","title":"Validating Calibration Results","text":"function returns list containing:","code":"# Response matrix: N persons √ó I items dim(sim_data$response_matrix) #> [1] 1000   25 head(sim_data$response_matrix[, 1:6]) #>      item1 item2 item3 item4 item5 item6 #> [1,]     0     1     0     1     0     1 #> [2,]     0     0     1     0     0     0 #> [3,]     1     1     1     1     1     1 #> [4,]     1     1     1     1     0     1 #> [5,]     0     1     0     1     0     0 #> [6,]     1     1     1     1     1     0  # True abilities (used for generating responses) head(sim_data$theta) #> [1] -0.56047565 -0.23017749  1.55870831  0.07050839  0.12928774  1.71506499 cat(sprintf(\"Theta mean: %.3f, SD: %.3f\\n\",              mean(sim_data$theta), sd(sim_data$theta))) #> Theta mean: 0.016, SD: 0.992  # Item parameters used cat(sprintf(\"Number of items: %d\\n\", length(sim_data$beta))) #> Number of items: 25 cat(sprintf(\"Beta range: [%.2f, %.2f]\\n\",              min(sim_data$beta), max(sim_data$beta))) #> Beta range: [-1.48, 1.06]"},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"matching-latent-distribution","dir":"Articles","previous_headings":"Generating Response Data","what":"Matching Latent Distribution","title":"Validating Calibration Results","text":"Important: Use latent distribution simulation used calibration: distributions don‚Äôt match, achieved reliability differ target.","code":"# Calibrate for bimodal population eqc_bimodal <- eqc_calibrate(   target_rho = 0.75,   n_items = 20,   latent_shape = \"bimodal\",   latent_params = list(delta = 0.8),   seed = 42 )  # Generate data with SAME distribution sim_data <- simulate_response_data(   eqc_result = eqc_bimodal,   n_persons = 1000,   latent_shape = \"bimodal\",           # Same shape!   latent_params = list(delta = 0.8),  # Same params!   seed = 123 )"},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"external-validation-with-tam","dir":"Articles","previous_headings":"","what":"External Validation with TAM","title":"Validating Calibration Results","text":"compute_reliability_tam() function provides independent validation using TAM package‚Äôs official reliability functions.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"requirements","dir":"Articles","previous_headings":"External Validation with TAM","what":"Requirements","title":"Validating Calibration Results","text":"","code":"# Install TAM if needed install.packages(\"TAM\")"},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"computing-reliability","dir":"Articles","previous_headings":"External Validation with TAM","what":"Computing Reliability","title":"Validating Calibration Results","text":"","code":"# Compute WLE and EAP reliability tam_rel <- compute_reliability_tam(   resp = sim_data$response_matrix,   model = \"rasch\",   verbose = FALSE )  # View results cat(sprintf(\"Target reliability:  %.4f\\n\", eqc_result$target_rho)) cat(sprintf(\"EQC achieved rho:    %.4f\\n\", eqc_result$achieved_rho)) cat(sprintf(\"TAM WLE reliability: %.4f\\n\", tam_rel$rel_wle)) cat(sprintf(\"TAM EAP reliability: %.4f\\n\", tam_rel$rel_eap))"},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"output-components","dir":"Articles","previous_headings":"External Validation with TAM","what":"Output Components","title":"Validating Calibration Results","text":"","code":"names(tam_rel)  # rel_wle: WLE reliability coefficient # rel_eap: EAP reliability coefficient # mod: Fitted TAM model object # wle: Output from TAM::tam.wle()"},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"using-with-2pl-model","dir":"Articles","previous_headings":"External Validation with TAM","what":"Using with 2PL Model","title":"Validating Calibration Results","text":"","code":"# For 2PL data eqc_2pl <- eqc_calibrate(   target_rho = 0.80,   n_items = 30,   model = \"2pl\",   seed = 42 )  sim_2pl <- simulate_response_data(eqc_2pl, n_persons = 1000, seed = 123)  tam_2pl <- compute_reliability_tam(   resp = sim_2pl$response_matrix,   model = \"2pl\"  # Specify 2PL )"},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"understanding-wle-vs-eap-reliability","dir":"Articles","previous_headings":"","what":"Understanding WLE vs EAP Reliability","title":"Validating Calibration Results","text":"critical validation finding: TAM‚Äôs EAP reliability systematically higher WLE reliability. bug‚Äîreflects fundamentally different mathematical definitions.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"the-two-definitions","dir":"Articles","previous_headings":"Understanding WLE vs EAP Reliability","what":"The Two Definitions","title":"Validating Calibration Results","text":"WLE Reliability (design-effect based): œÅWLE=1‚àís‚Äæ2VWLE\\rho_{\\text{WLE}} = 1 - \\frac{\\bar{s}^2}{V_{\\text{WLE}}} s‚Äæ2\\bar{s}^2 average squared standard error VWLEV_{\\text{WLE}} variance WLE estimates. EAP Reliability (posterior variance based): œÅEAP=VEAPVEAP+œÉ‚Äæ2\\rho_{\\text{EAP}} = \\frac{V_{\\text{EAP}}}{V_{\\text{EAP}} + \\bar{\\sigma}^2} VEAPV_{\\text{EAP}} variance EAP estimates œÉ‚Äæ2\\bar{\\sigma}^2 average posterior variance.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"mathematical-relationship","dir":"Articles","previous_headings":"Understanding WLE vs EAP Reliability","what":"Mathematical Relationship","title":"Validating Calibration Results","text":"TAM‚Äôs definitions, œÅEAP‚â•œÅWLE\\rho_{\\text{EAP}} \\geq \\rho_{\\text{WLE}}always holds. inequality strict except trivial cases.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"practical-interpretation","dir":"Articles","previous_headings":"Understanding WLE vs EAP Reliability","what":"Practical Interpretation","title":"Validating Calibration Results","text":"Recommendation: conservative inference, focus WLE reliability. EQC/SPC target typically falls WLE EAP.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"expected-patterns","dir":"Articles","previous_headings":"Understanding WLE vs EAP Reliability","what":"Expected Patterns","title":"Validating Calibration Results","text":"","code":"# Typical validation results # Target: 0.80  # WLE reliability: 0.78 - 0.82  (slight underestimation common) # EAP reliability: 0.82 - 0.86  (slight overestimation common)  # Both within ¬±0.03 of target is excellent # WLE within ¬±0.05 of target is acceptable"},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"comparing-eqc-and-spc-results","dir":"Articles","previous_headings":"","what":"Comparing EQC and SPC Results","title":"Validating Calibration Results","text":"compare_eqc_spc() function provides formal comparison two calibration algorithms.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"basic-comparison","dir":"Articles","previous_headings":"Comparing EQC and SPC Results","what":"Basic Comparison","title":"Validating Calibration Results","text":"","code":"# Run EQC eqc_result <- eqc_calibrate(   target_rho = 0.80,   n_items = 25,   model = \"rasch\",   seed = 42 )  # Run SPC with EQC warm start spc_result <- spc_calibrate(   target_rho = 0.80,   n_items = 25,   model = \"rasch\",   c_init = eqc_result,   n_iter = 200,   seed = 42 )  # Compare comparison <- compare_eqc_spc(eqc_result, spc_result)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"interpreting-the-comparison","dir":"Articles","previous_headings":"Comparing EQC and SPC Results","what":"Interpreting the Comparison","title":"Validating Calibration Results","text":"","code":"# Output includes: comparison$c_eqc      # EQC's c* comparison$c_spc      # SPC's c* comparison$diff_abs   # Absolute difference comparison$diff_pct   # Percent difference comparison$agreement  # TRUE if difference < 5%"},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"expected-differences","dir":"Articles","previous_headings":"Comparing EQC and SPC Results","what":"Expected Differences","title":"Validating Calibration Results","text":"EQC SPC may produce slightly different results due : Different reliability formulas: EQC uses fixed quadrature; SPC uses fresh samples Stochastic noise: SPC Monte Carlo variance Reliability metric: using different metrics, expect systematic differences Agreement criterion: Differences < 5% indicate good agreement.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"when-they-disagree","dir":"Articles","previous_headings":"Comparing EQC and SPC Results","what":"When They Disagree","title":"Validating Calibration Results","text":"EQC SPC differ 5%:","code":"# 1. Check if using same reliability metric cat(sprintf(\"EQC metric: %s\\n\", eqc_result$metric)) cat(sprintf(\"SPC metric: %s\\n\", spc_result$metric))  # 2. Increase SPC iterations for more stable estimate spc_longer <- spc_calibrate(   target_rho = 0.80,   n_items = 25,   c_init = eqc_result,   n_iter = 500,  # More iterations   burn_in = 250,   seed = 42 )  # 3. Check SPC convergence cat(sprintf(\"Converged: %s\\n\", spc_longer$convergence$converged)) cat(sprintf(\"Post-burn-in SD: %.4f\\n\", spc_longer$convergence$sd_post_burn))"},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"monte-carlo-validation-workflow","dir":"Articles","previous_headings":"","what":"Monte Carlo Validation Workflow","title":"Validating Calibration Results","text":"rigorous validation, use multiple replications account sampling variability.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"complete-validation-example","dir":"Articles","previous_headings":"Monte Carlo Validation Workflow","what":"Complete Validation Example","title":"Validating Calibration Results","text":"","code":"# ==== Configuration ==== target_rho <- 0.80 n_items <- 25 n_persons <- 1000 n_replications <- 50  # ==== Step 1: Calibrate ==== eqc_result <- eqc_calibrate(   target_rho = target_rho,   n_items = n_items,   model = \"rasch\",   latent_shape = \"normal\",   item_source = \"irw\",   M = 20000,  # Large quadrature for precision   seed = 42 )  cat(sprintf(\"Calibrated c* = %.4f\\n\", eqc_result$c_star)) cat(sprintf(\"EQC achieved rho = %.4f\\n\\n\", eqc_result$achieved_rho))  # ==== Step 2: Monte Carlo Validation ==== wle_rels <- numeric(n_replications) eap_rels <- numeric(n_replications)  cat(\"Running Monte Carlo validation...\\n\")  for (r in 1:n_replications) {   # Generate data   sim_data <- simulate_response_data(     eqc_result = eqc_result,     n_persons = n_persons,     latent_shape = \"normal\",     seed = r   )      # Compute TAM reliability   tam_rel <- compute_reliability_tam(     resp = sim_data$response_matrix,     model = \"rasch\",     verbose = FALSE   )      wle_rels[r] <- tam_rel$rel_wle   eap_rels[r] <- tam_rel$rel_eap      if (r %% 10 == 0) cat(sprintf(\"  Completed %d/%d\\n\", r, n_replications)) }  # ==== Step 3: Summarize Results ==== cat(\"\\n\") cat(\"=======================================================\\n\") cat(\"  Monte Carlo Validation Results\\n\") cat(\"=======================================================\\n\\n\")  cat(sprintf(\"Target reliability: %.3f\\n\\n\", target_rho))  cat(\"WLE Reliability:\\n\") cat(sprintf(\"  Mean:   %.4f\\n\", mean(wle_rels))) cat(sprintf(\"  SD:     %.4f\\n\", sd(wle_rels))) cat(sprintf(\"  Range:  [%.4f, %.4f]\\n\", min(wle_rels), max(wle_rels))) cat(sprintf(\"  MAE:    %.4f\\n\\n\", mean(abs(wle_rels - target_rho))))  cat(\"EAP Reliability:\\n\") cat(sprintf(\"  Mean:   %.4f\\n\", mean(eap_rels))) cat(sprintf(\"  SD:     %.4f\\n\", sd(eap_rels))) cat(sprintf(\"  Range:  [%.4f, %.4f]\\n\", min(eap_rels), max(eap_rels))) cat(sprintf(\"  MAE:    %.4f\\n\", mean(abs(eap_rels - target_rho))))"},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"interpreting-monte-carlo-results","dir":"Articles","previous_headings":"Monte Carlo Validation Workflow","what":"Interpreting Monte Carlo Results","title":"Validating Calibration Results","text":"Success criteria:","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"visualizing-results","dir":"Articles","previous_headings":"Monte Carlo Validation Workflow","what":"Visualizing Results","title":"Validating Calibration Results","text":"","code":"# Create validation plot par(mfrow = c(1, 2))  # WLE distribution hist(wle_rels, breaks = 15, col = \"lightblue\",      main = \"WLE Reliability Distribution\",      xlab = \"Reliability\", xlim = c(target_rho - 0.1, target_rho + 0.1)) abline(v = target_rho, col = \"red\", lwd = 2, lty = 2) abline(v = mean(wle_rels), col = \"blue\", lwd = 2) legend(\"topright\", c(\"Target\", \"Mean\"),         col = c(\"red\", \"blue\"), lty = c(2, 1), lwd = 2)  # EAP distribution hist(eap_rels, breaks = 15, col = \"lightgreen\",      main = \"EAP Reliability Distribution\",      xlab = \"Reliability\", xlim = c(target_rho - 0.1, target_rho + 0.1)) abline(v = target_rho, col = \"red\", lwd = 2, lty = 2) abline(v = mean(eap_rels), col = \"darkgreen\", lwd = 2) legend(\"topright\", c(\"Target\", \"Mean\"),         col = c(\"red\", \"darkgreen\"), lty = c(2, 1), lwd = 2)  par(mfrow = c(1, 1))"},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"validation-across-multiple-targets","dir":"Articles","previous_headings":"","what":"Validation Across Multiple Targets","title":"Validating Calibration Results","text":"Test calibration accuracy across range target reliabilities:","code":"# Test multiple target levels targets <- c(0.60, 0.70, 0.80, 0.85) results <- data.frame(   target = targets,   c_star = NA,   achieved_rho = NA,   mean_wle = NA,   mean_eap = NA,   mae_wle = NA,   mae_eap = NA )  for (i in seq_along(targets)) {   # Calibrate   eqc <- eqc_calibrate(     target_rho = targets[i],     n_items = 25,     model = \"rasch\",     seed = 42   )      results$c_star[i] <- eqc$c_star   results$achieved_rho[i] <- eqc$achieved_rho      # Validate with 20 replications   wle <- eap <- numeric(20)   for (r in 1:20) {     sim <- simulate_response_data(eqc, n_persons = 1000, seed = r)     tam <- compute_reliability_tam(sim$response_matrix, \"rasch\", verbose = FALSE)     wle[r] <- tam$rel_wle     eap[r] <- tam$rel_eap   }      results$mean_wle[i] <- mean(wle)   results$mean_eap[i] <- mean(eap)   results$mae_wle[i] <- mean(abs(wle - targets[i]))   results$mae_eap[i] <- mean(abs(eap - targets[i]))      cat(sprintf(\"Target %.2f: c* = %.3f, MAE(WLE) = %.4f\\n\",                targets[i], eqc$c_star, results$mae_wle[i])) }  # Summary table print(results)"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"issue-1-large-discrepancy-between-target-and-achieved","dir":"Articles","previous_headings":"Troubleshooting Validation Issues","what":"Issue 1: Large Discrepancy Between Target and Achieved","title":"Validating Calibration Results","text":"Symptoms: MAE > 0.05, systematic bias Possible causes solutions:","code":"# 1. Latent distribution mismatch # Solution: Ensure same distribution for calibration and simulation eqc <- eqc_calibrate(..., latent_shape = \"bimodal\", latent_params = list(delta = 0.8)) sim <- simulate_response_data(eqc, ...,                                 latent_shape = \"bimodal\",  # MUST match                                latent_params = list(delta = 0.8))  # 2. Small sample size # Solution: Increase n_persons sim <- simulate_response_data(eqc, n_persons = 2000, ...)  # Larger N  # 3. Insufficient quadrature # Solution: Increase M in EQC eqc <- eqc_calibrate(..., M = 50000)  # Larger quadrature"},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"issue-2-wle-reliability-much-lower-than-target","dir":"Articles","previous_headings":"Troubleshooting Validation Issues","what":"Issue 2: WLE Reliability Much Lower Than Target","title":"Validating Calibration Results","text":"Symptoms: WLE consistently 0.03-0.05 target Explanation: often expected behavior due conservative nature WLE reliability.","code":"# Check if EAP is closer to target cat(sprintf(\"Target: %.3f\\n\", target_rho)) cat(sprintf(\"WLE:    %.3f (diff: %+.3f)\\n\", tam_rel$rel_wle, tam_rel$rel_wle - target_rho)) cat(sprintf(\"EAP:    %.3f (diff: %+.3f)\\n\", tam_rel$rel_eap, tam_rel$rel_eap - target_rho))  # If EAP is close but WLE is low, this is normal # The true reliability is between WLE and EAP"},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"issue-3-high-variability-across-replications","dir":"Articles","previous_headings":"Troubleshooting Validation Issues","what":"Issue 3: High Variability Across Replications","title":"Validating Calibration Results","text":"Symptoms: SD reliability estimates > 0.03 Solutions:","code":"# 1. Increase sample size per replication sim <- simulate_response_data(eqc, n_persons = 2000, ...)  # 2. Use more items eqc <- eqc_calibrate(..., n_items = 40)  # 3. For heavy-tailed latent distributions, use even larger N"},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"issue-4-eqc-and-spc-disagree-by-10","dir":"Articles","previous_headings":"Troubleshooting Validation Issues","what":"Issue 4: EQC and SPC Disagree by > 10%","title":"Validating Calibration Results","text":"Symptoms: compare_eqc_spc() shows large percentage difference Solutions:","code":"# 1. Ensure both use same reliability metric eqc <- eqc_calibrate(..., reliability_metric = \"msem\") spc <- spc_calibrate(..., reliability_metric = \"msem\")  # 2. Increase SPC iterations spc <- spc_calibrate(..., n_iter = 500, burn_in = 250)  # 3. Check SPC convergence if (!spc$convergence$converged) {   warning(\"SPC did not converge - increase n_iter\") }  # 4. Some difference is theoretically expected # See SPC vignette for Jensen's inequality explanation"},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"issue-5-target-reliability-not-achievable","dir":"Articles","previous_headings":"Troubleshooting Validation Issues","what":"Issue 5: Target Reliability Not Achievable","title":"Validating Calibration Results","text":"Symptoms: EQC hits upper bound, warning message Solutions:","code":"# 1. Use \"info\" metric (yields higher reliability for same c) eqc <- eqc_calibrate(..., reliability_metric = \"info\")  # 2. Extend search bounds eqc <- eqc_calibrate(..., c_bounds = c(0.1, 5))  # 3. Increase number of items eqc <- eqc_calibrate(..., n_items = 40)  # 4. Accept maximum achievable reliability # Check: eqc_result$misc$rho_bounds[\"rho_U\"]"},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"complete-validation-template","dir":"Articles","previous_headings":"","what":"Complete Validation Template","title":"Validating Calibration Results","text":"Use template simulation studies:","code":"# ============================================================== # IRTsimrel Validation Template # ==============================================================  library(IRTsimrel) library(TAM)  # ---- Configuration ---- TARGET_RHO <- 0.80 N_ITEMS <- 25 N_PERSONS <- 1000 N_REPS <- 50 MODEL <- \"rasch\" LATENT_SHAPE <- \"normal\" SEED_CALIB <- 42  # ---- Step 1: Calibration ---- cat(\"Step 1: Running EQC calibration...\\n\")  eqc_result <- eqc_calibrate(   target_rho = TARGET_RHO,   n_items = N_ITEMS,   model = MODEL,   latent_shape = LATENT_SHAPE,   item_source = \"irw\",   M = 20000,   seed = SEED_CALIB,   verbose = TRUE )  # ---- Step 2: SPC Validation (Optional) ---- cat(\"\\nStep 2: Running SPC validation...\\n\")  spc_result <- spc_calibrate(   target_rho = TARGET_RHO,   n_items = N_ITEMS,   model = MODEL,   latent_shape = LATENT_SHAPE,   item_source = \"irw\",   c_init = eqc_result,   n_iter = 200,   seed = SEED_CALIB,   verbose = TRUE )  compare_eqc_spc(eqc_result, spc_result)  # ---- Step 3: Monte Carlo TAM Validation ---- cat(\"\\nStep 3: Running Monte Carlo validation...\\n\")  wle_rels <- eap_rels <- numeric(N_REPS)  for (r in 1:N_REPS) {   sim_data <- simulate_response_data(     eqc_result = eqc_result,     n_persons = N_PERSONS,     latent_shape = LATENT_SHAPE,     seed = r   )      tam_rel <- compute_reliability_tam(     resp = sim_data$response_matrix,     model = MODEL,     verbose = FALSE   )      wle_rels[r] <- tam_rel$rel_wle   eap_rels[r] <- tam_rel$rel_eap      if (r %% 10 == 0) cat(sprintf(\"  %d/%d complete\\n\", r, N_REPS)) }  # ---- Step 4: Summary ---- cat(\"\\n\") cat(\"=======================================================\\n\") cat(\"  VALIDATION SUMMARY\\n\") cat(\"=======================================================\\n\\n\")  cat(sprintf(\"Configuration:\\n\")) cat(sprintf(\"  Target reliability: %.3f\\n\", TARGET_RHO)) cat(sprintf(\"  Items: %d, Persons: %d, Replications: %d\\n\\n\", N_ITEMS, N_PERSONS, N_REPS))  cat(sprintf(\"Calibration:\\n\")) cat(sprintf(\"  EQC c*: %.4f (achieved rho = %.4f)\\n\", eqc_result$c_star, eqc_result$achieved_rho)) cat(sprintf(\"  SPC c*: %.4f (agreement: %s)\\n\\n\",              spc_result$c_star,              ifelse(abs(eqc_result$c_star - spc_result$c_star)/eqc_result$c_star < 0.05, \"YES\", \"NO\")))  cat(sprintf(\"TAM Validation:\\n\")) cat(sprintf(\"  WLE: Mean = %.4f, SD = %.4f, MAE = %.4f\\n\",              mean(wle_rels), sd(wle_rels), mean(abs(wle_rels - TARGET_RHO)))) cat(sprintf(\"  EAP: Mean = %.4f, SD = %.4f, MAE = %.4f\\n\",              mean(eap_rels), sd(eap_rels), mean(abs(eap_rels - TARGET_RHO))))  cat(sprintf(\"\\nValidation Status: \")) if (mean(abs(wle_rels - TARGET_RHO)) < 0.03) {   cat(\"PASSED\\n\") } else {   cat(\"INVESTIGATE\\n\") }"},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Validating Calibration Results","text":"Effective validation reliability-targeted simulation requires: Generate representative data using simulate_response_data() matching latent distributions External validation via TAM‚Äôs WLErel() EAPrel() functions Understand reliability metrics: WLE conservative, EAP liberal, target falls Cross-validate algorithms using compare_eqc_spc() possible Use Monte Carlo replications account sampling variability Set realistic expectations: MAE < 0.03 excellent, < 0.05 acceptable Following practices ensures simulation studies achieve intended reliability levels confidence.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Validating Calibration Results","text":"Warm, T. . (1989). Weighted likelihood estimation ability item response theory. Psychometrika, 54(3), 427-450. Robitzsch, ., Kiefer, T., & Wu, M. (2022). TAM: Test Analysis Modules. R package version 4.1-4.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"JoonHo Lee. Author, maintainer.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Lee J (2025). IRTsimrel: Reliability-Targeted Simulation Item Response Data. R package version 0.1.0, https://github.com/joonho112/IRTsimrel.","code":"@Manual{,   title = {IRTsimrel: Reliability-Targeted Simulation for Item Response Data},   author = {JoonHo Lee},   year = {2025},   note = {R package version 0.1.0},   url = {https://github.com/joonho112/IRTsimrel}, }"},{"path":"https://joonho112.github.io/IRTsimrel/index.html","id":"irtsimrel-","dir":"","previous_headings":"","what":"IRTsimrel","title":"IRTsimrel","text":"IRTsimrel provides principled framework reliability-targeted simulation Item Response Theory (IRT) data. Instead treating reliability implicit outcome simulation design choices, IRTsimrel allows researchers specify target reliability level explicit input parameter.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/index.html","id":"the-problem","dir":"","previous_headings":"","what":"The Problem","title":"IRTsimrel","text":"Monte Carlo simulation studies IRT, researchers routinely vary sample size, test length, item parameters‚Äîmarginal reliability almost never directly controlled. creates: Ecological validity threats: Real assessments often reliabilities 0.5‚Äì0.7, simulations may implicitly assume higher values Confounded comparisons: Conclusions model superiority may hold within certain reliability regimes Limited replicability: Without knowing implied reliability, exact replication impossible","code":""},{"path":"https://joonho112.github.io/IRTsimrel/index.html","id":"the-solution-think-like-multilevel-modelers","dir":"","previous_headings":"","what":"The Solution: Think Like Multilevel Modelers","title":"IRTsimrel","text":"multilevel modeling, intraclass correlation (ICC) always primary design factor. ICC determines signal--noise ratio‚Äîproportion variance cluster level versus residual level. Marginal reliability IRT serves role ICC multilevel models. IRTsimrel brings IRT simulation methodology alignment best practice.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"IRTsimrel","text":"can install development version IRTsimrel GitHub :","code":"# install.packages(\"pak\") pak::pak(\"joonho112/IRTsimrel\")"},{"path":"https://joonho112.github.io/IRTsimrel/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick Start","title":"IRTsimrel","text":"Suppose want simulate Rasch model data : 25 items Target reliability 0.80 Normal latent trait distribution","code":""},{"path":"https://joonho112.github.io/IRTsimrel/index.html","id":"step-1-calibrate","dir":"","previous_headings":"Quick Start","what":"Step 1: Calibrate","title":"IRTsimrel","text":"","code":"library(IRTsimrel)  # Calibrate to achieve target reliability eqc_result <- eqc_calibrate(   target_rho = 0.80,   n_items = 25,   model = \"rasch\",   latent_shape = \"normal\",   item_source = \"parametric\",   M = 10000,   seed = 42 )  eqc_result #>  #> ======================================================= #>   Empirical Quadrature Calibration (EQC) Results #> ======================================================= #>  #> Calibration Summary: #>   Model                        : RASCH #>   Target reliability (rho*)    : 0.8000 #>   Achieved reliability         : 0.8000 #>   Absolute error               : 3.77e-06 #>   Scaling factor (c*)          : 0.9277 #>  #> Design Parameters: #>   Number of items (I)          : 25 #>   Quadrature points (M)        : 10000 #>   Reliability metric           : MSEM-based (bar/w) #>   Latent variance              : 1.0123 #>  #> Convergence: #>   Root status                  : uniroot_success #>   Search bracket               : [0.300, 3.000] #>   Bracket reliabilities        : [0.3538, 0.9020] #>  #> Parameter Summaries: #>   theta:        mean = -0.011, sd = 1.006 #>   beta:         mean = -0.000, sd = 0.909, range = [-1.60, 1.73] #>   lambda_base:  mean = 1.000, sd = 0.000 #>   lambda_scaled: mean = 0.928, sd = 0.000"},{"path":"https://joonho112.github.io/IRTsimrel/index.html","id":"step-2-generate-data","dir":"","previous_headings":"Quick Start","what":"Step 2: Generate Data","title":"IRTsimrel","text":"","code":"# Generate response data with calibrated parameters sim_data <- simulate_response_data(   eqc_result = eqc_result,   n_persons = 1000,   latent_shape = \"normal\",   seed = 123 )  # Response matrix ready for analysis dim(sim_data$response_matrix) #> [1] 1000   25"},{"path":"https://joonho112.github.io/IRTsimrel/index.html","id":"step-3-validate-optional","dir":"","previous_headings":"Quick Start","what":"Step 3: Validate (Optional)","title":"IRTsimrel","text":"","code":"# Validate with TAM package tam_rel <- compute_reliability_tam(   resp = sim_data$response_matrix,   model = \"rasch\" )  cat(sprintf(\"Target:  %.3f\\n\", 0.80)) cat(sprintf(\"WLE:     %.3f\\n\", tam_rel$rel_wle)) cat(sprintf(\"EAP:     %.3f\\n\", tam_rel$rel_eap))"},{"path":[]},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/index.html","id":"flexible-latent-distributions","dir":"","previous_headings":"Key Features","what":"Flexible Latent Distributions","title":"IRTsimrel","text":"12 built-shapes including normal, bimodal, trimodal, skewed, heavy-tailed, uniform, floor/ceiling effects‚Äîpre-standardized mean 0 variance 1.","code":"compare_shapes(   n = 3000,   shapes = c(\"normal\", \"bimodal\", \"skew_pos\", \"heavy_tail\"),   seed = 42 )"},{"path":"https://joonho112.github.io/IRTsimrel/index.html","id":"realistic-item-parameters","dir":"","previous_headings":"Key Features","what":"Realistic Item Parameters","title":"IRTsimrel","text":"Generate item parameters empirically-grounded characteristics:","code":"# IRW-based difficulties with copula-correlated discriminations items <- sim_item_params(   n_items = 30,   model = \"2pl\",   source = \"irw\",   method = \"copula\",   discrimination_params = list(rho = -0.3)  # Empirical correlation )"},{"path":"https://joonho112.github.io/IRTsimrel/index.html","id":"the-core-principle-separation-of-structure-and-scale","dir":"","previous_headings":"","what":"The Core Principle: Separation of Structure and Scale","title":"IRTsimrel","text":"IRTsimrel implements fundamental principle: Structure: Realistic item characteristics flexible latent distributions come empirically-grounded generators Scale: global discrimination scaling factor c*c^* calibrated achieve target reliability Œªi*=c*‚ãÖŒªi,0\\lambda_i^* = c^* \\cdot \\lambda_{,0} allows researchers study effect reliability estimation maintaining realistic data structures.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/index.html","id":"two-reliability-metrics","dir":"","previous_headings":"","what":"Two Reliability Metrics","title":"IRTsimrel","text":"Jensen‚Äôs inequality: œÅÃÉ‚â•œÅ‚Äæ\\tilde{\\rho} \\geq \\bar{\\rho} always holds.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/index.html","id":"vignettes","dir":"","previous_headings":"","what":"Vignettes","title":"IRTsimrel","text":"detailed guidance, see package vignettes: vignette(\"introduction_to_irtsimrel\") ‚Äî Package overview workflow vignette(\"latent_distributions\") ‚Äî Working 12 latent shapes vignette(\"item_parameters\") ‚Äî Generating realistic item parameters vignette(\"eqc_algorithm\") ‚Äî Algorithm 1: EQC details vignette(\"spc_algorithm\") ‚Äî Algorithm 2: SPC details vignette(\"validation\") ‚Äî Validating calibration results","code":""},{"path":"https://joonho112.github.io/IRTsimrel/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"IRTsimrel","text":"use IRTsimrel research, please cite:","code":"Lee, J.-H. (2025). Reliability-targeted simulation for item response data. arXiv preprint. arXiv:XXXX.XXXXX"},{"path":"https://joonho112.github.io/IRTsimrel/index.html","id":"related-work","dir":"","previous_headings":"","what":"Related Work","title":"IRTsimrel","text":"TAM ‚Äî Test Analysis Modules IRT mirt ‚Äî Multidimensional Item Response Theory irw ‚Äî Item Response Warehouse","code":""},{"path":"https://joonho112.github.io/IRTsimrel/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"IRTsimrel","text":"MIT ¬© JoonHo Lee","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/IRTsimrel-package.html","id":null,"dir":"Reference","previous_headings":"","what":"IRTsimrel: Reliability-Targeted Simulation for Item Response Data ‚Äî IRTsimrel-package","title":"IRTsimrel: Reliability-Targeted Simulation for Item Response Data ‚Äî IRTsimrel-package","text":"framework reliability-targeted simulation studies Item Response Theory (IRT). Researchers specify target reliability level, package calibrates item discriminations achieve target.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/IRTsimrel-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"IRTsimrel: Reliability-Targeted Simulation for Item Response Data ‚Äî IRTsimrel-package","text":"Main functions: eqc_calibrate: Empirical Quadrature Calibration (recommended) spc_calibrate: Stochastic Approximation Calibration sim_latentG: Generate latent ability distributions sim_item_params: Generate item parameters simulate_response_data: Generate response data","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/reference/IRTsimrel-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"IRTsimrel: Reliability-Targeted Simulation for Item Response Data ‚Äî IRTsimrel-package","text":"JoonHo Lee","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/as.data.frame.item_params.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract item parameters as data frame ‚Äî as.data.frame.item_params","title":"Extract item parameters as data frame ‚Äî as.data.frame.item_params","text":"Extract item parameters data frame","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/as.data.frame.item_params.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract item parameters as data frame ‚Äî as.data.frame.item_params","text":"","code":"# S3 method for class 'item_params' as.data.frame(x, ...)"},{"path":"https://joonho112.github.io/IRTsimrel/reference/as.numeric.latent_G.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract theta values from latent_G object ‚Äî as.numeric.latent_G","title":"Extract theta values from latent_G object ‚Äî as.numeric.latent_G","text":"Convenience function extract theta vector use functions.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/as.numeric.latent_G.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract theta values from latent_G object ‚Äî as.numeric.latent_G","text":"","code":"# S3 method for class 'latent_G' as.numeric(x)"},{"path":"https://joonho112.github.io/IRTsimrel/reference/as.numeric.latent_G.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract theta values from latent_G object ‚Äî as.numeric.latent_G","text":"x latent_G object.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/as.numeric.latent_G.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract theta values from latent_G object ‚Äî as.numeric.latent_G","text":"Numeric vector latent abilities.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/compare_eqc_spc.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare EQC and SPC Calibration Results ‚Äî compare_eqc_spc","title":"Compare EQC and SPC Calibration Results ‚Äî compare_eqc_spc","text":"Compares calibration results EQC SPC algorithms.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/compare_eqc_spc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare EQC and SPC Calibration Results ‚Äî compare_eqc_spc","text":"","code":"compare_eqc_spc(eqc_result, spc_result, verbose = TRUE)"},{"path":"https://joonho112.github.io/IRTsimrel/reference/compare_eqc_spc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare EQC and SPC Calibration Results ‚Äî compare_eqc_spc","text":"eqc_result object class \"eqc_result\". spc_result object class \"spc_result\". verbose Logical. TRUE, print comparison summary.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/compare_eqc_spc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare EQC and SPC Calibration Results ‚Äî compare_eqc_spc","text":"list comparison statistics (invisibly): c_eqc Calibrated c* EQC. c_spc Calibrated c* SPC. diff_abs Absolute difference c* values. diff_pct Percent difference relative EQC. agreement Logical. TRUE difference < 5%. target_rho Target reliability.","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/reference/compare_eqc_spc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare EQC and SPC Calibration Results ‚Äî compare_eqc_spc","text":"","code":"if (FALSE) { # \\dontrun{ # Run both algorithms eqc_result <- eqc_calibrate(target_rho = 0.80, n_items = 25, seed = 42) spc_result <- spc_calibrate(target_rho = 0.80, n_items = 25,                             c_init = eqc_result, seed = 42)  # Compare results compare_eqc_spc(eqc_result, spc_result) } # }"},{"path":"https://joonho112.github.io/IRTsimrel/reference/compare_shapes.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare Multiple Distribution Shapes ‚Äî compare_shapes","title":"Compare Multiple Distribution Shapes ‚Äî compare_shapes","text":"Generates compares multiple latent ability distributions side--side.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/compare_shapes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare Multiple Distribution Shapes ‚Äî compare_shapes","text":"","code":"compare_shapes(   n = 2000,   shapes = c(\"normal\", \"bimodal\", \"trimodal\", \"skew_pos\", \"skew_neg\", \"heavy_tail\",     \"uniform\"),   sigma = 1,   seed = NULL )"},{"path":"https://joonho112.github.io/IRTsimrel/reference/compare_shapes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare Multiple Distribution Shapes ‚Äî compare_shapes","text":"n Integer. Sample size distribution. shapes Character vector. Shapes compare. sigma Numeric. Common scale parameter. seed Integer. Random seed.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/compare_shapes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare Multiple Distribution Shapes ‚Äî compare_shapes","text":"ggplot2 object faceted density plots.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/compare_shapes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare Multiple Distribution Shapes ‚Äî compare_shapes","text":"","code":"if (FALSE) { # \\dontrun{ compare_shapes(n = 3000) } # }"},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_apc_init.html","id":null,"dir":"Reference","previous_headings":"","what":"Analytic Pre-Calibration (APC) Initialization ‚Äî compute_apc_init","title":"Analytic Pre-Calibration (APC) Initialization ‚Äî compute_apc_init","text":"Computes initial value scaling factor using closed-form approximation Gaussian Rasch assumptions.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_apc_init.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Analytic Pre-Calibration (APC) Initialization ‚Äî compute_apc_init","text":"","code":"compute_apc_init(target_rho, n_items, sigma_beta = 1)"},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_apc_init.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Analytic Pre-Calibration (APC) Initialization ‚Äî compute_apc_init","text":"target_rho Numeric. Target reliability. n_items Integer. Number items. sigma_beta Numeric. SD item difficulties (default: 1.0).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_apc_init.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Analytic Pre-Calibration (APC) Initialization ‚Äî compute_apc_init","text":"Numeric. Initial scaling factor c_init.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_apc_init.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Analytic Pre-Calibration (APC) Initialization ‚Äî compute_apc_init","text":"Gaussian Rasch setting \\(\\theta \\sim N(0,1)\\) \\(\\beta \\sim N(0, \\sigma_\\beta^2)\\), expected item information involves logistic-normal convolution: $$\\kappa(\\sigma^2) = \\int \\frac{e^z}{(1+e^z)^2} \\phi(z; 0, \\sigma^2) dz$$ Approximating \\(\\kappa \\approx 0.25 / \\sqrt{1 + \\sigma^2 \\pi^2/3}\\), closed-form pre-calibration : $$c_{init} = \\sqrt{\\frac{\\rho^*}{\\cdot \\kappa \\cdot (1 - \\rho^*)}}$$","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_apc_init.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Analytic Pre-Calibration (APC) Initialization ‚Äî compute_apc_init","text":"","code":"# Compute initial c for target reliability of 0.80 with 25 items compute_apc_init(target_rho = 0.80, n_items = 25) #> [1] 1.327405  # With different difficulty spread compute_apc_init(target_rho = 0.75, n_items = 20, sigma_beta = 1.5) #> [1] 1.432348"},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_reliability_tam.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute WLE and EAP Reliability Using TAM ‚Äî compute_reliability_tam","title":"Compute WLE and EAP Reliability Using TAM ‚Äî compute_reliability_tam","text":"Fits Rasch 2PL model using TAM computes WLE EAP reliability using official WLErel() EAPrel() functions.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_reliability_tam.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute WLE and EAP Reliability Using TAM ‚Äî compute_reliability_tam","text":"","code":"compute_reliability_tam(resp, model = c(\"rasch\", \"2pl\"), verbose = FALSE, ...)"},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_reliability_tam.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute WLE and EAP Reliability Using TAM ‚Äî compute_reliability_tam","text":"resp Matrix data.frame item responses (0/1). model Character. \"rasch\" \"2pl\". verbose Logical. TRUE, print fitting messages. ... Additional arguments passed TAM fitting functions.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_reliability_tam.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute WLE and EAP Reliability Using TAM ‚Äî compute_reliability_tam","text":"list components: rel_wle WLE reliability. rel_eap EAP reliability. mod Fitted TAM model object. wle Output TAM::tam.wle().","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_reliability_tam.html","id":"wle-vs-eap-reliability","dir":"Reference","previous_headings":"","what":"WLE vs EAP Reliability","title":"Compute WLE and EAP Reliability Using TAM ‚Äî compute_reliability_tam","text":"TAM defines reliability coefficients differently: WLE reliability: \\(1 - \\bar{s}^2 / V_{WLE}\\), based design effect EAP reliability: \\(V_{EAP} / (V_{EAP} + \\bar{\\sigma}^2)\\), based posterior variance Mathematically, \\(\\rho_{EAP} \\geq \\rho_{WLE}\\) always holds TAM's definitions. EAP reliability closely corresponds MSEM-based population reliability. conservative inference, treat WLE lower bound.","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_reliability_tam.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute WLE and EAP Reliability Using TAM ‚Äî compute_reliability_tam","text":"","code":"if (FALSE) { # \\dontrun{ # Simulate response data from EQC results sim_data <- simulate_response_data(eqc_result, n_persons = 500)  # Compute TAM reliability tam_rel <- compute_reliability_tam(sim_data$response_matrix, model = \"rasch\") cat(sprintf(\"WLE reliability: %.4f\\n\", tam_rel$rel_wle)) cat(sprintf(\"EAP reliability: %.4f\\n\", tam_rel$rel_eap)) } # }"},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_rho_bar.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Marginal Reliability from Simulated Test Information ‚Äî compute_rho_bar","title":"Compute Marginal Reliability from Simulated Test Information ‚Äî compute_rho_bar","text":"Low-level utilities mapping discrimination scale \\(c\\) simulated person/item parameters marginal reliability. functions implement reliability definitions used inside eqc_calibrate() spc_calibrate(): compute_rho_bar(): MSEM-based marginal reliability \\(\\bar{w}(c) = \\sigma_\\theta^2 / (\\sigma_\\theta^2 + E[1/\\mathcal{J}(\\theta;c)])\\) compute_rho_tilde(): Average-information reliability \\(\\tilde{\\rho}(c) = \\sigma_\\theta^2 \\bar{\\mathcal{J}}(c) /       (\\sigma_\\theta^2 \\bar{\\mathcal{J}}(c) + 1)\\)","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_rho_bar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Marginal Reliability from Simulated Test Information ‚Äî compute_rho_bar","text":"","code":"compute_rho_bar(c, theta_vec, beta_vec, lambda_base, theta_var = NULL)  compute_rho_tilde(c, theta_vec, beta_vec, lambda_base, theta_var = NULL)"},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_rho_bar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Marginal Reliability from Simulated Test Information ‚Äî compute_rho_bar","text":"c Numeric scalar. Global discrimination scaling factor. theta_vec Numeric vector abilities \\(\\theta_m\\). beta_vec Numeric vector item difficulties \\(\\beta_i\\). lambda_base Numeric vector baseline discriminations \\(\\lambda_{,0}\\) (scaling c). theta_var Optional numeric. Pre-calculated variance theta. NULL, computed theta_vec.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_rho_bar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Marginal Reliability from Simulated Test Information ‚Äî compute_rho_bar","text":"Numeric scalar reliability value.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_rho_bar.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Marginal Reliability from Simulated Test Information ‚Äî compute_rho_bar","text":"computation proceeds : Form scaled discriminations \\(\\lambda_i(c) = c \\cdot \\lambda_{,0}\\). Compute item response probabilities \\(p_{mi} = \\text{logit}^{-1}\\{\\lambda_i(c)(\\theta_m - \\beta_i)\\}\\). Item information: \\(\\mathcal{J}_{mi} = \\lambda_i(c)^2 p_{mi}(1-p_{mi})\\). Test information \\(\\theta_m\\): \\(\\mathcal{J}_m = \\sum_i \\mathcal{J}_{mi}\\). Reliability: compute_rho_bar(): harmonic-mean-based MSEM \\(\\text{MSEM} = E[1/\\mathcal{J}_m]\\), \\(\\bar{w}(c) = \\sigma_\\theta^2 / (\\sigma_\\theta^2 + \\text{MSEM})\\). compute_rho_tilde(): arithmetic-mean-based information \\(\\bar{\\mathcal{J}} = E[\\mathcal{J}_m]\\), \\(\\tilde{\\rho}(c) = \\sigma_\\theta^2 \\bar{\\mathcal{J}} /           (\\sigma_\\theta^2 \\bar{\\mathcal{J}} + 1)\\). small floor (1e-10) applied test information avoid numerical problems taking reciprocals.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_rho_bar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Marginal Reliability from Simulated Test Information ‚Äî compute_rho_bar","text":"","code":"# Simple toy example set.seed(1) theta <- rnorm(1000) beta  <- rnorm(20) lambda0 <- rep(1, 20)  compute_rho_bar(1, theta, beta, lambda0) #> [1] 0.7795393 compute_rho_tilde(1, theta, beta, lambda0) #> [1] 0.7870079  # With pre-calculated theta variance (recommended for SPC) theta_var_fixed <- var(rnorm(10000))  # Pre-calculate from large sample compute_rho_bar(1, theta, beta, lambda0, theta_var = theta_var_fixed) #> [1] 0.7684109"},{"path":"https://joonho112.github.io/IRTsimrel/reference/eqc_calibrate.html","id":null,"dir":"Reference","previous_headings":"","what":"Empirical Quadrature Calibration (Algorithm 1: EQC/SQC) ‚Äî eqc_calibrate","title":"Empirical Quadrature Calibration (Algorithm 1: EQC/SQC) ‚Äî eqc_calibrate","text":"eqc_calibrate() implements Algorithm 1 (Empirical / Stochastic Quadrature Calibration, EQC/SQC) reliability-targeted IRT simulation. Given target marginal reliability \\(\\rho^*\\), latent distribution generator sim_latentG() (\\(G\\)) item parameter generator sim_item_params() (\\(H\\)), function searches global discrimination scale \\(c^* > 0\\) population reliability \\(\\rho(c)\\) Rasch/2PL model approximately equal \\(\\rho^*\\). key idea : Draw large fixed \"quadrature\" sample \\(\\{\\theta_m\\}_{m=1}^M \\sim G\\) item parameters \\(\\{(\\beta_i, \\lambda_{,0})\\}_{=1}^\\sim H\\) . scale \\(c\\), form \\(\\lambda_i(c) = c \\cdot \\lambda_{,0}\\) compute empirical approximation population reliability \\(\\hat\\rho_M(c)\\) test information function. Solve scalar equation \\(\\hat\\rho_M(c^*) = \\rho^*\\) using deterministic root-finding (Brent's method via uniroot()).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/eqc_calibrate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Empirical Quadrature Calibration (Algorithm 1: EQC/SQC) ‚Äî eqc_calibrate","text":"","code":"eqc_calibrate(   target_rho,   n_items,   model = c(\"rasch\", \"2pl\"),   latent_shape = \"normal\",   item_source = \"irw\",   latent_params = list(),   item_params = list(),   reliability_metric = c(\"msem\", \"info\", \"bar\", \"tilde\"),   M = 10000L,   c_bounds = c(0.3, 3),   tol = 1e-04,   seed = NULL,   verbose = FALSE )"},{"path":"https://joonho112.github.io/IRTsimrel/reference/eqc_calibrate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Empirical Quadrature Calibration (Algorithm 1: EQC/SQC) ‚Äî eqc_calibrate","text":"target_rho Numeric (0, 1). Target marginal reliability \\(\\rho^*\\). n_items Integer. Number items test form. model Character. Measurement model: \"rasch\" \"2pl\". \"rasch\", baseline discriminations set 1 scaling. latent_shape Character. Shape argument passed sim_latentG() (e.g. \"normal\", \"bimodal\", \"heavy_tail\", ...). item_source Character. Source argument passed sim_item_params() (e.g. \"irw\", \"parametric\", \"hierarchical\", \"custom\"). latent_params List. Additional arguments passed sim_latentG(). item_params List. Additional arguments passed sim_item_params(). reliability_metric Character. Reliability definition used inside EQC: \"msem\" MSEM-based marginal reliability (default, theoretically exact). \"info\" Average-information reliability (faster, stable). Synonyms: \"bar\" \"msem\", \"tilde\" \"info\". M Integer. Size empirical quadrature sample (default: 10000). c_bounds Numeric length-2 vector. Search bounds \\(c\\). Default: c(0.3, 3). tol Numeric. Tolerance uniroot(). Default: 1e-4. seed Optional integer reproducibility. verbose Logical. TRUE, print progress messages.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/eqc_calibrate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Empirical Quadrature Calibration (Algorithm 1: EQC/SQC) ‚Äî eqc_calibrate","text":"object class \"eqc_result\" (list) elements: c_star Calibrated discrimination scale \\(c^*\\). target_rho Target reliability \\(\\rho^*\\). achieved_rho Empirical quadrature estimate \\(\\hat\\rho_M(c^*)\\). metric Reliability metric used. theta_quad Length-M vector quadrature abilities. theta_var Sample variance theta_quad. items_base item_params object scale = 1 (baseline). items_calib item_params object discriminations scaled c_star.","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/reference/eqc_calibrate.html","id":"reliability-metrics","dir":"Reference","previous_headings":"","what":"Reliability Metrics","title":"Empirical Quadrature Calibration (Algorithm 1: EQC/SQC) ‚Äî eqc_calibrate","text":"function supports two reliability definitions: MSEM-based (\"msem\"/\"bar\"): Uses harmonic mean test information, \\(\\bar{w}(c) = \\sigma^2_\\theta / (\\sigma^2_\\theta + E[1/\\mathcal{J}(\\theta;c)])\\). theoretically exact may lower ceiling high reliability. Average-information (\"info\"/\"tilde\"): Uses arithmetic mean, \\(\\tilde{\\rho}(c) = \\sigma^2_\\theta \\bar{\\mathcal{J}}(c) / (\\sigma^2_\\theta \\bar{\\mathcal{J}}(c) + 1)\\). Jensen's inequality, \\(\\tilde{\\rho} \\geq \\bar{w}\\), metric typically yields higher reliability values.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/eqc_calibrate.html","id":"wle-vs-eap-reliability-interpretation","dir":"Reference","previous_headings":"","what":"WLE vs EAP Reliability Interpretation","title":"Empirical Quadrature Calibration (Algorithm 1: EQC/SQC) ‚Äî eqc_calibrate","text":"validating TAM, note EAP reliability systematically higher WLE reliability. bug mathematical property TAM's definitions. EAP reliability directly corresponds MSEM-based population reliability targeted EQC. conservative inference, treat WLE lower bound EAP upper bound true measurement precision.","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/reference/eqc_calibrate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Empirical Quadrature Calibration (Algorithm 1: EQC/SQC) ‚Äî eqc_calibrate","text":"","code":"if (FALSE) { # \\dontrun{ # Basic EQC calibration eqc_result <- eqc_calibrate(   target_rho = 0.80,   n_items = 25,   model = \"rasch\",   latent_shape = \"normal\",   item_source = \"irw\",   seed = 42,   verbose = TRUE ) print(eqc_result) } # }"},{"path":"https://joonho112.github.io/IRTsimrel/reference/plot.item_params.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for item_params objects ‚Äî plot.item_params","title":"Plot method for item_params objects ‚Äî plot.item_params","text":"Plot method item_params objects","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/plot.item_params.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for item_params objects ‚Äî plot.item_params","text":"","code":"# S3 method for class 'item_params' plot(x, type = c(\"scatter\", \"density\", \"both\"), ...)"},{"path":"https://joonho112.github.io/IRTsimrel/reference/plot.latent_G.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Method for latent_G Objects ‚Äî plot.latent_G","title":"Plot Method for latent_G Objects ‚Äî plot.latent_G","text":"Plot Method latent_G Objects","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/plot.latent_G.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Method for latent_G Objects ‚Äî plot.latent_G","text":"","code":"# S3 method for class 'latent_G' plot(   x,   type = c(\"both\", \"histogram\", \"density\"),   show_normal = TRUE,   bins = 50,   ... )"},{"path":"https://joonho112.github.io/IRTsimrel/reference/plot.latent_G.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Method for latent_G Objects ‚Äî plot.latent_G","text":"x latent_G object sim_latentG(). type Character. Type plot: \"histogram\", \"density\", \"\". show_normal Logical. Overlay normal reference density? bins Integer. Number histogram bins. ... Additional arguments passed plotting functions.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/plot.latent_G.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Method for latent_G Objects ‚Äî plot.latent_G","text":"ggplot2 object (available) base R plot.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/plot.spc_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot SPC Convergence Trajectory ‚Äî plot.spc_result","title":"Plot SPC Convergence Trajectory ‚Äî plot.spc_result","text":"Visualizes Robbins-Monro iteration trajectory.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/plot.spc_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot SPC Convergence Trajectory ‚Äî plot.spc_result","text":"","code":"# S3 method for class 'spc_result' plot(x, type = c(\"both\", \"trajectory\", \"c\", \"rho\"), ...)"},{"path":"https://joonho112.github.io/IRTsimrel/reference/plot.spc_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot SPC Convergence Trajectory ‚Äî plot.spc_result","text":"x spc_result object. type Character. Plot type: \"trajectory\", \"rho\", \"c\", \"\". ... Additional arguments (unused).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/plot.spc_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot SPC Convergence Trajectory ‚Äî plot.spc_result","text":"ggplot object (ggplot2 available) NULL (base R fallback).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/print.latent_G.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for latent_G Objects ‚Äî print.latent_G","title":"Print Method for latent_G Objects ‚Äî print.latent_G","text":"Print Method latent_G Objects","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/print.latent_G.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for latent_G Objects ‚Äî print.latent_G","text":"","code":"# S3 method for class 'latent_G' print(x, ...)"},{"path":"https://joonho112.github.io/IRTsimrel/reference/print.latent_G.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for latent_G Objects ‚Äî print.latent_G","text":"x latent_G object sim_latentG(). ... Additional arguments (ignored).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/sim_item_params.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Item Parameters for IRT Studies ‚Äî sim_item_params","title":"Simulate Item Parameters for IRT Studies ‚Äî sim_item_params","text":"sim_item_params() generates item parameters (difficulty \\(\\beta\\) discrimination \\(\\lambda\\)) Item Response Theory (IRT) simulation studies. wraps IRW irw_simu_diff() function realistic difficulty distributions provides multiple methods generating correlated discriminations. function designed four key principles: Realistic difficulties: Integration Item Response Warehouse (IRW) empirically-grounded difficulty distributions. Correlated parameters: Support empirically observed negative correlation difficulty discrimination (Sweeney et al., 2022). Marginal preservation: Copula method preserves exact marginal distributions achieving target correlation. Reliability targeting: Scale factor subsequent calibration.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/sim_item_params.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Item Parameters for IRT Studies ‚Äî sim_item_params","text":"","code":"sim_item_params(   n_items,   model = c(\"rasch\", \"2pl\"),   source = c(\"irw\", \"parametric\", \"hierarchical\", \"custom\"),   method = c(\"copula\", \"conditional\", \"independent\"),   n_forms = 1L,   difficulty_params = list(),   discrimination_params = list(),   hierarchical_params = list(),   custom_params = list(),   scale = 1,   center_difficulties = TRUE,   seed = NULL )"},{"path":"https://joonho112.github.io/IRTsimrel/reference/sim_item_params.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Item Parameters for IRT Studies ‚Äî sim_item_params","text":"n_items Integer. Number items generate per form. model Character. data-generating model: \"rasch\" \"2pl\". source Character. Source generating difficulties: \"irw\" Use IRW difficulty pool (realistic, empirical) \"parametric\" Generate parametric distribution \"hierarchical\" Joint MVN parameters (Glas & van der Linden) \"custom\" User-supplied parameters function method Character. Method generating discriminations (model = \"2pl\"): \"copula\" Gaussian copula - preserves marginals exactly (RECOMMENDED) \"conditional\" Conditional normal regression difficulty \"independent\" Independent generation (correlation) n_forms Integer. Number test forms generate. Default 1. > 1, returns data frame form_id column. difficulty_params List. Parameters difficulty generation: source = \"irw\": pool - difficulty pool data frame source = \"parametric\": mu, sigma, distribution discrimination_params List. Parameters discrimination generation: mu_log Mean log-discrimination (default: 0) sigma_log SD log-discrimination (default: 0.3) rho Target correlation \\(\\beta\\) \\(\\log(\\lambda)\\) (default: -0.3) hierarchical_params List. source = \"hierarchical\": mu 2-vector: means \\((\\log\\lambda, \\beta)\\) tau 2-vector: SDs rho Correlation custom_params List. source = \"custom\": beta Vector function returning difficulties lambda Vector function returning discriminations scale Numeric. Global discrimination scaling factor reliability targeting. Final discriminations \\(\\lambda_i^* = c \\cdot \\lambda_i\\). Default 1. center_difficulties Logical. TRUE, center difficulties sum zero identification. Default TRUE. seed Integer. Random seed reproducibility.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/sim_item_params.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Item Parameters for IRT Studies ‚Äî sim_item_params","text":"object class \"item_params\" containing: data Data frame columns: form_id, item_id, beta, lambda, lambda_unscaled model Model type used source Source used generation method Method used discrimination generation n_items Number items per form n_forms Number forms generated scale Scale factor applied centered Whether difficulties centered params Parameters used generation achieved Achieved statistics (correlations, moments)","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/reference/sim_item_params.html","id":"why-copula-method-is-recommended","dir":"Reference","previous_headings":"","what":"Why Copula Method is Recommended","title":"Simulate Item Parameters for IRT Studies ‚Äî sim_item_params","text":"difficulties come IRW pool (realistic, often non-normal marginal distributions), conditional normal method can distort achieved correlation assumes linearity. Gaussian copula method: Transforms difficulties uniform scale via empirical CDF Generates correlated uniforms Gaussian copula Transforms back desired marginals (log-normal discrimination) guarantees: Exact preservation difficulty marginal (whatever IRW provides) Exact log-normal marginal discriminations Spearman correlation \\(\\approx \\rho\\) (rank-based, robust non-normality","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/sim_item_params.html","id":"connection-to-reliability-targeted-framework","dir":"Reference","previous_headings":"","what":"Connection to Reliability-Targeted Framework","title":"Simulate Item Parameters for IRT Studies ‚Äî sim_item_params","text":"scale parameter implements \"separation structure scale\": Structure: Realistic item characteristics IRW + correlation Scale: Global factor \\(c\\) calibrated target reliability","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/sim_item_params.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Simulate Item Parameters for IRT Studies ‚Äî sim_item_params","text":"Glas, C. . W., & van der Linden, W. J. (2003). Computerized adaptive testing item cloning. Applied Psychological Measurement, 27(4), 247-261. Sweeney, S. M., et al. (2022). investigation nature consequence relationship IRT difficulty discrimination. EM:IP, 41(4), 50-67. Zhang, L., et al. (2025). Realistic simulation item difficulties. PsyArXiv.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/sim_item_params.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate Item Parameters for IRT Studies ‚Äî sim_item_params","text":"","code":"# Example 1: Rasch with IRW difficulties items1 <- sim_item_params(n_items = 25, model = \"rasch\", source = \"irw\")  # Example 2: 2PL with copula method (recommended) items2 <- sim_item_params(   n_items = 30, model = \"2pl\", source = \"irw\",   method = \"copula\",   discrimination_params = list(rho = -0.3) )  # Example 3: Multiple forms items3 <- sim_item_params(   n_items = 20, model = \"2pl\", n_forms = 5,   source = \"irw\", method = \"copula\" ) #> Warning: collapsing to unique 'x' values  # Example 4: Hierarchical 2PL items4 <- sim_item_params(   n_items = 25, model = \"2pl\", source = \"hierarchical\",   hierarchical_params = list(mu = c(0, 0), tau = c(0.25, 1), rho = -0.3) )"},{"path":"https://joonho112.github.io/IRTsimrel/reference/sim_latentG.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Latent Ability Distribution for IRT Studies (G-family) ‚Äî sim_latentG","title":"Simulate Latent Ability Distribution for IRT Studies (G-family) ‚Äî sim_latentG","text":"sim_latentG() generates latent abilities (person parameters \\(\\theta\\)) Item Response Theory (IRT) simulation studies. implements population model \\(\\theta_p \\sim G\\) \\(G\\) flexible distribution family. function designed two key principles: Pre-standardization: distribution shape mathematically constructed mean 0 variance 1, ensuring changing shape inadvertently change scale. Separation Structure Scale: sigma parameter directly controls standard deviation latent trait, independent distributional shape. generated abilities follow: $$\\theta_p = \\mu + X_p^\\top \\beta + \\sigma \\cdot z_p$$ \\(z_p \\sim G_0\\) \\(E[z]=0\\) \\(Var[z]=1\\).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/sim_latentG.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Latent Ability Distribution for IRT Studies (G-family) ‚Äî sim_latentG","text":"","code":"sim_latentG(   n,   shape = c(\"normal\", \"bimodal\", \"trimodal\", \"multimodal\", \"skew_pos\", \"skew_neg\",     \"heavy_tail\", \"light_tail\", \"uniform\", \"floor\", \"ceiling\", \"custom\"),   sigma = 1,   mu = 0,   xcov = NULL,   beta = NULL,   shape_params = list(),   mixture_spec = NULL,   standardize_custom = TRUE,   seed = NULL,   return_z = TRUE )"},{"path":"https://joonho112.github.io/IRTsimrel/reference/sim_latentG.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Latent Ability Distribution for IRT Studies (G-family) ‚Äî sim_latentG","text":"n Integer. Number persons (latent abilities) generate. shape Character. distributional shape standardized component. One : \"normal\" Standard normal \\(N(0,1)\\) \"bimodal\" Symmetric two-component Gaussian mixture analytically standardized parameters \"trimodal\" Symmetric three-component Gaussian mixture \"multimodal\" Four-component Gaussian mixture \"skew_pos\" Right-skewed distribution via standardized Gamma \"skew_neg\" Left-skewed distribution (negated Gamma) \"heavy_tail\" Heavy-tailed distribution via standardized Student-t \"light_tail\" Light-tailed (platykurtic) mixture distribution \"uniform\" Uniform distribution \\([-\\sqrt{3}, \\sqrt{3}]\\) \"floor\" Distribution floor effect (left-truncated feel) \"ceiling\" Distribution ceiling effect (right-truncated feel) \"custom\" User-specified mixture distribution sigma Numeric. Scale (standard deviation) residual latent trait. Since standardized component variance 1, sigma directly equals marginal SD residual term. Default 1. mu Numeric. Grand mean latent ability distribution. Rasch models often fixed 0 identification. Default 0. xcov Matrix data.frame. Optional covariate matrix n rows. supplied, person-specific covariate effects added \\(\\eta = X\\beta\\). beta Numeric vector. Regression coefficients xcov. Must length equal ncol(xcov). Ignored xcov NULL. shape_params List. Additional parameters controlling shape. See Details shape-specific parameters. mixture_spec List. shape = \"custom\", specifies mixture: weights Numeric vector mixing proportions (must sum 1) means Numeric vector component means sds Numeric vector component standard deviations custom mixture automatically standardized mean 0 variance 1. standardize_custom Logical. TRUE (default), custom mixtures post-standardized ensure mean 0 variance 1. FALSE, raw mixture used (user must ensure proper standardization). seed Integer. Random seed reproducibility. NULL (default), current RNG state used. return_z Logical. TRUE, include standardized draws z output. Default TRUE.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/sim_latentG.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Latent Ability Distribution for IRT Studies (G-family) ‚Äî sim_latentG","text":"object class \"latent_G\" (list) containing: theta Numeric vector length n, simulated latent abilities z Standardized draws (return_z = TRUE) eta_cov Covariate linear predictor (0 covariates) mu Grand mean used sigma Scale parameter used shape Shape label shape_params Shape parameters used n Sample size sample_moments List sample mean, sd, skewness, kurtosis","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/reference/sim_latentG.html","id":"pre-standardization-mathematics","dir":"Reference","previous_headings":"","what":"Pre-standardization Mathematics","title":"Simulate Latent Ability Distribution for IRT Studies (G-family) ‚Äî sim_latentG","text":"built-shape constructed exactly mean 0 variance 1: Bimodal: Two-component mixture modes \\(\\pm\\delta\\): $$z = s \\cdot \\delta + \\epsilon, \\quad s \\sim \\text{Rademacher}, \\quad \\epsilon \\sim N(0, 1-\\delta^2)$$ component variance \\(1-\\delta^2\\) ensures \\(Var[z] = \\delta^2 + (1-\\delta^2) = 1\\). Trimodal: Three-component mixture weights \\((w_L, w_0, w_R)\\) means \\((-m, 0, m)\\). Component variance \\(\\sigma_c^2 = 1 - (1-w_0)m^2\\) ensure unit total variance. Skewed: Standardized Gamma distribution: $$z = \\frac{\\Gamma(k, 1) - k}{\\sqrt{k}}$$ \\(E[z]=0\\) \\(Var[z]=1\\) \\(k > 0\\). Heavy-tailed: Standardized Student-t: $$z = \\frac{t_\\nu}{\\sqrt{\\nu/(\\nu-2)}}$$ \\(Var[z]=1\\) \\(\\nu > 2\\).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/sim_latentG.html","id":"shape-specific-parameters","dir":"Reference","previous_headings":"","what":"Shape-Specific Parameters","title":"Simulate Latent Ability Distribution for IRT Studies (G-family) ‚Äî sim_latentG","text":"delta \"bimodal\": mode separation, must satisfy \\(0 < \\delta < 1\\). Default: 0.8 w0 \"trimodal\": weight central component, must satisfy \\(0 < w_0 < 1\\). Default: 1/3 m \"trimodal\": magnitude side component means. Must satisfy \\((1-w_0)m^2 < 1\\). Default: 1.2 k \"skew_pos\"/\"skew_neg\": Gamma shape parameter, controls skewness magnitude. Default: 4 df \"heavy_tail\": degrees freedom, must > 2. Default: 5","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/sim_latentG.html","id":"connection-to-irt-framework","dir":"Reference","previous_headings":"","what":"Connection to IRT Framework","title":"Simulate Latent Ability Distribution for IRT Studies (G-family) ‚Äî sim_latentG","text":"Rasch/2PL model, latent distribution \\(G\\) affects: Marginal reliability: \\(\\bar{w} = \\sigma_\\theta^2 / (\\sigma_\\theta^2 + \\text{MSEM})\\) Expected test information: \\(\\bar{\\mathcal{J}} = E_G[\\mathcal{J}(\\theta)]\\) Identifiability (see Appendix F manuscript) function serves generator \\(G\\) reliability-targeted simulation studies, allowing researchers examine distributional shape affects model performance holding scale constant.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/sim_latentG.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Simulate Latent Ability Distribution for IRT Studies (G-family) ‚Äî sim_latentG","text":"Baker, F. B., & Kim, S.-H. (2004). Item Response Theory: Parameter Estimation Techniques (2nd ed.). Marcel Dekker. Paganin, S., et al. (2022). Computational strategies estimation performance Bayesian semiparametric item response theory models. Journal Educational Behavioral Statistics, 48(2), 147-188.","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/reference/sim_latentG.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate Latent Ability Distribution for IRT Studies (G-family) ‚Äî sim_latentG","text":"","code":"# Basic usage: standard normal abilities sim1 <- sim_latentG(n = 1000, shape = \"normal\") mean(sim1$theta)  # approximately 0 #> [1] -0.003041014 sd(sim1$theta)    # approximately 1 #> [1] 1.013878  # Bimodal distribution for heterogeneous population sim2 <- sim_latentG(n = 1000, shape = \"bimodal\",                     shape_params = list(delta = 0.9))  # Skewed distribution with larger scale sim3 <- sim_latentG(n = 1000, shape = \"skew_pos\", sigma = 1.5)  # With covariate effects (e.g., group differences) group <- rbinom(1000, 1, 0.5) sim4 <- sim_latentG(n = 1000, shape = \"normal\",                     xcov = data.frame(group = group),                     beta = 0.5)  # Custom mixture distribution sim5 <- sim_latentG(n = 1000, shape = \"custom\",                     mixture_spec = list(                       weights = c(0.3, 0.5, 0.2),                       means = c(-1.5, 0, 2),                       sds = c(0.5, 0.7, 0.5)                     ))"},{"path":"https://joonho112.github.io/IRTsimrel/reference/simulate_response_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Item Response Data from EQC Results ‚Äî simulate_response_data","title":"Simulate Item Response Data from EQC Results ‚Äî simulate_response_data","text":"Generates item response data using calibrated parameters EQC.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/simulate_response_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Item Response Data from EQC Results ‚Äî simulate_response_data","text":"","code":"simulate_response_data(   eqc_result,   n_persons,   latent_shape = \"normal\",   latent_params = list(),   seed = NULL )"},{"path":"https://joonho112.github.io/IRTsimrel/reference/simulate_response_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Item Response Data from EQC Results ‚Äî simulate_response_data","text":"eqc_result eqc_result object eqc_calibrate(). n_persons Integer. Number persons simulate. latent_shape Character. Shape argument sim_latentG(). latent_params List. Additional arguments sim_latentG(). seed Optional integer reproducibility.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/simulate_response_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Item Response Data from EQC Results ‚Äî simulate_response_data","text":"list containing: response_matrix N x matrix binary responses theta True abilities (N x 1) beta Item difficulties (x 1) lambda Item discriminations (x 1)","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/reference/simulate_response_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate Item Response Data from EQC Results ‚Äî simulate_response_data","text":"","code":"if (FALSE) { # \\dontrun{ # First, run EQC calibration eqc_result <- eqc_calibrate(   target_rho = 0.80,   n_items = 25,   model = \"rasch\",   seed = 42 )  # Generate response data sim_data <- simulate_response_data(   eqc_result = eqc_result,   n_persons = 1000,   latent_shape = \"normal\",   seed = 123 )  # Use with TAM for validation tam_rel <- compute_reliability_tam(sim_data$response_matrix, model = \"rasch\") } # }"},{"path":"https://joonho112.github.io/IRTsimrel/reference/spc_calibrate.html","id":null,"dir":"Reference","previous_headings":"","what":"Stochastic Approximation Calibration (Algorithm 2: SPC/SAC) ‚Äî spc_calibrate","title":"Stochastic Approximation Calibration (Algorithm 2: SPC/SAC) ‚Äî spc_calibrate","text":"spc_calibrate() implements Algorithm 2 (Stochastic Approximation Calibration, SPC/SAC) reliability-targeted IRT simulation using Robbins-Monro stochastic approximation algorithm. Given target marginal reliability \\(\\rho^*\\), latent distribution generator sim_latentG() (\\(G\\)) item parameter generator sim_item_params() (\\(H\\)), function iteratively searches global discrimination scale \\(c^* > 0\\) population reliability \\(\\rho(c)\\) Rasch/2PL model approximately equal \\(\\rho^*\\). SPC complements EQC (Algorithm 1) : Providing independent validation EQC calibration results. Enabling calibration exact marginal reliability \\(\\bar{w}\\) (just average-information approximation \\(\\tilde{\\rho}\\)). Handling complex data-generating processes analytic information functions may unavailable. algorithm uses Robbins-Monro update rule: $$c_{n+1} = c_n - a_n \\cdot (\\hat{\\rho}_n - \\rho^*)$$ \\(a_n = / (n + )^\\gamma\\) decreasing step size sequence satisfying \\(\\sum a_n = \\infty\\) \\(\\sum a_n^2 < \\infty\\).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/spc_calibrate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stochastic Approximation Calibration (Algorithm 2: SPC/SAC) ‚Äî spc_calibrate","text":"","code":"spc_calibrate(   target_rho,   n_items,   model = c(\"rasch\", \"2pl\"),   latent_shape = \"normal\",   item_source = \"irw\",   latent_params = list(),   item_params = list(),   reliability_metric = c(\"msem\", \"info\", \"bar\", \"tilde\"),   c_init = NULL,   M_per_iter = 500L,   M_pre = 10000L,   n_iter = 300L,   burn_in = NULL,   step_params = list(),   c_bounds = c(0.01, 20),   resample_items = TRUE,   seed = NULL,   verbose = FALSE )  sac_calibrate(   target_rho,   n_items,   model = c(\"rasch\", \"2pl\"),   latent_shape = \"normal\",   item_source = \"irw\",   latent_params = list(),   item_params = list(),   reliability_metric = c(\"msem\", \"info\", \"bar\", \"tilde\"),   c_init = NULL,   M_per_iter = 500L,   M_pre = 10000L,   n_iter = 300L,   burn_in = NULL,   step_params = list(),   c_bounds = c(0.01, 20),   resample_items = TRUE,   seed = NULL,   verbose = FALSE )"},{"path":"https://joonho112.github.io/IRTsimrel/reference/spc_calibrate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Stochastic Approximation Calibration (Algorithm 2: SPC/SAC) ‚Äî spc_calibrate","text":"target_rho Numeric (0, 1). Target marginal reliability \\(\\rho^*\\). n_items Integer. Number items test form. model Character. Measurement model: \"rasch\" \"2pl\". \"rasch\", baseline discriminations set 1 scaling. latent_shape Character. Shape argument passed sim_latentG() (e.g. \"normal\", \"bimodal\", \"heavy_tail\", ...). item_source Character. Source argument passed sim_item_params() (e.g. \"irw\", \"parametric\", \"hierarchical\", \"custom\"). latent_params List. Additional arguments passed sim_latentG(). item_params List. Additional arguments passed sim_item_params(). reliability_metric Character. Reliability definition used inside SPC: \"msem\" MSEM-based marginal reliability (theoretically exact, targets \\(\\bar{w}\\)). \"info\" Average-information reliability (faster, targets \\(\\tilde{\\rho}\\)). Synonyms: \"bar\" \"msem\", \"tilde\" \"info\". c_init Numeric, eqc_result object, NULL. Initial value scaling factor \\(c_0\\). eqc_result object provided, c_star used (warm start). numeric value provided, used directly. NULL, initialized using Analytic Pre-Calibration (APC). Providing warm start EQC greatly accelerates convergence. M_per_iter Integer. Number Monte Carlo samples per iteration estimating reliability. Default: 500. Larger values reduce variance increase computation time. M_pre Integer. Number Monte Carlo samples pre-calculating latent variance \\(\\sigma^2_\\theta\\). Default: 10000. variance fixed throughout iterations stability. CRITICAL parameter numerical stability. n_iter Integer. Total number Robbins-Monro iterations. Default: 300. burn_in Integer. Number initial iterations discard Polyak-Ruppert averaging. Default: floor(n_iter / 2). step_params List. Parameters controlling step size sequence: Base step size (default: 1.0) Stabilization constant (default: 50) gamma Decay exponent (default: 0.67, .e., 2/3) c_bounds Numeric length-2 vector. Projection bounds \\(c\\). Iterates clipped interval update. Default: c(0.01, 20). resample_items Logical. TRUE (default), resample item parameters iteration. FALSE, fix item parameters across iterations (reduces variance may introduce bias). seed Optional integer reproducibility. verbose Logical integer. TRUE >= 1, print progress messages. >= 2, print detailed iteration-level output.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/spc_calibrate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Stochastic Approximation Calibration (Algorithm 2: SPC/SAC) ‚Äî spc_calibrate","text":"object class \"spc_result\" (list) elements: c_star Calibrated discrimination scale (Polyak-Ruppert average). c_final Final iterate \\(c_{n_{iter}}\\). target_rho Target reliability \\(\\rho^*\\). achieved_rho Estimated reliability \\(c^*\\) (post-calibration). theta_var Pre-calculated latent variance used throughout. trajectory Numeric vector iterates. rho_trajectory Numeric vector reliability estimates. init_method Character indicating initialization method. metric Reliability metric used. convergence List convergence diagnostics.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/spc_calibrate.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Stochastic Approximation Calibration (Algorithm 2: SPC/SAC) ‚Äî spc_calibrate","text":"Robbins, H., & Monro, S. (1951). stochastic approximation method. Annals Mathematical Statistics, 22(3), 400‚Äì407. Polyak, B. T., & Juditsky, . B. (1992). Acceleration stochastic approximation averaging. SIAM Journal Control Optimization, 30(4), 838‚Äì855.","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/reference/spc_calibrate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Stochastic Approximation Calibration (Algorithm 2: SPC/SAC) ‚Äî spc_calibrate","text":"","code":"if (FALSE) { # \\dontrun{ # Example 1: Basic SPC calibration spc_result <- spc_calibrate(   target_rho = 0.75,   n_items = 20,   model = \"rasch\",   n_iter = 200,   seed = 12345,   verbose = TRUE ) print(spc_result) plot(spc_result)  # Example 2: Warm start from EQC (RECOMMENDED) eqc_result <- eqc_calibrate(   target_rho = 0.80,   n_items = 25,   model = \"2pl\",   M = 10000,   seed = 42 )  spc_result <- spc_calibrate(   target_rho = 0.80,   n_items = 25,   model = \"2pl\",   c_init = eqc_result,  # Direct EQC object passing!   n_iter = 100,   seed = 42 )  # Compare EQC and SPC results cat(sprintf(\"EQC c* = %.4f, SPC c* = %.4f\\n\",             eqc_result$c_star, spc_result$c_star)) } # }"},{"path":"https://joonho112.github.io/IRTsimrel/reference/summary.latent_G.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary Method for latent_G Objects ‚Äî summary.latent_G","title":"Summary Method for latent_G Objects ‚Äî summary.latent_G","text":"Summary Method latent_G Objects","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/summary.latent_G.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary Method for latent_G Objects ‚Äî summary.latent_G","text":"","code":"# S3 method for class 'latent_G' summary(object, ...)"},{"path":"https://joonho112.github.io/IRTsimrel/reference/summary.latent_G.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary Method for latent_G Objects ‚Äî summary.latent_G","text":"object latent_G object sim_latentG(). ... Additional arguments (ignored).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/summary.latent_G.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary Method for latent_G Objects ‚Äî summary.latent_G","text":"list summary statistics.","code":""}]
