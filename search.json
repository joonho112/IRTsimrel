[{"path":"https://joonho112.github.io/IRTsimrel/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 JoonHo Lee Permission hereby granted, free charge, person obtaining copy software associated documentation files (‚ÄúSoftware‚Äù), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED ‚Äú‚Äù, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-eqc.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"Empirical Quadrature Calibration (EQC) primary algorithm IRTsimrel solving inverse reliability problem. Given target marginal reliability œÅ*\\rho^*, EQC finds global discrimination scaling factor c*c^* population reliability equals target. Reading time: approximately 25 minutes. Prerequisites: vignette assumes familiarity mathematical foundations developed vignette(\"theory-reliability\"). applied usage tutorials workflows, see vignette(\"introduction\"). Key references: Lee (2025, arXiv:2512.16012), Sections 2.3‚Äì2.4; Brent (1973).","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-eqc.html","id":"algorithm-statement","dir":"Articles","previous_headings":"","what":"Algorithm Statement","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"EQC solves scalar root-finding problem œÅÃÇM(c)=œÅ*\\hat{\\rho}_M(c) = \\rho^* using three-step procedure.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-eqc.html","id":"formal-algorithm","dir":"Articles","previous_headings":"Algorithm Statement","what":"Formal Algorithm","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"Algorithm 1 (Empirical Quadrature Calibration). Input: Target reliability œÅ*\\rho^*, number items II, latent distribution GG, item parameter distribution HH, quadrature size MM, search bounds [cL,cU][c_L, c_U], tolerance Œµ\\varepsilon. Step 1 (Quadrature Sampling). Draw {Œ∏m}m=1M‚àºG\\{\\theta_m\\}_{m=1}^M \\sim G {(Œ≤i,Œªi(0))}=1I‚àºH\\{(\\beta_i, \\lambda_i^{(0)})\\}_{=1}^\\sim H. Fix samples subsequent evaluations. Step 2 (Empirical Reliability Function). Define œÅÃÇM:(0,‚àû)‚Üí(0,1)\\hat{\\rho}_M : (0, \\infty) \\(0, 1) : œÅÃÇM(c)=œÅ(c;{Œ∏m}m=1M,ùõÉ,c‚ãÖùõå(0))   \\hat{\\rho}_M(c) = \\rho\\bigl(c;\\, \\{\\theta_m\\}_{m=1}^M,\\,   \\boldsymbol{\\beta},\\, c \\cdot \\boldsymbol{\\lambda}^{(0)}\\bigr) using either œÅÃÉ\\tilde{\\rho} (info) w‚Äæ\\bar{w} (msem) definition. Step 3 (Brent Root-Finding). Solve gM(c)=œÅÃÇM(c)‚àíœÅ*=0g_M(c) = \\hat{\\rho}_M(c) - \\rho^* = 0 [cL,cU][c_L, c_U] using Brent‚Äôs method (stats::uniroot() R) tolerance Œµ\\varepsilon. Output: Calibrated scaling factor cÃÇM*\\hat{c}^*_M, achieved reliability œÅÃÇM(cÃÇM*)\\hat{\\rho}_M(\\hat{c}^*_M), calibrated item parameters.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-eqc.html","id":"why-fixed-quadrature","dir":"Articles","previous_headings":"Algorithm Statement","what":"Why Fixed Quadrature?","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"critical design choice Monte Carlo samples {Œ∏m}\\{\\theta_m\\} {(Œ≤i,Œªi(0))}\\{(\\beta_i, \\lambda_i^{(0)})\\} used every evaluation œÅÃÇM(c)\\hat{\\rho}_M(c) root-finding iteration. makes œÅÃÇM(c)\\hat{\\rho}_M(c) deterministic function cc given draw, : Guarantees Brent‚Äôs method converges (stochastic oscillation). Eliminates need step size tuning. Produces reproducible results given seed. trade-solution cÃÇM*\\hat{c}^*_M depends particular quadrature draw, introducing Monte Carlo error order O(1/M)O(1/\\sqrt{M}).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-eqc.html","id":"brents-root-finding-method","dir":"Articles","previous_headings":"","what":"Brent‚Äôs Root-Finding Method","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"EQC uses Brent‚Äôs method (Brent, 1973), combines safety bisection speed superlinear methods.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-eqc.html","id":"components-of-brents-method","dir":"Articles","previous_headings":"Brent‚Äôs Root-Finding Method","what":"Components of Brent‚Äôs Method","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"Brent‚Äôs method adaptively selects among three strategies iteration: Bisection: Takes midpoint current bracketing interval [,b][, b]. Always converges slow (linear rate). Secant method: Uses linear interpolation two recent points. Superlinear convergence rate approximately œÜ‚âà1.618\\varphi \\approx 1.618 (golden ratio), guaranteed stay within bounds. Inverse quadratic interpolation (IQI): Fits quadratic three recent points (inverse direction). Achieves faster convergence function smooth, order approximately 22. step, Brent‚Äôs method: Attempts IQI secant first (speed). Falls back bisection superlinear step leave bracket make insufficient progress.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-eqc.html","id":"convergence-properties","dir":"Articles","previous_headings":"Brent‚Äôs Root-Finding Method","what":"Convergence Properties","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"Proposition (Convergence Brent‚Äôs Method). Given continuous function gg [,b][, b] g()‚ãÖg(b)<0g() \\cdot g(b) < 0 (sign change), Brent‚Äôs method converges root c*c^* satisfying |g(c*)|<Œµ|g(c^*)| < \\varepsilon : O(log2(b‚àíaŒµ)) iterations (worst case, bisection) O\\!\\left(\\log_2\\!\\left(\\frac{b - }{\\varepsilon}\\right)\\right) \\text{ iterations (worst case, bisection)} practice, superlinear convergence typically achieves machine precision fewer 50 function evaluations. convergence order IQI succeeds approximately: |cn‚àíc*|‚âàO(2‚àí2n) |c_n - c^*| \\approx O\\!\\left(2^{-2^n}\\right) doubly exponential ‚Äî vastly faster linearly convergent |cn‚àíc*|‚âàO(2‚àín)|c_n - c^*| \\approx O(2^{-n}) pure bisection.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-eqc.html","id":"why-brents-method-is-ideal-for-eqc","dir":"Articles","previous_headings":"Brent‚Äôs Root-Finding Method","what":"Why Brent‚Äôs Method is Ideal for EQC","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"Several properties reliability function make Brent‚Äôs method particularly well-suited: Bracketed root: \"info\" metric, strict monotonicity œÅÃÉ(c)\\tilde{\\rho}(c) guarantees sign change [cL,cU][c_L, c_U] œÅ*\\rho^* feasible. Smooth function: œÅÃÇM(c)\\hat{\\rho}_M(c) infinitely differentiable cc, enabling fast superlinear convergence. derivative needed: Unlike Newton‚Äôs method, Brent‚Äôs method require computing ‚àÇœÅÃÇM/‚àÇc\\partial \\hat{\\rho}_M / \\partial c, avoiding complexity differentiating Monte Carlo sum. Robustness: bisection fallback prevents divergence even function near-zero slope (high low reliability regions).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-eqc.html","id":"convergence-theory","dir":"Articles","previous_headings":"","what":"Convergence Theory","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"theoretical properties EQC established Lee (2025), Appendix . state main results proof sketches. full notation definitions, see vignette(\"theory-reliability\").","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-eqc.html","id":"consistency-theorem-a-1","dir":"Articles","previous_headings":"Convergence Theory","what":"Consistency (Theorem A.1)","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"Theorem (Consistency EQC). Let c*c^* unique population solution œÅ(c*)=œÅ*\\rho(c^*) = \\rho^* let cÃÇM*\\hat{c}^*_M EQC solution quadrature size MM. : cÃÇM*‚Üí.s.c*M‚Üí‚àû \\hat{c}^*_M \\xrightarrow{\\text{.s.}} c^* \\quad \\text{} M \\\\infty Proof sketch. argument proceeds three steps: Uniform convergence: Uniform Law Large Numbers (ULLN), empirical reliability function converges uniformly compact set [cL,cU][c_L, c_U]: supc‚àà[cL,cU]|œÅÃÇM(c)‚àíœÅ(c)|‚Üí.s.0 \\sup_{c \\[c_L, c_U]} |\\hat{\\rho}_M(c) - \\rho(c)| \\xrightarrow{\\text{.s.}} 0  requires verifying family {hc(Œ∏,ùõÉ,ùõå)}c‚àà[cL,cU]\\{h_c(\\theta, \\boldsymbol{\\beta}, \\boldsymbol{\\lambda})\\}_{c \\[c_L, c_U]} satisfies Lipschitz bounded variation condition cc, follows smoothness logistic function. Uniqueness root: strict monotonicity œÅÃÉ(c)\\tilde{\\rho}(c) (Proposition 1 vignette(\"theory-reliability\")), equation œÅ(c)=œÅ*\\rho(c) = \\rho^* unique solution c*c^* interval œÅ(cL)<œÅ*<œÅ(cU)\\rho(c_L) < \\rho^* < \\rho(c_U). Root convergence: Combining uniform convergence objective uniqueness root, Argmax Continuous Mapping Theorem (zero-finding analogue) yields cÃÇM*‚Üíc*\\hat{c}^*_M \\c^* .s.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-eqc.html","id":"asymptotic-normality-theorem-a-2","dir":"Articles","previous_headings":"Convergence Theory","what":"Asymptotic Normality (Theorem A.2)","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"Theorem (Asymptotic Normality EQC). regularity conditions: M(cÃÇM*‚àíc*)‚ÜídN(0,œÉg2g‚Ä≤(c*)2) \\sqrt{M}\\,(\\hat{c}^*_M - c^*) \\xrightarrow{d} N\\!\\left(0,\\, \\frac{\\sigma^2_g}{g'(c^*)^2}\\right) g(c)=œÅ(c)‚àíœÅ*g(c) = \\rho(c) - \\rho^*, g‚Ä≤(c*)=œÅ‚Ä≤(c*)g'(c^*) = \\rho'(c^*) slope reliability function solution, œÉg2\\sigma^2_g asymptotic variance gÃÇM(c*)\\hat{g}_M(c^*). Proof sketch. Apply delta method (implicit function theorem version). CLT: MgÃÇM(c*)‚ÜídN(0,œÉg2) \\sqrt{M}\\,\\hat{g}_M(c^*) \\xrightarrow{d} N(0, \\sigma^2_g) Since cÃÇM*\\hat{c}^*_M solves gÃÇM(cÃÇM*)=0\\hat{g}_M(\\hat{c}^*_M) = 0, Taylor expansion around c*c^* gives: 0=gÃÇM(cÃÇM*)‚âàgÃÇM(c*)+g‚Ä≤(c*)(cÃÇM*‚àíc*) 0 = \\hat{g}_M(\\hat{c}^*_M) \\approx \\hat{g}_M(c^*) + g'(c^*)\\,(\\hat{c}^*_M - c^*) Solving cÃÇM*‚àíc*\\hat{c}^*_M - c^* scaling M\\sqrt{M} yields result. key requirement g‚Ä≤(c*)‚â†0g'(c^*) \\neq 0, follows strict monotonicity.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-eqc.html","id":"monte-carlo-error-analysis","dir":"Articles","previous_headings":"Convergence Theory","what":"Monte Carlo Error Analysis","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"Practical implications. asymptotic normality result () implies Monte Carlo standard error cÃÇM*\\hat{c}^*_M : SE(cÃÇM*)‚âàœÉgM|g‚Ä≤(c*)| \\text{SE}(\\hat{c}^*_M) \\approx \\frac{\\sigma_g}{\\sqrt{M}\\, |g'(c^*)|} reliability function‚Äôs slope |g‚Ä≤(c*)||g'(c^*)| acts amplification factor: steeper slopes (smaller c*c^*, moderate reliability targets) produce smaller estimation errors, flat slopes (extreme reliability targets near 0 1) produce larger errors. reliability estimate , delta method: |œÅÃÇM(cÃÇM*)‚àíœÅ*|=Op(1M) |\\hat{\\rho}_M(\\hat{c}^*_M) - \\rho^*| = O_p\\!\\left(\\frac{1}{\\sqrt{M}}\\right)","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-eqc.html","id":"information-floor","dir":"Articles","previous_headings":"Numerical Stability","what":"Information Floor","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"computing MSEM metric, reciprocal 1/ùí•(Œ∏;c)1/\\mathcal{J}(\\theta; c) can become numerically unstable test information small. package applies floor: ùí•safe(Œ∏;c)=max(ùí•(Œ∏;c),10‚àí10) \\mathcal{J}_{\\text{safe}}(\\theta; c) = \\max\\!\\bigl(\\mathcal{J}(\\theta; c),\\, 10^{-10}\\bigr) prevents division--zero introducing negligible bias (floor activated extreme ability values logistic probabilities near 0 1).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-eqc.html","id":"search-bound-sensitivity","dir":"Articles","previous_headings":"Numerical Stability","what":"Search Bound Sensitivity","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"choice [cL,cU][c_L, c_U] affects feasibility numerical behavior: narrow: target œÅ*\\rho^* may fall outside achievable range [cL,cU][c_L, c_U], causing EQC return boundary solution warning. wide: MSEM metric, non-monotonicity extreme cc (Proposition 2 vignette(\"theory-reliability\")) can cause multiple roots, Brent‚Äôs method may find wrong one. Default recommendation: c_bounds = c(0.3, 3) works well applications. Extend c(0.1, 5) c(0.1, 10) high-reliability targets (œÅ*>0.90\\rho^* > 0.90) unusual item/latent configurations.","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-eqc.html","id":"reliability-metric-comparison","dir":"Articles","previous_headings":"","what":"Reliability Metric Comparison","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"EQC supports two reliability metrics. choice affects interpretation numerical properties calibration.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-eqc.html","id":"average-information-tilderho-reliability_metric-info","dir":"Articles","previous_headings":"Reliability Metric Comparison","what":"Average-Information (œÅÃÉ\\tilde{\\rho}): reliability_metric = \"info\"","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"Advantages: Guaranteed monotonicity cc: unique root, bracketing issues. Faster convergence Brent‚Äôs method (steeper slope typical range). Recommended Lee (2025) default. Interpretation: reliability measurement precision uniform average level. Slightly optimistic (overestimates true marginal reliability).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-eqc.html","id":"msem-based-barw-reliability_metric-msem","dir":"Articles","previous_headings":"Reliability Metric Comparison","what":"MSEM-Based (w‚Äæ\\bar{w}): reliability_metric = \"msem\"","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"Advantages: Theoretically exact marginal reliability. Accounts heterogeneous measurement precision across Œ∏\\theta. Caution: Can non-monotone extreme cc values. c_bounds must bracket correct root.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-eqc.html","id":"jensens-gap-in-practice","dir":"Articles","previous_headings":"Reliability Metric Comparison","what":"Jensen‚Äôs Gap in Practice","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"","code":"# Calibrate under both metrics eqc_info <- eqc_calibrate(   target_rho = 0.80, n_items = 25, model = \"rasch\",   item_source = \"parametric\", reliability_metric = \"info\",   M = 5000L, seed = 42, verbose = FALSE )  eqc_msem <- eqc_calibrate(   target_rho = 0.80, n_items = 25, model = \"rasch\",   item_source = \"parametric\", reliability_metric = \"msem\",   M = 5000L, seed = 42, verbose = FALSE ) #> Warning in eqc_calibrate(target_rho = 0.8, n_items = 25, model = \"rasch\", : #> MSEM-based reliability (w-bar) may have a non-monotone objective for EQC (see #> Lee, 2025, Section 4.3). Consider using 'info' (rho-tilde) for EQC, or use #> sac_calibrate() which handles w-bar targeting correctly.  cat(\"Calibration with target rho* = 0.80:\\n\") #> Calibration with target rho* = 0.80: cat(sprintf(\"  Info metric: c* = %.4f, achieved = %.4f\\n\",             eqc_info$c_star, eqc_info$achieved_rho)) #>   Info metric: c* = 0.8995, achieved = 0.8000 cat(sprintf(\"  MSEM metric: c* = %.4f, achieved = %.4f\\n\",             eqc_msem$c_star, eqc_msem$achieved_rho)) #>   MSEM metric: c* = 0.9232, achieved = 0.8000 cat(sprintf(\"  Ratio c*_msem / c*_info: %.3f\\n\",             eqc_msem$c_star / eqc_info$c_star)) #>   Ratio c*_msem / c*_info: 1.026 # Cross-evaluate: what does each c* achieve under the other metric? theta_eval <- sim_latentG(5000, shape = \"normal\")$theta items_eval <- sim_item_params(25, model = \"rasch\", source = \"parametric\") beta_eval  <- items_eval$data$beta lambda_eval <- rep(1, 25)  both_at_info <- compute_rho_both(eqc_info$c_star, theta_eval, beta_eval, lambda_eval) both_at_msem <- compute_rho_both(eqc_msem$c_star, theta_eval, beta_eval, lambda_eval)  cat(\"\\nCross-evaluation of c* values:\\n\") #>  #> Cross-evaluation of c* values: cat(sprintf(\"  At c*_info = %.4f: rho_tilde = %.4f, rho_bar = %.4f\\n\",             eqc_info$c_star, both_at_info$rho_tilde, both_at_info$rho_bar)) #>   At c*_info = 0.8995: rho_tilde = 0.8000, rho_bar = 0.7937 cat(sprintf(\"  At c*_msem = %.4f: rho_tilde = %.4f, rho_bar = %.4f\\n\",             eqc_msem$c_star, both_at_msem$rho_tilde, both_at_msem$rho_bar)) #>   At c*_msem = 0.9232: rho_tilde = 0.8067, rho_bar = 0.8000"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-eqc.html","id":"monte-carlo-convergence-study","dir":"Articles","previous_headings":"Diagnostic Examples","what":"Monte Carlo Convergence Study","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"EQC solution improve quadrature size MM? Figure 2: Variability EQC estimates decreases quadrature size. standard deviation cÃÇM*\\hat{c}^*_M decreases approximately 1/M1/\\sqrt{M}, consistent theoretical prediction Theorem .2.","code":"M_values <- c(500, 1000, 2000, 5000) n_reps <- 10 target <- 0.80  # Run multiple replications at each M mc_results <- data.frame(   M = integer(), rep = integer(), c_star = numeric() )  for (M_val in M_values) {   for (r in 1:n_reps) {     res <- eqc_calibrate(       target_rho = target, n_items = 25, model = \"rasch\",       item_source = \"parametric\", reliability_metric = \"info\",       M = as.integer(M_val), seed = 100 * r + M_val, verbose = FALSE     )     mc_results <- rbind(mc_results, data.frame(       M = M_val, rep = r, c_star = res$c_star     ))   } }  # Summary statistics mc_summary <- aggregate(c_star ~ M, data = mc_results, FUN = function(x) {   c(mean = mean(x), sd = sd(x), min = min(x), max = max(x)) })  cat(\"Monte Carlo convergence of c* (target = 0.80, 25 Rasch items):\\n\") #> Monte Carlo convergence of c* (target = 0.80, 25 Rasch items): cat(sprintf(\"  %-8s %-10s %-10s %-10s\\n\", \"M\", \"Mean c*\", \"SD(c*)\", \"Range\")) #>   M        Mean c*    SD(c*)     Range for (i in seq_len(nrow(mc_summary))) {   vals <- mc_summary$c_star[i, ]   cat(sprintf(\"  %-8d %-10.4f %-10.4f [%.4f, %.4f]\\n\",               mc_summary$M[i], vals[\"mean\"], vals[\"sd\"],               vals[\"min\"], vals[\"max\"])) } #>   500      0.9565     0.0337     [0.9111, 1.0141] #>   1000     0.9417     0.0392     [0.8858, 1.0102] #>   2000     0.9362     0.0227     [0.9031, 0.9718] #>   5000     0.9169     0.0256     [0.8692, 0.9521] oldpar <- par(mar = c(4.5, 4.5, 3, 1)) on.exit(par(oldpar))  # Box plot of c* across M values M_factor <- factor(mc_results$M,                    labels = paste0(\"M=\", format(M_values, big.mark = \",\"))) boxplot(c_star ~ M_factor, data = mc_results,         col = \"lightblue\", border = \"steelblue\",         xlab = \"Quadrature Size M\", ylab = \"EQC c* estimate\",         main = \"Monte Carlo Variability of EQC\")  # Reference line at the grand mean abline(h = mean(mc_results$c_star[mc_results$M == max(M_values)]),        lty = 2, col = \"red\", lwd = 1.5) legend(\"topright\", legend = \"Reference (largest M)\",        lty = 2, col = \"red\", lwd = 1.5, cex = 0.9)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-eqc.html","id":"sensitivity-to-target-reliability","dir":"Articles","previous_headings":"Diagnostic Examples","what":"Sensitivity to Target Reliability","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"Figure 3: Calibrated scaling factor function target reliability.","code":"targets <- seq(0.50, 0.90, by = 0.05) sensitivity <- data.frame(   target  = targets,   c_star  = numeric(length(targets)),   achieved = numeric(length(targets)) )  for (j in seq_along(targets)) {   res <- eqc_calibrate(     target_rho = targets[j], n_items = 25, model = \"rasch\",     item_source = \"parametric\", reliability_metric = \"info\",     M = 5000L, seed = 42, verbose = FALSE   )   sensitivity$c_star[j]  <- res$c_star   sensitivity$achieved[j] <- res$achieved_rho }  cat(\"EQC sensitivity to target reliability (25 Rasch items, info metric):\\n\") #> EQC sensitivity to target reliability (25 Rasch items, info metric): cat(sprintf(\"  %-8s %-10s %-10s %-10s\\n\",             \"Target\", \"c*\", \"Achieved\", \"|Error|\")) #>   Target   c*         Achieved   |Error| for (j in seq_len(nrow(sensitivity))) {   cat(sprintf(\"  %-8.2f %-10.4f %-10.4f %-10.6f\\n\",               sensitivity$target[j],               sensitivity$c_star[j],               sensitivity$achieved[j],               abs(sensitivity$achieved[j] - sensitivity$target[j]))) } #>   0.50     0.4114     0.5000     0.000010   #>   0.55     0.4580     0.5500     0.000001   #>   0.60     0.5118     0.6000     0.000001   #>   0.65     0.5758     0.6500     0.000000   #>   0.70     0.6548     0.7000     0.000006   #>   0.75     0.7572     0.7500     0.000000   #>   0.80     0.8995     0.8000     0.000000   #>   0.85     1.1199     0.8500     0.000001   #>   0.90     1.5328     0.9000     0.000001 oldpar <- par(mar = c(4.5, 4.5, 3, 1)) on.exit(par(oldpar))  plot(sensitivity$target, sensitivity$c_star, type = \"b\",      pch = 19, col = \"steelblue\", lwd = 2,      xlab = expression(\"Target reliability \" * rho * \"*\"),      ylab = expression(\"Calibrated scaling factor c*\"),      main = \"EQC: Target vs Calibrated Scale\") grid(col = \"gray90\")"},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-eqc.html","id":"sensitivity-to-latent-distribution-shape","dir":"Articles","previous_headings":"Diagnostic Examples","what":"Sensitivity to Latent Distribution Shape","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"","code":"shapes <- c(\"normal\", \"bimodal\", \"heavy_tail\", \"skew_pos\") shape_pars <- list(   normal     = list(),   bimodal    = list(delta = 0.9),   heavy_tail = list(df = 5),   skew_pos   = list(k = 4) )  cat(\"EQC c* for different latent shapes (target = 0.80, 25 Rasch items):\\n\") #> EQC c* for different latent shapes (target = 0.80, 25 Rasch items): for (sh in shapes) {   res <- eqc_calibrate(     target_rho = 0.80, n_items = 25, model = \"rasch\",     item_source = \"parametric\", reliability_metric = \"info\",     latent_shape = sh, latent_params = shape_pars[[sh]],     M = 5000L, seed = 42, verbose = FALSE   )   cat(sprintf(\"  %-12s: c* = %.4f, achieved = %.4f\\n\",               sh, res$c_star, res$achieved_rho)) } #>   normal      : c* = 0.8995, achieved = 0.8000 #> Auto-wrapping shape parameter(s) {delta} into latent_params$shape_params. #>   bimodal     : c* = 0.9605, achieved = 0.8000 #> Auto-wrapping shape parameter(s) {df} into latent_params$shape_params. #>   heavy_tail  : c* = 0.9365, achieved = 0.8000 #> Auto-wrapping shape parameter(s) {k} into latent_params$shape_params. #>   skew_pos    : c* = 0.9132, achieved = 0.8000"},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-eqc.html","id":"model-comparison-rasch-vs-2pl","dir":"Articles","previous_headings":"Diagnostic Examples","what":"Model Comparison: Rasch vs 2PL","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"","code":"eqc_rasch <- eqc_calibrate(   target_rho = 0.80, n_items = 25, model = \"rasch\",   item_source = \"parametric\", reliability_metric = \"info\",   M = 5000L, seed = 42, verbose = FALSE )  eqc_2pl <- eqc_calibrate(   target_rho = 0.80, n_items = 25, model = \"2pl\",   item_source = \"parametric\", reliability_metric = \"info\",   M = 5000L, seed = 42, verbose = FALSE )  cat(\"Model comparison (target = 0.80, 25 items, info metric):\\n\") #> Model comparison (target = 0.80, 25 items, info metric): cat(sprintf(\"  Rasch: c* = %.4f, achieved = %.4f\\n\",             eqc_rasch$c_star, eqc_rasch$achieved_rho)) #>   Rasch: c* = 0.8995, achieved = 0.8000 cat(sprintf(\"  2PL:   c* = %.4f, achieved = %.4f\\n\",             eqc_2pl$c_star, eqc_2pl$achieved_rho)) #>   2PL:   c* = 0.8637, achieved = 0.8000 cat(sprintf(\"  Rasch baseline lambda: %s\\n\",             paste(unique(round(eqc_rasch$lambda_base, 2)), collapse = \", \"))) #>   Rasch baseline lambda: 1 cat(sprintf(\"  2PL baseline lambda range: [%.2f, %.2f]\\n\",             min(eqc_2pl$lambda_base), max(eqc_2pl$lambda_base))) #>   2PL baseline lambda range: [0.53, 2.08]"},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-eqc.html","id":"verbose-output-walkthrough","dir":"Articles","previous_headings":"Diagnostic Examples","what":"Verbose Output Walkthrough","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"verbose mode reveals internal steps EQC. Key information verbose output: Pre-calibration: Shows APC initialization feasibility bounds. Root status: Brent‚Äôs convergence status uniroot(). Achieved reliability: Final reliability calibrated c*c^*.","code":"eqc_v <- eqc_calibrate(   target_rho = 0.80, n_items = 25, model = \"rasch\",   item_source = \"parametric\", reliability_metric = \"info\",   M = 5000L, seed = 42, verbose = TRUE ) #> Step 1: Generating quadrature samples... #>   M (quad persons) = 5000 #>   I (items)        = 25 #>   theta: mean = -0.014, sd = 1.005, var = 1.010 #>   beta:  mean = 0.000, sd = 0.861 #>   lambda_base: mean = 1.000, sd = 0.000 #>   metric = info #> Step 2: Running root-finding algorithm... #>   At c = 0.300: rho = 0.3539, g = -0.4461 #>   At c = 3.000: rho = 0.9550, g = 0.1550 #>   c* = 0.899499 #>   Target rho    = 0.8000 #>   Achieved rho  = 0.8000 #>   Root status   = uniroot_success"},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-eqc.html","id":"output-structure","dir":"Articles","previous_headings":"","what":"Output Structure","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"eqc_calibrate() function returns object class \"eqc_result\" containing calibration results.","code":"# Key components cat(\"EQC result components:\\n\") #> EQC result components: cat(sprintf(\"  c_star:       %.4f  (calibrated scaling factor)\\n\",             eqc_v$c_star)) #>   c_star:       0.8995  (calibrated scaling factor) cat(sprintf(\"  target_rho:   %.2f  (target reliability)\\n\",             eqc_v$target_rho)) #>   target_rho:   0.80  (target reliability) cat(sprintf(\"  achieved_rho: %.4f  (achieved reliability)\\n\",             eqc_v$achieved_rho)) #>   achieved_rho: 0.8000  (achieved reliability) cat(sprintf(\"  metric:       %s   (reliability metric used)\\n\",             eqc_v$metric)) #>   metric:       info   (reliability metric used) cat(sprintf(\"  n_items:      %d    (number of items)\\n\",             length(eqc_v$beta_vec))) #>   n_items:      25    (number of items) cat(sprintf(\"  M (quadrature): %d\\n\", length(eqc_v$theta_quad))) #>   M (quadrature): 5000"},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-eqc.html","id":"prediction-and-downstream-use","dir":"Articles","previous_headings":"Output Structure","what":"Prediction and Downstream Use","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"predict() method evaluates reliability arbitrary scaling factors using stored quadrature samples.","code":"# Evaluate reliability at different c values c_query <- c(0.5, 1.0, 1.5, 2.0) pred <- predict(eqc_v, newdata = c_query)  cat(\"Predict method: reliability at different c values\\n\") #> Predict method: reliability at different c values for (j in seq_along(c_query)) {   cat(sprintf(\"  c = %.1f: rho = %.4f\\n\", c_query[j], pred[j])) } #>   c = 0.5: rho = 0.5897 #>   c = 1.0: rho = 0.8260 #>   c = 1.5: rho = 0.8972 #>   c = 2.0: rho = 0.9280"},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-eqc.html","id":"connection-to-sac-validation","dir":"Articles","previous_headings":"","what":"Connection to SAC Validation","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"rigorous validation, EQC results cross-checked SAC algorithm. recommended workflow : Run EQC primary calibration. Initialize SAC EQC result (warm start). Compare using compare_eqc_sac(). See vignette(\"algorithm-sac\") SAC algorithm details vignette(\"validation\") complete validation framework.","code":"# Quick cross-validation example sac_check <- sac_calibrate(   target_rho = 0.80, n_items = 25, model = \"rasch\",   item_source = \"parametric\", reliability_metric = \"info\",   c_init = eqc_v, n_iter = 200L, M_per_iter = 1000L,   seed = 42, verbose = FALSE )  comparison <- compare_eqc_sac(eqc_v, sac_check, verbose = FALSE) cat(sprintf(\"EQC-SAC agreement: %.2f%% difference\\n\", comparison$diff_pct)) #> EQC-SAC agreement: 1.31% difference"},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-eqc.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"EQC recommended primary algorithm reliability-targeted IRT simulation:","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-eqc.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Algorithm 1: Empirical Quadrature Calibration (EQC)","text":"Lee, J. (2025). Reliability-targeted simulation item response data: Solving inverse design problem. arXiv preprint arXiv:2512.16012. Brent, R. P. (1973). Algorithms Minimization Without Derivatives. Prentice-Hall. van der Vaart, . W. (1998). Asymptotic Statistics. Cambridge University Press.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-sac.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Algorithm 2: Stochastic Approximation Calibration (SAC)","text":"Stochastic Approximation Calibration (SAC) secondary algorithm IRTsimrel, designed complement EQC (Algorithm 1). SAC uses Robbins-Monro stochastic approximation framework find discrimination scaling factor c*c^* achieves target reliability. Reading time: approximately 25 minutes. Positioning: SAC serves primarily validation companion EQC. algorithms agree c*c^* (typically within 5%), calibration can trusted high confidence. SAC also provides trajectory-based convergence diagnostics EQC lacks. Prerequisites: Familiarity vignette(\"theory-reliability\") mathematical foundations. applied workflows, see vignette(\"introduction\"). Key references: Lee (2025, arXiv:2512.16012), Section 2.5; Robbins Monro (1951); Polyak Juditsky (1992); Kushner Yin (2003).","code":""},{"path":[]},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-sac.html","id":"the-stochastic-root-finding-problem","dir":"Articles","previous_headings":"The Robbins-Monro Framework","what":"The Stochastic Root-Finding Problem","title":"Algorithm 2: Stochastic Approximation Calibration (SAC)","text":"SAC targets root-finding problem EQC, uses fundamentally different approach. goal solve: g(c)=ùîº[œÅÃÇ(c)]‚àíœÅ*=0 g(c) = \\mathbb{E}\\!\\left[\\hat{\\rho}(c)\\right] - \\rho^* = 0 \\tag{1} g(c)=œÅ(c)‚àíœÅ*g(c) = \\rho(c) - \\rho^* reliability gap function. key distinction EQC SAC never constructs deterministic approximation gg. Instead, iteration nn, observes noisy evaluation: Yn=œÅÃÇn(cn)=œÅ(cn)+Œµn Y_n = \\hat{\\rho}_n(c_n) = \\rho(c_n) + \\varepsilon_n \\tag{2} œÅÃÇn\\hat{\\rho}_n computed fresh Monte Carlo samples step, Œµn\\varepsilon_n zero-mean noise bounded variance: ùîº[Œµn‚à£cn]=0\\mathbb{E}[\\varepsilon_n \\mid c_n] = 0 ùîº[Œµn2‚à£cn]‚â§œÉŒµ2\\mathbb{E}[\\varepsilon_n^2 \\mid c_n] \\leq \\sigma^2_\\varepsilon.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-sac.html","id":"the-robbins-monro-update-rule","dir":"Articles","previous_headings":"The Robbins-Monro Framework","what":"The Robbins-Monro Update Rule","title":"Algorithm 2: Stochastic Approximation Calibration (SAC)","text":"iterative update proceeds : cn+1=Œ†[cL,cU][cn‚àí(œÅÃÇn(cn)‚àíœÅ*)] c_{n+1} = \\Pi_{[c_L, c_U]}\\!\\left[c_n - a_n\\,(\\hat{\\rho}_n(c_n) - \\rho^*)\\right] \\tag{3} Œ†[cL,cU][‚ãÖ]\\Pi_{[c_L, c_U]}[\\cdot] denotes projection onto feasible interval [cL,cU][c_L, c_U] ana_n decreasing step size sequence. Intuition: œÅÃÇn(cn)>œÅ*\\hat{\\rho}_n(c_n) > \\rho^* (current reliability high), update decreases cnc_n (reducing discrimination, hence reliability). œÅÃÇn(cn)<œÅ*\\hat{\\rho}_n(c_n) < \\rho^*, update increases cnc_n.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-sac.html","id":"robbins-monro-conditions","dir":"Articles","previous_headings":"The Robbins-Monro Framework","what":"Robbins-Monro Conditions","title":"Algorithm 2: Stochastic Approximation Calibration (SAC)","text":"step size sequence must satisfy: ‚àën=1‚àû=‚àû‚àën=1‚àûan2<‚àû \\sum_{n=1}^{\\infty} a_n = \\infty \\quad\\text{}\\quad \\sum_{n=1}^{\\infty} a_n^2 < \\infty \\tag{4} First condition (Œ£an=‚àû\\Sigma a_n = \\infty): Ensures algorithm can reach point parameter space, regardless initial value. Without , total adjustment ‚àë‚ãÖ|œÅÃÇn‚àíœÅ*|\\sum a_n \\cdot |\\hat{\\rho}_n - \\rho^*| might bounded, preventing convergence distant starting point. Second condition (Œ£an2<‚àû\\Sigma a_n^2 < \\infty): Controls accumulated noise. total noise variance proportional ‚àëan2œÉŒµ2\\sum a_n^2 \\sigma^2_\\varepsilon, must finite convergence.","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-sac.html","id":"the-step-size-sequence","dir":"Articles","previous_headings":"Step Size Analysis","what":"The Step Size Sequence","title":"Algorithm 2: Stochastic Approximation Calibration (SAC)","text":"SAC uses parametric family: =(n+)Œ≥ a_n = \\frac{}{(n + )^\\gamma} \\tag{5} three parameters controlling different aspects learning dynamics.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-sac.html","id":"role-of-each-parameter","dir":"Articles","previous_headings":"Step Size Analysis","what":"Role of Each Parameter","title":"Algorithm 2: Stochastic Approximation Calibration (SAC)","text":">0a > 0 (scale constant): Controls overall magnitude updates. Larger aa means aggressive steps, leading faster initial progress potentially oscillation. package: step_params$(default: 1). ‚â•0A \\geq 0 (stabilization constant): Dampens early iterations step sizes otherwise large (a1=/(1+)Œ≥a_1 = /(1+)^\\gamma). >0A > 0, effective step size starts smaller, providing stability initial transient phase. particularly important c_init far c*c^*. package sets AA automatically based burn-fraction. Œ≥‚àà(1/2,1]\\gamma \\(1/2, 1] (decay exponent): Controls quickly step sizes decrease. package: step_params$gamma (default: 0.67). Œ≥=0.51\\gamma = 0.51: Slow decay, close boundary Robbins-Monro conditions. Maintains larger steps longer, can beneficial initial estimates poor. Œ≥=2/3\\gamma = 2/3: common compromise convergence speed stability. Œ≥=1\\gamma = 1: Fastest allowable decay. Reduces variance quickly may -correct initial value far solution.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-sac.html","id":"robbins-monro-conditions-verification","dir":"Articles","previous_headings":"Step Size Analysis","what":"Robbins-Monro Conditions Verification","title":"Algorithm 2: Stochastic Approximation Calibration (SAC)","text":"parametric family =/(n+)Œ≥a_n = /(n+)^\\gamma: ‚àën=1‚àû(n+)Œ≥=‚àû‚áîŒ≥‚â§1 \\sum_{n=1}^{\\infty} \\frac{}{(n+)^\\gamma} = \\infty \\quad\\iff\\quad \\gamma \\leq 1 ‚àën=1‚àûa2(n+)2Œ≥<‚àû‚áî2Œ≥>1‚áîŒ≥>1/2 \\sum_{n=1}^{\\infty} \\frac{^2}{(n+)^{2\\gamma}} < \\infty \\quad\\iff\\quad 2\\gamma > 1 \\;\\iff\\; \\gamma > 1/2 Therefore, Œ≥‚àà(1/2,1]\\gamma \\(1/2, 1] satisfies conditions.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-sac.html","id":"step-size-sensitivity","dir":"Articles","previous_headings":"Step Size Analysis","what":"Step Size Sensitivity","title":"Algorithm 2: Stochastic Approximation Calibration (SAC)","text":"effect different step size configurations can observed convergence trajectory. Figure 1: Effect step decay parameter SAC convergence trajectories. Observations: Slower decay (Œ≥=0.51\\gamma = 0.51) maintains larger oscillations longer eventually converges. Faster decay (Œ≥=1.0\\gamma = 1.0) converges quickly starting near solution, risks -correcting distant start. default Œ≥=0.67\\gamma = 0.67 provides good compromise speed stability.","code":"# Common setup eqc_ref <- eqc_calibrate(   target_rho = 0.80, n_items = 25, model = \"rasch\",   item_source = \"parametric\", M = 5000L, seed = 42, verbose = FALSE )  # Run SAC with different step decay values decays <- c(0.51, 0.67, 0.85, 1.0) colors <- c(\"steelblue\", \"coral\", \"seagreen\", \"purple\")  oldpar <- par(mar = c(4.5, 4.5, 3, 1)) on.exit(par(oldpar))  plot(NULL, xlim = c(1, 300), ylim = c(0.5, 2.5),      xlab = \"Iteration\", ylab = \"c_n\",      main = \"SAC Trajectories: Step Decay Sensitivity\") abline(h = eqc_ref$c_star, lty = 2, col = \"gray40\", lwd = 1.5)  for (k in seq_along(decays)) {   sac_k <- sac_calibrate(     target_rho = 0.80, n_items = 25, model = \"rasch\",     item_source = \"parametric\", reliability_metric = \"info\",     c_init = 0.5,  # deliberately poor start     n_iter = 300L, M_per_iter = 1000L,     step_params = list(gamma = decays[k]),     seed = 42, verbose = FALSE   )   lines(seq_along(sac_k$trajectory), sac_k$trajectory,         col = colors[k], lwd = 1.5) }  legend(\"topright\",        legend = c(sprintf(\"gamma = %.2f\", decays), \"EQC c*\"),        col = c(colors, \"gray40\"), lty = c(rep(1, 4), 2),        lwd = c(rep(1.5, 4), 1.5), cex = 0.85)"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-sac.html","id":"why-averaging","dir":"Articles","previous_headings":"Polyak-Ruppert Averaging","what":"Why Averaging?","title":"Algorithm 2: Stochastic Approximation Calibration (SAC)","text":"raw SAC iterates cnc_n converge rate O(n‚àíŒ≥)O(n^{-\\gamma}), suboptimal. Polyak Juditsky (1992) showed simple average iterates achieves optimal rate O(n‚àí1/2)O(n^{-1/2}), regardless Œ≥\\gamma (long Robbins-Monro conditions hold).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-sac.html","id":"the-averaging-formula","dir":"Articles","previous_headings":"Polyak-Ruppert Averaging","what":"The Averaging Formula","title":"Algorithm 2: Stochastic Approximation Calibration (SAC)","text":"discarding burn-period BB iterations, Polyak-Ruppert average : c‚ÄæN=1N‚àíB‚àën=B+1Ncn \\bar{c}_N = \\frac{1}{N - B} \\sum_{n=B+1}^{N} c_n \\tag{6} NN total number iterations BB burn-count.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-sac.html","id":"convergence-rate-comparison","dir":"Articles","previous_headings":"Polyak-Ruppert Averaging","what":"Convergence Rate Comparison","title":"Algorithm 2: Stochastic Approximation Calibration (SAC)","text":"practical benefit substantial. Œ≥=0.67\\gamma = 0.67 (package default), final iterate converges rate O(n‚àí0.67)O(n^{-0.67}), Polyak-Ruppert average converges rate O(n‚àí0.5)O(n^{-0.5}) ‚Äî nearly exponent considerably smaller constants due variance reduction.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-sac.html","id":"burn-in-selection","dir":"Articles","previous_headings":"Polyak-Ruppert Averaging","what":"Burn-In Selection","title":"Algorithm 2: Stochastic Approximation Calibration (SAC)","text":"burn-period BB large enough exclude initial transient (iterates approached solution) small enough include sufficient number post-burn-samples. package: burn_in parameter, specified integer count (default: floor(n_iter / 2), .e., 50% iterations). Guidelines: EQC warm start: default burn_in = floor(n_iter / 2) sufficient (starting near solution, transient short). cold start APC: default 50% burn-appropriate; long runs (N>1000N > 1000), smaller fraction (e.g., burn_in = floor(n_iter / 5)) can used include post-burn-samples.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-sac.html","id":"initialization-strategies","dir":"Articles","previous_headings":"","what":"Initialization Strategies","title":"Algorithm 2: Stochastic Approximation Calibration (SAC)","text":"initial value c0c_0 significantly affects SAC‚Äôs convergence speed. package supports three initialization methods.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-sac.html","id":"strategy-1-eqc-warm-start-recommended","dir":"Articles","previous_headings":"Initialization Strategies","what":"Strategy 1: EQC Warm Start (Recommended)","title":"Algorithm 2: Stochastic Approximation Calibration (SAC)","text":"Pass eqc_result object directly c_init: Advantages: Starting near solution means transient phase short, burn-can minimal, fewer iterations needed.","code":"eqc_for_init <- eqc_calibrate(   target_rho = 0.80, n_items = 25, model = \"rasch\",   item_source = \"parametric\", M = 5000L, seed = 42, verbose = FALSE )  sac_warm <- sac_calibrate(   target_rho = 0.80, n_items = 25, model = \"rasch\",   item_source = \"parametric\", reliability_metric = \"info\",   c_init = eqc_for_init,  # EQC warm start   n_iter = 200L, M_per_iter = 1000L,   seed = 42, verbose = FALSE )  cat(sprintf(\"EQC c*: %.4f\\n\", eqc_for_init$c_star)) #> EQC c*: 0.8995 cat(sprintf(\"SAC c* (warm start): %.4f\\n\", sac_warm$c_star)) #> SAC c* (warm start): 0.9113 cat(sprintf(\"Init method: %s\\n\", sac_warm$init_method)) #> Init method: eqc_warm_start"},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-sac.html","id":"strategy-2-analytic-pre-calibration-apc","dir":"Articles","previous_headings":"Initialization Strategies","what":"Strategy 2: Analytic Pre-Calibration (APC)","title":"Algorithm 2: Stochastic Approximation Calibration (SAC)","text":"c_init = NULL, SAC uses closed-form approximation derived Gaussian Rasch assumptions. Definition (APC Formula). assumptions Œ∏‚àºN(0,1)\\theta \\sim N(0, 1) Œ≤i‚àºN(0,œÉŒ≤2)\\beta_i \\sim N(0, \\sigma^2_\\beta) Œªi(0)=1\\lambda_i^{(0)} = 1 (Rasch), approximate initial value : cAPC=œÅ*‚ãÖŒ∫(œÉ2)‚ãÖ(1‚àíœÅ*) c_{\\text{APC}} = \\sqrt{\\frac{\\rho^*}{\\cdot \\kappa(\\sigma^2) \\cdot (1 - \\rho^*)}} \\tag{7} œÉ2=1+œÉŒ≤2\\sigma^2 = 1 + \\sigma^2_\\beta logistic-normal convolution constant approximated : Œ∫(œÉ2)‚âà0.251+œÉ2œÄ2/3 \\kappa(\\sigma^2) \\approx \\frac{0.25}{\\sqrt{1 + \\sigma^2 \\pi^2 / 3}} \\tag{8} Derivation sketch: Gaussian Rasch model, expected item information single item ùîº[Œª2p(1‚àíp)]=c2Œ∫(œÉ2)\\mathbb{E}[\\lambda^2 p(1-p)] = c^2 \\kappa(\\sigma^2). II items, average test information approximately Ic2Œ∫I c^2 \\kappa, œÅÃÉ‚âàœÉŒ∏2Ic2Œ∫/(œÉŒ∏2Ic2Œ∫+1)\\tilde{\\rho} \\approx \\sigma^2_\\theta c^2 \\kappa / (\\sigma^2_\\theta c^2 \\kappa + 1). Setting equal œÅ*\\rho^* solving cc yields Eq. (7).","code":"# APC initialization (c_init = NULL triggers APC) sac_apc <- sac_calibrate(   target_rho = 0.80, n_items = 25, model = \"rasch\",   item_source = \"parametric\", reliability_metric = \"info\",   c_init = NULL,  # APC warm start   n_iter = 300L, M_per_iter = 1000L,   seed = 42, verbose = FALSE )  cat(sprintf(\"SAC c* (APC start): %.4f\\n\", sac_apc$c_star)) #> SAC c* (APC start): 0.9793 cat(sprintf(\"Init method: %s\\n\", sac_apc$init_method)) #> Init method: apc_warm_start  # Compare APC init quality c_apc <- compute_apc_init(target_rho = 0.80, n_items = 25) cat(sprintf(\"APC initial value: %.4f (vs true c* ~ %.4f)\\n\",             c_apc, eqc_for_init$c_star)) #> APC initial value: 1.3274 (vs true c* ~ 0.8995)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-sac.html","id":"strategy-3-user-specified-value","dir":"Articles","previous_headings":"Initialization Strategies","what":"Strategy 3: User-Specified Value","title":"Algorithm 2: Stochastic Approximation Calibration (SAC)","text":"numeric value can passed directly:","code":"sac_user <- sac_calibrate(   target_rho = 0.80, n_items = 25, model = \"rasch\",   item_source = \"parametric\", reliability_metric = \"info\",   c_init = 1.0,  # user-specified   n_iter = 300L, M_per_iter = 1000L,   seed = 42, verbose = FALSE )  cat(sprintf(\"SAC c* (user init = 1.0): %.4f\\n\", sac_user$c_star)) #> SAC c* (user init = 1.0): 0.9233 cat(sprintf(\"Init method: %s\\n\", sac_user$init_method)) #> Init method: user_specified"},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-sac.html","id":"initialization-comparison","dir":"Articles","previous_headings":"Initialization Strategies","what":"Initialization Comparison","title":"Algorithm 2: Stochastic Approximation Calibration (SAC)","text":"Figure 2: Convergence speed depends strongly initialization quality.","code":"oldpar <- par(mar = c(4.5, 4.5, 3, 1)) on.exit(par(oldpar))  plot(NULL, xlim = c(1, 300), ylim = c(0, 3),      xlab = \"Iteration\", ylab = \"c_n\",      main = \"Effect of Initialization on Convergence\") abline(h = eqc_for_init$c_star, lty = 2, col = \"gray40\", lwd = 1.5)  lines(seq_along(sac_warm$trajectory), sac_warm$trajectory,       col = \"steelblue\", lwd = 1.5) lines(seq_along(sac_apc$trajectory), sac_apc$trajectory,       col = \"coral\", lwd = 1.5) lines(seq_along(sac_user$trajectory), sac_user$trajectory,       col = \"seagreen\", lwd = 1.5)  legend(\"topright\",        legend = c(\"EQC warm start\", \"APC\", \"User (c=1.0)\", \"EQC c*\"),        col = c(\"steelblue\", \"coral\", \"seagreen\", \"gray40\"),        lty = c(1, 1, 1, 2), lwd = 1.5, cex = 0.9)"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-sac.html","id":"almost-sure-convergence-theorem-a-3","dir":"Articles","previous_headings":"Convergence Theory","what":"Almost Sure Convergence (Theorem A.3)","title":"Algorithm 2: Stochastic Approximation Calibration (SAC)","text":"Theorem (SAC Convergence; cf.¬†Theorem .3, Lee 2025). Suppose: step sizes satisfy Eq. (4): ‚àë=‚àû\\sum a_n = \\infty, ‚àëan2<‚àû\\sum a_n^2 < \\infty. reliability function œÅ(c)\\rho(c) Lipschitz continuous [cL,cU][c_L, c_U]. g(c)=œÅ(c)‚àíœÅ*g(c) = \\rho(c) - \\rho^* unique root c*c^* (cL,cU)(c_L, c_U). g‚Ä≤(c*)>0g'(c^*) > 0 (strict monotonicity root). noise Œµn\\varepsilon_n satisfies ùîº[Œµn‚à£cn]=0\\mathbb{E}[\\varepsilon_n \\mid c_n] = 0 ùîº[Œµn2‚à£cn]‚â§œÉŒµ2<‚àû\\mathbb{E}[\\varepsilon_n^2 \\mid c_n] \\leq \\sigma^2_\\varepsilon < \\infty. projected SAC iterates converge almost surely: cn‚Üí.s.c*n‚Üí‚àû c_n \\xrightarrow{\\text{.s.}} c^* \\quad \\text{} n \\\\infty \\tag{9} Proof sketch. proof follows classical Robbins-Monro theory, extended projected (constrained) setting Kushner Yin (2003, Chapter 5). key steps : Lyapunov function: Define V(c)=(c‚àíc*)2V(c) = (c - c^*)^2. Compute conditional expectation V(cn+1)V(c_{n+1}) given cnc_n: ùîº[V(cn+1)‚à£cn]=V(cn)‚àí2an(cn‚àíc*)g(cn)+an2ùîº[(œÅÃÇn‚àíœÅ*)2‚à£cn] \\begin{aligned} \\mathbb{E}[V(c_{n+1}) \\mid c_n] &= V(c_n) - 2a_n(c_n - c^*) g(c_n) + a_n^2 \\mathbb{E}[(\\hat{\\rho}_n - \\rho^*)^2 \\mid c_n] \\end{aligned} Drift condition: Since g(c)(c‚àíc*)>0g(c)(c - c^*) > 0 c‚â†c*c \\neq c^* (reliability function increasing, gg sign c‚àíc*c - c^*), drift term ‚àí2an(cn‚àíc*)g(cn)<0-2a_n(c_n - c^*)g(c_n) < 0 provides contraction toward c*c^*. Noise control: accumulated noise ‚àëan2œÉŒµ2<‚àû\\sum a_n^2 \\sigma^2_\\varepsilon < \\infty (step size conditions), noise prevent convergence. Almost sure convergence: Robbins-Siegmund theorem (supermartingale convergence result), V(cn)‚ÜíV*V(c_n) \\V^* .s. random variable V*V^*. drift condition forces V*=0V^* = 0, giving cn‚Üíc*c_n \\c^* .s.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-sac.html","id":"asymptotic-normality-of-polyak-ruppert-average","dir":"Articles","previous_headings":"Convergence Theory","what":"Asymptotic Normality of Polyak-Ruppert Average","title":"Algorithm 2: Stochastic Approximation Calibration (SAC)","text":"Theorem (Polyak-Ruppert CLT). conditions Theorem .3 additional smoothness assumptions, Polyak-Ruppert average satisfies: N‚àíB(c‚ÄæN‚àíc*)‚ÜídN(0,œÉŒµ2g‚Ä≤(c*)2) \\sqrt{N - B}\\,(\\bar{c}_N - c^*) \\xrightarrow{d} N\\!\\left(0,\\, \\frac{\\sigma^2_\\varepsilon}{g'(c^*)^2}\\right) \\tag{10} achieves Cramer-Rao lower bound stochastic root-finding problem, meaning Polyak-Ruppert averaging asymptotically efficient. Rate comparison: Œ≥=0.67\\gamma = 0.67 (package default): Final iterate: MSE ‚àºO(n‚àí1.34)\\sim O(n^{-1.34}) Polyak-Ruppert average: MSE ‚àºO(n‚àí1)\\sim O(n^{-1}) final iterate converges faster rate PR average case, PR average achieves smaller constants optimal asymptotic efficiency. Œ≥\\gamma closer 1/21/2, rate improvement averaging dramatic.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-sac.html","id":"convergence-diagnostics","dir":"Articles","previous_headings":"Convergence Theory","what":"Convergence Diagnostics","title":"Algorithm 2: Stochastic Approximation Calibration (SAC)","text":"SAC provides automatic convergence assessment several statistics. Convergence criterion: algorithm considered converged : |c‚Äæfirst half‚àíc‚Äæsecond half|<0.05 |\\bar{c}_{\\text{first half}} - \\bar{c}_{\\text{second half}}| < 0.05 mean-split diagnostic detects systematic drift, indicate iterates yet settled around solution. Post-burn-SD: small relative c*c^*. Values 0.1 suggest iterations better initialization.","code":"# Run SAC with enough iterations sac_diag <- sac_calibrate(   target_rho = 0.80, n_items = 25, model = \"rasch\",   item_source = \"parametric\", reliability_metric = \"info\",   c_init = eqc_for_init, n_iter = 300L, M_per_iter = 1000L,   seed = 42, verbose = FALSE )  conv <- sac_diag$convergence cat(\"Convergence diagnostics:\\n\") #> Convergence diagnostics: cat(sprintf(\"  Converged:          %s\\n\", conv$converged)) #>   Converged:          TRUE cat(sprintf(\"  Mean (first half):  %.4f\\n\", conv$mean_first_half)) #>   Mean (first half):  0.9117 cat(sprintf(\"  Mean (second half): %.4f\\n\", conv$mean_second_half)) #>   Mean (second half): 0.9126 cat(sprintf(\"  SD (post-burn-in):  %.4f\\n\", conv$sd_post_burn)) #>   SD (post-burn-in):  0.0007 cat(sprintf(\"  Hit lower bound:    %s\\n\", conv$hit_lower_bound)) #>   Hit lower bound:    FALSE cat(sprintf(\"  Hit upper bound:    %s\\n\", conv$hit_upper_bound)) #>   Hit upper bound:    FALSE"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-sac.html","id":"when-they-agree","dir":"Articles","previous_headings":"Comparative Analysis: EQC vs SAC","what":"When They Agree","title":"Algorithm 2: Stochastic Approximation Calibration (SAC)","text":"algorithms use reliability metric SAC run converged, agreement within 5% typical expected.","code":"# Both targeting rho* = 0.80 with info metric eqc_comp <- eqc_calibrate(   target_rho = 0.80, n_items = 25, model = \"rasch\",   item_source = \"parametric\", reliability_metric = \"info\",   M = 5000L, seed = 42, verbose = FALSE )  sac_comp <- sac_calibrate(   target_rho = 0.80, n_items = 25, model = \"rasch\",   item_source = \"parametric\", reliability_metric = \"info\",   c_init = eqc_comp, n_iter = 300L, M_per_iter = 1000L,   seed = 42, verbose = FALSE )  comparison <- compare_eqc_sac(eqc_comp, sac_comp, verbose = FALSE) cat(sprintf(\"EQC c*:   %.4f\\n\", comparison$c_eqc)) #> EQC c*:   0.8995 cat(sprintf(\"SAC c*:   %.4f\\n\", comparison$c_sac)) #> SAC c*:   0.9122 cat(sprintf(\"Diff:     %.4f (%.2f%%)\\n\", comparison$diff_abs, comparison$diff_pct)) #> Diff:     0.0127 (1.41%) cat(sprintf(\"Agree:    %s\\n\", comparison$agreement)) #> Agree:    TRUE"},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-sac.html","id":"sources-of-disagreement","dir":"Articles","previous_headings":"Comparative Analysis: EQC vs SAC","what":"Sources of Disagreement","title":"Algorithm 2: Stochastic Approximation Calibration (SAC)","text":"EQC SAC disagree 5%, investigate following: Different reliability metrics: Ensure use \"info\" use \"msem\". Different metrics target different quantities, disagreement expected. SAC non-convergence: Check sac_result$convergence$converged. FALSE, increase n_iter use EQC warm start. Small M EQC: Low quadrature size introduces Monte Carlo error. Increase M EQC. Extreme target: high (>0.95> 0.95) low (<0.50< 0.50) targets flatter reliability curves, making algorithms less precise.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-sac.html","id":"what-to-do-when-they-disagree","dir":"Articles","previous_headings":"Comparative Analysis: EQC vs SAC","what":"What to Do When They Disagree","title":"Algorithm 2: Stochastic Approximation Calibration (SAC)","text":"","code":"# Strategy 1: Increase SAC iterations sac_longer <- sac_calibrate(   ..., n_iter = 500L, seed = 42 )  # Strategy 2: Increase EQC quadrature eqc_precise <- eqc_calibrate(   ..., M = 50000L, seed = 42 )  # Strategy 3: Verify same metric stopifnot(eqc_result$metric == sac_result$metric)  # Strategy 4: Run multiple SAC replications sac_reps <- replicate(5, {   sac_calibrate(     ..., seed = sample.int(10000, 1), verbose = FALSE   )$c_star }) cat(sprintf(\"SAC c* across 5 reps: mean = %.4f, sd = %.4f\\n\",             mean(sac_reps), sd(sac_reps)))"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-sac.html","id":"trajectory-analysis","dir":"Articles","previous_headings":"Diagnostic Examples","what":"Trajectory Analysis","title":"Algorithm 2: Stochastic Approximation Calibration (SAC)","text":"plot() method provides visual diagnostics SAC convergence. Figure 3: SAC convergence trajectory showing scaling factor iterations. Figure 4: SAC reliability trajectory showing convergence target.","code":"# Run SAC from APC start for a more interesting trajectory sac_traj <- sac_calibrate(   target_rho = 0.80, n_items = 25, model = \"rasch\",   item_source = \"parametric\", reliability_metric = \"info\",   c_init = NULL,  # APC start   n_iter = 300L, M_per_iter = 1000L,   seed = 42, verbose = FALSE )  plot(sac_traj, type = \"c\") plot(sac_traj, type = \"rho\")"},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-sac.html","id":"replication-variability","dir":"Articles","previous_headings":"Diagnostic Examples","what":"Replication Variability","title":"Algorithm 2: Stochastic Approximation Calibration (SAC)","text":"SAC inherently stochastic. Running multiple replications reveals variability estimate.","code":"n_reps <- 8 sac_reps <- numeric(n_reps)  for (r in seq_len(n_reps)) {   sac_r <- sac_calibrate(     target_rho = 0.80, n_items = 25, model = \"rasch\",     item_source = \"parametric\", reliability_metric = \"info\",     c_init = eqc_for_init,     n_iter = 200L, M_per_iter = 1000L,     seed = r * 100, verbose = FALSE   )   sac_reps[r] <- sac_r$c_star }  cat(\"SAC replication study (8 runs with EQC warm start):\\n\") #> SAC replication study (8 runs with EQC warm start): cat(sprintf(\"  Mean c*:  %.4f\\n\", mean(sac_reps))) #>   Mean c*:  0.9160 cat(sprintf(\"  SD c*:    %.4f\\n\", sd(sac_reps))) #>   SD c*:    0.0075 cat(sprintf(\"  Range:    [%.4f, %.4f]\\n\", min(sac_reps), max(sac_reps))) #>   Range:    [0.9056, 0.9247] cat(sprintf(\"  EQC c*:   %.4f\\n\", eqc_for_init$c_star)) #>   EQC c*:   0.8995 cat(sprintf(\"  |Mean - EQC|: %.4f\\n\", abs(mean(sac_reps) - eqc_for_init$c_star))) #>   |Mean - EQC|: 0.0165"},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-sac.html","id":"comparison-across-different-conditions","dir":"Articles","previous_headings":"Diagnostic Examples","what":"Comparison Across Different Conditions","title":"Algorithm 2: Stochastic Approximation Calibration (SAC)","text":"","code":"# Test across different target reliabilities targets <- c(0.60, 0.70, 0.80, 0.90) cat(\"EQC vs SAC across target reliabilities (25 Rasch items):\\n\") #> EQC vs SAC across target reliabilities (25 Rasch items): cat(sprintf(\"  %-8s %-10s %-10s %-10s %-8s\\n\",             \"Target\", \"EQC c*\", \"SAC c*\", \"|Diff|\", \"Agree\")) #>   Target   EQC c*     SAC c*     |Diff|     Agree  for (rho_t in targets) {   eqc_t <- eqc_calibrate(     target_rho = rho_t, n_items = 25, model = \"rasch\",     item_source = \"parametric\", reliability_metric = \"info\",     M = 5000L, seed = 42, verbose = FALSE   )   sac_t <- sac_calibrate(     target_rho = rho_t, n_items = 25, model = \"rasch\",     item_source = \"parametric\", reliability_metric = \"info\",     c_init = eqc_t, n_iter = 200L, M_per_iter = 1000L,     seed = 42, verbose = FALSE   )   diff_abs <- abs(eqc_t$c_star - sac_t$c_star)   diff_pct <- 100 * diff_abs / eqc_t$c_star   agree <- diff_pct < 5   cat(sprintf(\"  %-8.2f %-10.4f %-10.4f %-10.4f %-8s\\n\",               rho_t, eqc_t$c_star, sac_t$c_star, diff_abs,               ifelse(agree, \"YES\", \"NO\"))) } #>   0.60     0.5118     0.5145     0.0026     YES      #>   0.70     0.6548     0.6603     0.0055     YES      #>   0.80     0.8995     0.9113     0.0118     YES      #>   0.90     1.5328     1.5537     0.0209     YES"},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-sac.html","id":"effect-of-m_per_iter","dir":"Articles","previous_headings":"Diagnostic Examples","what":"Effect of M_per_iter","title":"Algorithm 2: Stochastic Approximation Calibration (SAC)","text":"per-iteration Monte Carlo sample size controls noise level SAC step.","code":"m_values <- c(200, 500, 1000, 2000) cat(\"SAC sensitivity to M_per_iter (target = 0.80, 300 iter):\\n\") #> SAC sensitivity to M_per_iter (target = 0.80, 300 iter): cat(sprintf(\"  %-12s %-10s %-12s %-10s\\n\",             \"M_per_iter\", \"c*\", \"Post-burn SD\", \"Converged\")) #>   M_per_iter   c*         Post-burn SD Converged  for (m_val in m_values) {   sac_m <- sac_calibrate(     target_rho = 0.80, n_items = 25, model = \"rasch\",     item_source = \"parametric\", reliability_metric = \"info\",     c_init = eqc_for_init, n_iter = 300L,     M_per_iter = as.integer(m_val),     seed = 42, verbose = FALSE   )   cat(sprintf(\"  %-12d %-10.4f %-12.4f %-10s\\n\",               m_val, sac_m$c_star,               sac_m$convergence$sd_post_burn,               sac_m$convergence$converged)) } #>   200          0.9115     0.0005       TRUE       #>   500          0.9115     0.0004       TRUE       #>   1000         0.9122     0.0007       TRUE       #>   2000         0.9127     0.0005       TRUE"},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-sac.html","id":"deprecated-alias","dir":"Articles","previous_headings":"","what":"Deprecated Alias","title":"Algorithm 2: Stochastic Approximation Calibration (SAC)","text":"function previously named spc_calibrate(). backward compatibility, spc_calibrate() still works deprecated emit warning. Use sac_calibrate() new code. Similarly, compare_eqc_spc() deprecated favor compare_eqc_sac().","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-sac.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Algorithm 2: Stochastic Approximation Calibration (SAC)","text":"SAC theoretically grounded validation companion EQC:","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/algorithm-sac.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Algorithm 2: Stochastic Approximation Calibration (SAC)","text":"Lee, J. (2025). Reliability-targeted simulation item response data: Solving inverse design problem. arXiv preprint arXiv:2512.16012. Robbins, H., & Monro, S. (1951). stochastic approximation method. Annals Mathematical Statistics, 22(3), 400‚Äì407. Polyak, B. T., & Juditsky, . B. (1992). Acceleration stochastic approximation averaging. SIAM Journal Control Optimization, 30(4), 838‚Äì855. Kushner, H. J., & Yin, G. G. (2003). Stochastic Approximation Recursive Algorithms Applications (2nd ed.). Springer. Spall, J. C. (2003). Introduction Stochastic Search Optimization. Wiley.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Complete API Reference with Examples","text":"vignette provides comprehensive reference every exported function IRTsimrel v0.2.0. Functions organized five categories: Calibration Functions ‚Äì core algorithms reliability-targeted simulation (eqc_calibrate, sac_calibrate, compare_eqc_sac). Simulation Functions ‚Äì Generators latent abilities, item parameters, response data (sim_latentG, sim_item_params, simulate_response_data, compare_shapes). Reliability Functions ‚Äì Low-level utilities computing exploring reliability (compute_rho_bar, compute_rho_tilde, compute_rho_both, compute_apc_init, check_feasibility, rho_curve, compute_reliability_tam). S3 Methods ‚Äì Print, summary, plot, coef, predict, coercion methods object classes. Deprecated Functions ‚Äì Legacy aliases retained backward compatibility (spc_calibrate, compare_eqc_spc). conceptual introductions, see vignette(\"introduction\"). applied workflow guidance, see vignette(\"applied-guide\"). mathematical theory, see vignette(\"theory-reliability\"). Citation: Lee, J. (2025). Reliability-targeted simulation item response data: Solving inverse design problem. arXiv preprint arXiv:2512.16012.","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"eqc-calibrate","dir":"Articles","previous_headings":"1. Calibration Functions","what":"1.1 eqc_calibrate() ‚Äì Empirical Quadrature Calibration","title":"Complete API Reference with Examples","text":"Implements Algorithm 1 (EQC/SQC) Lee (2025). Given target marginal reliability, EQC draws large fixed quadrature sample abilities item parameters, solves scalar root-finding problem via Brent‚Äôs method (uniroot()). recommended starting point simulation studies.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"signature","dir":"Articles","previous_headings":"1. Calibration Functions > 1.1 eqc_calibrate() ‚Äì Empirical Quadrature Calibration","what":"Signature","title":"Complete API Reference with Examples","text":"","code":"eqc_calibrate(   target_rho,   n_items,   model             = c(\"rasch\", \"2pl\"),   latent_shape      = \"normal\",   item_source       = \"parametric\",   latent_params     = list(),   item_params       = list(),   reliability_metric = c(\"info\", \"tilde\", \"msem\", \"bar\"),   M                 = 10000L,   c_bounds          = c(0.3, 3),   tol               = 1e-4,   seed              = NULL,   verbose           = FALSE )"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"return-value","dir":"Articles","previous_headings":"1. Calibration Functions > 1.1 eqc_calibrate() ‚Äì Empirical Quadrature Calibration","what":"Return Value","title":"Complete API Reference with Examples","text":"object class \"eqc_result\" (list) elements:","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"examples","dir":"Articles","previous_headings":"1. Calibration Functions > 1.1 eqc_calibrate() ‚Äì Empirical Quadrature Calibration","what":"Examples","title":"Complete API Reference with Examples","text":"See vignette(\"algorithm-eqc\") detailed walk-.","code":"# Rasch model with 25 items targeting rho = 0.80 eqc_res <- eqc_calibrate(   target_rho = 0.80,   n_items    = 25,   model      = \"rasch\",   M          = 5000L,   seed       = 42 ) eqc_res #>  #> ======================================================= #>   Empirical Quadrature Calibration (EQC) Results #> ======================================================= #>  #> Calibration Summary: #>   Model                        : RASCH #>   Target reliability (rho*)    : 0.8000 #>   Achieved reliability         : 0.8000 #>   Absolute error               : 1.19e-07 #>   Scaling factor (c*)          : 0.8995 #>  #> Design Parameters: #>   Number of items (I)          : 25 #>   Quadrature points (M)        : 5000 #>   Reliability metric           : Average-information (tilde) #>   Latent variance              : 1.0099 #>  #> Convergence: #>   Root status                  : uniroot_success #>   Search bracket               : [0.300, 3.000] #>   Bracket reliabilities        : [0.3539, 0.9550] #>  #> Parameter Summaries: #>   theta:        mean = -0.014, sd = 1.005 #>   beta:         mean = 0.000, sd = 0.861, range = [-2.17, 1.45] #>   lambda_base:  mean = 1.000, sd = 0.000 #>   lambda_scaled: mean = 0.899, sd = 0.000 # 2PL model with bimodal latent distribution eqc_2pl <- eqc_calibrate(   target_rho   = 0.85,   n_items      = 30,   model        = \"2pl\",   latent_shape = \"bimodal\",   M            = 5000L,   seed         = 42 ) cat(sprintf(\"c* = %.4f, achieved rho = %.4f\\n\",             eqc_2pl$c_star, eqc_2pl$achieved_rho)) #> c* = 1.0072, achieved rho = 0.8500"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"sac-calibrate","dir":"Articles","previous_headings":"1. Calibration Functions","what":"1.2 sac_calibrate() ‚Äì Stochastic Approximation Calibration","title":"Complete API Reference with Examples","text":"Implements Algorithm 2 (SAC) Lee (2025). Uses Robbins‚ÄìMonro stochastic approximation framework Polyak‚ÄìRuppert averaging. SAC provides independent validation EQC can target exact MSEM-based marginal reliability.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"signature-1","dir":"Articles","previous_headings":"1. Calibration Functions > 1.2 sac_calibrate() ‚Äì Stochastic Approximation Calibration","what":"Signature","title":"Complete API Reference with Examples","text":"","code":"sac_calibrate(   target_rho,   n_items,   model              = c(\"rasch\", \"2pl\"),   latent_shape       = \"normal\",   item_source        = \"parametric\",   latent_params      = list(),   item_params        = list(),   reliability_metric = c(\"msem\", \"info\", \"bar\", \"tilde\"),   c_init             = NULL,   M_per_iter         = 500L,   M_pre              = 10000L,   n_iter             = 300L,   burn_in            = NULL,   step_params        = list(),   c_bounds           = c(0.01, 20),   resample_items     = TRUE,   seed               = NULL,   verbose            = FALSE )"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"return-value-1","dir":"Articles","previous_headings":"1. Calibration Functions > 1.2 sac_calibrate() ‚Äì Stochastic Approximation Calibration","what":"Return Value","title":"Complete API Reference with Examples","text":"object class \"sac_result\" (list) elements:","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"examples-1","dir":"Articles","previous_headings":"1. Calibration Functions > 1.2 sac_calibrate() ‚Äì Stochastic Approximation Calibration","what":"Examples","title":"Complete API Reference with Examples","text":"See vignette(\"algorithm-sac\") convergence tuning details.","code":"# SAC with APC initialization (default) sac_res <- sac_calibrate(   target_rho = 0.80,   n_items    = 25,   model      = \"rasch\",   n_iter     = 200L,   M_per_iter = 500L,   M_pre      = 5000L,   seed       = 42,   verbose    = FALSE ) cat(sprintf(\"SAC c* = %.4f, achieved rho = %.4f\\n\",             sac_res$c_star, sac_res$achieved_rho)) #> SAC c* = 1.0504, achieved rho = 0.8292 # Warm start from EQC result (recommended workflow) sac_warm <- sac_calibrate(   target_rho = 0.80,   n_items    = 25,   model      = \"rasch\",   c_init     = eqc_res,   n_iter     = 100L,   M_per_iter = 500L,   M_pre      = 5000L,   seed       = 42,   verbose    = FALSE ) cat(sprintf(\"EQC c* = %.4f, SAC c* = %.4f\\n\",             eqc_res$c_star, sac_warm$c_star)) #> EQC c* = 0.8995, SAC c* = 0.9232"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"compare-eqc-sac","dir":"Articles","previous_headings":"1. Calibration Functions","what":"1.3 compare_eqc_sac() ‚Äì Compare Calibration Results","title":"Complete API Reference with Examples","text":"Computes agreement diagnostics EQC SAC calibration results targeting reliability.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"signature-2","dir":"Articles","previous_headings":"1. Calibration Functions > 1.3 compare_eqc_sac() ‚Äì Compare Calibration Results","what":"Signature","title":"Complete API Reference with Examples","text":"","code":"compare_eqc_sac(eqc_result, sac_result, verbose = TRUE)"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"return-value-2","dir":"Articles","previous_headings":"1. Calibration Functions > 1.3 compare_eqc_sac() ‚Äì Compare Calibration Results","what":"Return Value","title":"Complete API Reference with Examples","text":"list (returned invisibly) components:","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"examples-2","dir":"Articles","previous_headings":"1. Calibration Functions > 1.3 compare_eqc_sac() ‚Äì Compare Calibration Results","what":"Examples","title":"Complete API Reference with Examples","text":"","code":"# Compare results from the two algorithms comp <- compare_eqc_sac(eqc_res, sac_warm, verbose = TRUE) #> Warning in compare_eqc_sac(eqc_res, sac_warm, verbose = TRUE): Reliability #> metric differs between EQC ('info') and SAC ('msem'). #>  #> ======================================================= #>   EQC vs SAC Comparison #> ======================================================= #>  #>   Target reliability  : 0.8000 #>   EQC c*              : 0.899499 #>   SAC c*              : 0.923198 #>   Absolute difference : 0.023698 #>   Percent difference  : 2.63% #>   Agreement (< 5%)    : YES #>  cat(sprintf(\"Agreement: %s (%.2f%% difference)\\n\",             ifelse(comp$agreement, \"YES\", \"NO\"), comp$diff_pct)) #> Agreement: YES (2.63% difference)"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"sim-latentg","dir":"Articles","previous_headings":"2. Simulation Functions","what":"2.1 sim_latentG() ‚Äì Simulate Latent Ability Distributions","title":"Complete API Reference with Examples","text":"Generates latent abilities flexible family pre-standardized distributions. built-shape mathematically constructed mean 0 variance 1, changes distributional shape alter scale.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"signature-3","dir":"Articles","previous_headings":"2. Simulation Functions > 2.1 sim_latentG() ‚Äì Simulate Latent Ability Distributions","what":"Signature","title":"Complete API Reference with Examples","text":"","code":"sim_latentG(   n,   shape              = c(\"normal\", \"bimodal\", \"trimodal\", \"multimodal\",                           \"skew_pos\", \"skew_neg\", \"heavy_tail\",                           \"light_tail\", \"uniform\", \"floor\", \"ceiling\",                           \"custom\"),   sigma              = 1,   mu                 = 0,   xcov               = NULL,   beta               = NULL,   shape_params       = list(),   mixture_spec       = NULL,   standardize_custom = TRUE,   seed               = NULL,   return_z           = TRUE )"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"parameters-3","dir":"Articles","previous_headings":"2. Simulation Functions > 2.1 sim_latentG() ‚Äì Simulate Latent Ability Distributions","what":"Parameters","title":"Complete API Reference with Examples","text":"Available shapes:","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"return-value-3","dir":"Articles","previous_headings":"2. Simulation Functions > 2.1 sim_latentG() ‚Äì Simulate Latent Ability Distributions","what":"Return Value","title":"Complete API Reference with Examples","text":"object class \"latent_G\" (list) elements:","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"examples-3","dir":"Articles","previous_headings":"2. Simulation Functions > 2.1 sim_latentG() ‚Äì Simulate Latent Ability Distributions","what":"Examples","title":"Complete API Reference with Examples","text":"See vignette(\"latent-distributions\") detailed shape comparisons.","code":"# Standard normal abilities g_norm <- sim_latentG(n = 2000, shape = \"normal\", seed = 42) cat(sprintf(\"Mean = %.3f, SD = %.3f, Skew = %.3f, Kurt = %.3f\\n\",             g_norm$sample_moments$mean,             g_norm$sample_moments$sd,             g_norm$sample_moments$skewness,             g_norm$sample_moments$kurtosis)) #> Mean = -0.016, SD = 0.994, Skew = 0.013, Kurt = 0.056 # Bimodal distribution with strong separation g_bimod <- sim_latentG(   n            = 2000,   shape        = \"bimodal\",   shape_params = list(delta = 0.9),   seed         = 42 ) cat(sprintf(\"Bimodal: Mean = %.3f, SD = %.3f, Kurt = %.3f\\n\",             g_bimod$sample_moments$mean,             g_bimod$sample_moments$sd,             g_bimod$sample_moments$kurtosis)) #> Bimodal: Mean = -0.017, SD = 0.989, Kurt = -1.298 # Positively skewed distribution g_skew <- sim_latentG(   n            = 2000,   shape        = \"skew_pos\",   shape_params = list(k = 3),   seed         = 42 ) cat(sprintf(\"Skew_pos: Skewness = %.3f\\n\",             g_skew$sample_moments$skewness)) #> Skew_pos: Skewness = 1.152 # Custom three-component mixture g_custom <- sim_latentG(   n            = 2000,   shape        = \"custom\",   mixture_spec = list(     weights = c(0.3, 0.5, 0.2),     means   = c(-1.5, 0, 2),     sds     = c(0.5, 0.7, 0.5)   ),   seed = 42 ) cat(sprintf(\"Custom: Mean = %.3f, SD = %.3f\\n\",             g_custom$sample_moments$mean,             g_custom$sample_moments$sd)) #> Custom: Mean = 0.011, SD = 0.996"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"sim-item-params","dir":"Articles","previous_headings":"2. Simulation Functions","what":"2.2 sim_item_params() ‚Äì Simulate Item Parameters","title":"Complete API Reference with Examples","text":"Generates item difficulty discrimination parameters IRT models. Supports multiple sources (parametric, IRW, hierarchical, custom) methods inducing difficulty‚Äìdiscrimination correlation.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"signature-4","dir":"Articles","previous_headings":"2. Simulation Functions > 2.2 sim_item_params() ‚Äì Simulate Item Parameters","what":"Signature","title":"Complete API Reference with Examples","text":"","code":"sim_item_params(   n_items,   model                 = c(\"rasch\", \"2pl\"),   source                = c(\"irw\", \"parametric\", \"hierarchical\", \"custom\"),   method                = c(\"copula\", \"conditional\", \"independent\"),   n_forms               = 1L,   difficulty_params     = list(),   discrimination_params = list(),   hierarchical_params   = list(),   custom_params         = list(),   scale                 = 1,   center_difficulties   = TRUE,   seed                  = NULL )"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"return-value-4","dir":"Articles","previous_headings":"2. Simulation Functions > 2.2 sim_item_params() ‚Äì Simulate Item Parameters","what":"Return Value","title":"Complete API Reference with Examples","text":"object class \"item_params\" (list) elements:","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"examples-4","dir":"Articles","previous_headings":"2. Simulation Functions > 2.2 sim_item_params() ‚Äì Simulate Item Parameters","what":"Examples","title":"Complete API Reference with Examples","text":"See vignette(\"item-parameters\") complete discussion sources methods.","code":"# Rasch items with parametric difficulties items_rasch <- sim_item_params(   n_items = 25,   model   = \"rasch\",   source  = \"parametric\",   seed    = 42 ) items_rasch #> Item Parameters Object #> ====================== #>   Model          : RASCH #>   Source         : parametric #>   Items per form : 25 #>   Number of forms: 1 #>   Scale factor   : 1.000 #>   Centered       : Yes #>  #> Difficulty (beta): #>   Mean: 0.0000, SD: 1.3064, Range: [-2.844, 2.099] # 2PL items with copula-induced correlation items_2pl <- sim_item_params(   n_items               = 30,   model                 = \"2pl\",   source                = \"parametric\",   method                = \"copula\",   discrimination_params = list(rho = -0.3, mu_log = 0, sigma_log = 0.3),   seed                  = 42 ) cat(sprintf(\"Achieved Spearman r(beta, log-lambda) = %.3f\\n\",             items_2pl$achieved$overall$cor_spearman_pooled)) #> Achieved Spearman r(beta, log-lambda) = -0.378 # Hierarchical 2PL (Glas & van der Linden style) items_hier <- sim_item_params(   n_items              = 25,   model                = \"2pl\",   source               = \"hierarchical\",   hierarchical_params  = list(mu = c(0, 0), tau = c(0.25, 1), rho = -0.3),   seed                 = 42 ) head(as.data.frame(items_hier)) #>   form_id item_id       beta    lambda lambda_unscaled #> 1       1       1  1.1864454 0.9930935       0.9930935 #> 2       1       2 -0.7521311 1.1116693       1.1116693 #> 3       1       3  0.2039055 1.4755926       1.4755926 #> 4       1       4  0.4317000 0.8526922       0.8526922 #> 5       1       5  0.2238748 1.1270078       1.1270078 #> 6       1       6 -0.3070683 0.9052717       0.9052717 # Custom user-supplied parameters items_custom <- sim_item_params(   n_items       = 10,   model         = \"2pl\",   source        = \"custom\",   custom_params = list(     beta   = seq(-2, 2, length.out = 10),     lambda = rep(1.2, 10)   ),   seed = 42 ) #> Warning in cor(df$beta, log(df$lambda_unscaled)): the standard deviation is #> zero #> Warning in cor(df$beta, log(df$lambda_unscaled), method = \"spearman\"): the #> standard deviation is zero #> Warning in cor(data$beta, log(data$lambda_unscaled)): the standard deviation is #> zero #> Warning in cor(data$beta, log(data$lambda_unscaled), method = \"spearman\"): the #> standard deviation is zero head(as.data.frame(items_custom)) #>   form_id item_id       beta lambda lambda_unscaled #> 1       1       1 -2.0000000    1.2             1.2 #> 2       1       2 -1.5555556    1.2             1.2 #> 3       1       3 -1.1111111    1.2             1.2 #> 4       1       4 -0.6666667    1.2             1.2 #> 5       1       5 -0.2222222    1.2             1.2 #> 6       1       6  0.2222222    1.2             1.2"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"simulate-response-data","dir":"Articles","previous_headings":"2. Simulation Functions","what":"2.3 simulate_response_data() ‚Äì Generate Response Matrices","title":"Complete API Reference with Examples","text":"Simulates binary (0/1) item response data using calibrated parameters eqc_calibrate() sac_calibrate(). final step external validation (e.g., TAM).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"signature-5","dir":"Articles","previous_headings":"2. Simulation Functions > 2.3 simulate_response_data() ‚Äì Generate Response Matrices","what":"Signature","title":"Complete API Reference with Examples","text":"","code":"simulate_response_data(   result,   n_persons,   latent_shape  = \"normal\",   latent_params = list(),   seed          = NULL )"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"return-value-5","dir":"Articles","previous_headings":"2. Simulation Functions > 2.3 simulate_response_data() ‚Äì Generate Response Matrices","what":"Return Value","title":"Complete API Reference with Examples","text":"list components:","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"examples-5","dir":"Articles","previous_headings":"2. Simulation Functions > 2.3 simulate_response_data() ‚Äì Generate Response Matrices","what":"Examples","title":"Complete API Reference with Examples","text":"","code":"# Generate 500 examinees from EQC calibration sim_data <- simulate_response_data(   result    = eqc_res,   n_persons = 500,   seed      = 123 ) cat(sprintf(\"Response matrix: %d persons x %d items\\n\",             nrow(sim_data$response_matrix),             ncol(sim_data$response_matrix))) #> Response matrix: 500 persons x 25 items cat(sprintf(\"Mean proportion correct: %.3f\\n\",             mean(sim_data$response_matrix))) #> Mean proportion correct: 0.502 # Generate from SAC result with skewed abilities sim_data2 <- simulate_response_data(   result       = sac_warm,   n_persons    = 500,   latent_shape = \"skew_pos\",   seed         = 123 ) cat(sprintf(\"Theta skewness: %.3f\\n\",             mean(((sim_data2$theta - mean(sim_data2$theta)) /                     sd(sim_data2$theta))^3))) #> Theta skewness: 0.906"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"compare-shapes","dir":"Articles","previous_headings":"2. Simulation Functions","what":"2.4 compare_shapes() ‚Äì Compare Distribution Shapes","title":"Complete API Reference with Examples","text":"Generates compares multiple latent distributions side--side using faceted density plots. Requires ggplot2 package.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"signature-6","dir":"Articles","previous_headings":"2. Simulation Functions > 2.4 compare_shapes() ‚Äì Compare Distribution Shapes","what":"Signature","title":"Complete API Reference with Examples","text":"","code":"compare_shapes(   n      = 2000,   shapes = c(\"normal\", \"bimodal\", \"trimodal\",              \"skew_pos\", \"skew_neg\", \"heavy_tail\",              \"uniform\"),   sigma  = 1,   seed   = NULL )"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"return-value-6","dir":"Articles","previous_headings":"2. Simulation Functions > 2.4 compare_shapes() ‚Äì Compare Distribution Shapes","what":"Return Value","title":"Complete API Reference with Examples","text":"ggplot object faceted density plots, one panel per shape. dashed red line shows N(0, 1) reference density.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"example","dir":"Articles","previous_headings":"2. Simulation Functions > 2.4 compare_shapes() ‚Äì Compare Distribution Shapes","what":"Example","title":"Complete API Reference with Examples","text":"Comparison latent distribution shapes. See vignette(\"latent-distributions\") extended shape comparisons.","code":"p <- compare_shapes(   n      = 2000,   shapes = c(\"normal\", \"bimodal\", \"skew_pos\", \"heavy_tail\"),   seed   = 42 ) print(p)"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"compute-rho-bar","dir":"Articles","previous_headings":"3. Reliability Functions","what":"3.1 compute_rho_bar() ‚Äì MSEM-Based Marginal Reliability","title":"Complete API Reference with Examples","text":"Computes MSEM-based marginal reliability using harmonic mean test information.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"signature-7","dir":"Articles","previous_headings":"3. Reliability Functions > 3.1 compute_rho_bar() ‚Äì MSEM-Based Marginal Reliability","what":"Signature","title":"Complete API Reference with Examples","text":"","code":"compute_rho_bar(c, theta_vec, beta_vec, lambda_base, theta_var = NULL)"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"return-value-7","dir":"Articles","previous_headings":"3. Reliability Functions > 3.1 compute_rho_bar() ‚Äì MSEM-Based Marginal Reliability","what":"Return Value","title":"Complete API Reference with Examples","text":"numeric scalar: MSEM-based reliability.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"example-1","dir":"Articles","previous_headings":"3. Reliability Functions > 3.1 compute_rho_bar() ‚Äì MSEM-Based Marginal Reliability","what":"Example","title":"Complete API Reference with Examples","text":"","code":"set.seed(1) theta <- rnorm(2000) beta  <- rnorm(20) lambda0 <- rep(1, 20)  rho_bar_val <- compute_rho_bar(c = 1.0, theta, beta, lambda0) cat(sprintf(\"rho_bar at c=1: %.4f\\n\", rho_bar_val)) #> rho_bar at c=1: 0.7856"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"compute-rho-tilde","dir":"Articles","previous_headings":"3. Reliability Functions","what":"3.2 compute_rho_tilde() ‚Äì Average-Information Reliability","title":"Complete API Reference with Examples","text":"Computes average-information reliability using arithmetic mean test information. Guaranteed monotone c, making recommended metric EQC.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"signature-8","dir":"Articles","previous_headings":"3. Reliability Functions > 3.2 compute_rho_tilde() ‚Äì Average-Information Reliability","what":"Signature","title":"Complete API Reference with Examples","text":"Parameters return value identical compute_rho_bar() ; internal formula differs.","code":"compute_rho_tilde(c, theta_vec, beta_vec, lambda_base, theta_var = NULL)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"example-2","dir":"Articles","previous_headings":"3. Reliability Functions > 3.2 compute_rho_tilde() ‚Äì Average-Information Reliability","what":"Example","title":"Complete API Reference with Examples","text":"","code":"rho_tilde_val <- compute_rho_tilde(c = 1.0, theta, beta, lambda0) cat(sprintf(\"rho_tilde at c=1: %.4f\\n\", rho_tilde_val)) #> rho_tilde at c=1: 0.7931  # Jensen's inequality: rho_tilde >= rho_bar cat(sprintf(\"rho_tilde >= rho_bar: %s\\n\",             ifelse(rho_tilde_val >= rho_bar_val, \"TRUE\", \"FALSE\"))) #> rho_tilde >= rho_bar: TRUE"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"compute-rho-both","dir":"Articles","previous_headings":"3. Reliability Functions","what":"3.3 compute_rho_both() ‚Äì Both Metrics in a Single Pass","title":"Complete API Reference with Examples","text":"Computes reliability metrics single set matrix computations, avoiding redundant M x operations.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"signature-9","dir":"Articles","previous_headings":"3. Reliability Functions > 3.3 compute_rho_both() ‚Äì Both Metrics in a Single Pass","what":"Signature","title":"Complete API Reference with Examples","text":"Parameters identical compute_rho_bar(). return value named list.","code":"compute_rho_both(c, theta_vec, beta_vec, lambda_base, theta_var = NULL)"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"example-3","dir":"Articles","previous_headings":"3. Reliability Functions > 3.3 compute_rho_both() ‚Äì Both Metrics in a Single Pass","what":"Example","title":"Complete API Reference with Examples","text":"","code":"both <- compute_rho_both(c = 1.0, theta, beta, lambda0) cat(sprintf(\"rho_tilde = %.4f, rho_bar = %.4f, gap = %.4f\\n\",             both$rho_tilde, both$rho_bar,             both$rho_tilde - both$rho_bar)) #> rho_tilde = 0.7931, rho_bar = 0.7856, gap = 0.0075"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"compute-apc-init","dir":"Articles","previous_headings":"3. Reliability Functions","what":"3.4 compute_apc_init() ‚Äì Analytic Pre-Calibration","title":"Complete API Reference with Examples","text":"Computes initial scaling factor using closed-form approximation Gaussian Rasch assumptions. Used internally sac_calibrate() c_init = NULL.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"signature-10","dir":"Articles","previous_headings":"3. Reliability Functions > 3.4 compute_apc_init() ‚Äì Analytic Pre-Calibration","what":"Signature","title":"Complete API Reference with Examples","text":"","code":"compute_apc_init(target_rho, n_items, sigma_beta = 1.0)"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"return-value-9","dir":"Articles","previous_headings":"3. Reliability Functions > 3.4 compute_apc_init() ‚Äì Analytic Pre-Calibration","what":"Return Value","title":"Complete API Reference with Examples","text":"numeric scalar: initial scaling factor (bounded [0.1, 10]).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"example-4","dir":"Articles","previous_headings":"3. Reliability Functions > 3.4 compute_apc_init() ‚Äì Analytic Pre-Calibration","what":"Example","title":"Complete API Reference with Examples","text":"","code":"# Compare APC estimates across test lengths for (I in c(10, 20, 30, 50)) {   c0 <- compute_apc_init(target_rho = 0.80, n_items = I)   cat(sprintf(\"  I = %2d: c_init = %.4f\\n\", I, c0)) } #>   I = 10: c_init = 2.0988 #>   I = 20: c_init = 1.4841 #>   I = 30: c_init = 1.2117 #>   I = 50: c_init = 0.9386"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"check-feasibility","dir":"Articles","previous_headings":"3. Reliability Functions","what":"3.5 check_feasibility() ‚Äì Feasibility Screening","title":"Complete API Reference with Examples","text":"Screens whether target reliability achievable given test design computing range reliabilities across range scaling factors. Run calibration avoid wasting time infeasible targets.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"signature-11","dir":"Articles","previous_headings":"3. Reliability Functions > 3.5 check_feasibility() ‚Äì Feasibility Screening","what":"Signature","title":"Complete API Reference with Examples","text":"","code":"check_feasibility(   n_items,   model         = c(\"rasch\", \"2pl\"),   latent_shape  = \"normal\",   item_source   = \"parametric\",   c_bounds      = c(0.1, 10),   M             = 10000L,   seed          = NULL,   latent_params = list(),   item_params   = list(),   verbose       = TRUE )"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"return-value-10","dir":"Articles","previous_headings":"3. Reliability Functions > 3.5 check_feasibility() ‚Äì Feasibility Screening","what":"Return Value","title":"Complete API Reference with Examples","text":"object class \"feasibility_check\" (returned invisibly) :","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"example-5","dir":"Articles","previous_headings":"3. Reliability Functions > 3.5 check_feasibility() ‚Äì Feasibility Screening","what":"Example","title":"Complete API Reference with Examples","text":"","code":"feas <- check_feasibility(   n_items = 25,   model   = \"rasch\",   M       = 5000L,   seed    = 42,   verbose = FALSE ) cat(sprintf(\"rho_tilde range: [%.4f, %.4f]\\n\",             feas$rho_range_info[1], feas$rho_range_info[2])) #> rho_tilde range: [0.0591, 0.9872] cat(sprintf(\"rho_bar range:   [%.4f, %.4f]\\n\",             feas$rho_range_msem[1], feas$rho_range_msem[2])) #> rho_bar range:   [0.0002, 0.9146]  # Is rho = 0.85 achievable with rho_tilde? cat(sprintf(\"rho=0.85 feasible (info): %s\\n\",             0.85 >= feas$rho_range_info[1] && 0.85 <= feas$rho_range_info[2])) #> rho=0.85 feasible (info): TRUE"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"rho-curve","dir":"Articles","previous_headings":"3. Reliability Functions","what":"3.6 rho_curve() ‚Äì Reliability as a Function of Scaling Factor","title":"Complete API Reference with Examples","text":"Computes optionally plots reliability curve across grid scaling factor values. Helps visualize relationship discrimination strength measurement precision.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"signature-12","dir":"Articles","previous_headings":"3. Reliability Functions > 3.6 rho_curve() ‚Äì Reliability as a Function of Scaling Factor","what":"Signature","title":"Complete API Reference with Examples","text":"","code":"rho_curve(   c_values      = seq(0.1, 5, length.out = 50),   n_items,   model         = c(\"rasch\", \"2pl\"),   latent_shape  = \"normal\",   item_source   = \"parametric\",   metric        = c(\"both\", \"info\", \"msem\"),   M             = 5000L,   seed          = NULL,   latent_params = list(),   item_params   = list(),   plot          = TRUE )"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"return-value-11","dir":"Articles","previous_headings":"3. Reliability Functions > 3.6 rho_curve() ‚Äì Reliability as a Function of Scaling Factor","what":"Return Value","title":"Complete API Reference with Examples","text":"data frame class \"rho_curve\" (returned invisibly plot = TRUE) columns c, rho_tilde, /rho_bar depending metric argument.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"example-6","dir":"Articles","previous_headings":"3. Reliability Functions > 3.6 rho_curve() ‚Äì Reliability as a Function of Scaling Factor","what":"Example","title":"Complete API Reference with Examples","text":"Reliability curve 25-item Rasch test.","code":"curve_data <- rho_curve(   c_values = seq(0.2, 4, length.out = 40),   n_items  = 25,   model    = \"rasch\",   metric   = \"both\",   M        = 5000L,   seed     = 42,   plot     = TRUE ) # Inspect the data head(curve_data) #> Reliability Curve #> ================= #>   Items: 25 | Model: RASCH | Metric: both #>   c range: [0.20, 0.69] (6 points) #>   rho_tilde range: [0.1989, 0.7174] #>   rho_bar range  : [0.1989, 0.7139] #>  #>           c rho_tilde   rho_bar #> 1 0.2000000 0.1988965 0.1988657 #> 2 0.2974359 0.3500759 0.3498742 #> 3 0.3948718 0.4807284 0.4800963 #> 4 0.4923077 0.5827614 0.5814095 #> 5 0.5897436 0.6596796 0.6573608 #> 6 0.6871795 0.7174113 0.7139425"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"compute-reliability-tam","dir":"Articles","previous_headings":"3. Reliability Functions","what":"3.7 compute_reliability_tam() ‚Äì TAM-Based Validation","title":"Complete API Reference with Examples","text":"Fits Rasch 2PL model using TAM package returns WLE EAP reliability estimates. function requires TAM package installed.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"signature-13","dir":"Articles","previous_headings":"3. Reliability Functions > 3.7 compute_reliability_tam() ‚Äì TAM-Based Validation","what":"Signature","title":"Complete API Reference with Examples","text":"","code":"compute_reliability_tam(resp, model = c(\"rasch\", \"2pl\"), verbose = FALSE, ...)"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"return-value-12","dir":"Articles","previous_headings":"3. Reliability Functions > 3.7 compute_reliability_tam() ‚Äì TAM-Based Validation","what":"Return Value","title":"Complete API Reference with Examples","text":"list components:","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"example-7","dir":"Articles","previous_headings":"3. Reliability Functions > 3.7 compute_reliability_tam() ‚Äì TAM-Based Validation","what":"Example","title":"Complete API Reference with Examples","text":"See vignette(\"validation\") complete validation workflow.","code":"# Requires TAM package tam_rel <- compute_reliability_tam(   resp    = sim_data$response_matrix,   model   = \"rasch\",   verbose = FALSE ) cat(sprintf(\"WLE reliability: %.4f\\n\", tam_rel$rel_wle)) cat(sprintf(\"EAP reliability: %.4f\\n\", tam_rel$rel_eap))"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"s3-methods","dir":"Articles","previous_headings":"","what":"4. S3 Methods","title":"Complete API Reference with Examples","text":"IRTsimrel defines S3 methods six object classes. section documents method signature brief example.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"methods-for-eqc_result-objects","dir":"Articles","previous_headings":"4. S3 Methods","what":"4.1 Methods for eqc_result Objects","title":"Complete API Reference with Examples","text":"Objects returned eqc_calibrate().","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"print-eqc_result","dir":"Articles","previous_headings":"4. S3 Methods > 4.1 Methods for eqc_result Objects","what":"print.eqc_result()","title":"Complete API Reference with Examples","text":"Displays calibration summary, design parameters, convergence diagnostics, parameter summaries. Returns x invisibly.","code":"print.eqc_result(x, digits = 4, ...) print(eqc_res) #>  #> ======================================================= #>   Empirical Quadrature Calibration (EQC) Results #> ======================================================= #>  #> Calibration Summary: #>   Model                        : RASCH #>   Target reliability (rho*)    : 0.8000 #>   Achieved reliability         : 0.8000 #>   Absolute error               : 1.19e-07 #>   Scaling factor (c*)          : 0.8995 #>  #> Design Parameters: #>   Number of items (I)          : 25 #>   Quadrature points (M)        : 5000 #>   Reliability metric           : Average-information (tilde) #>   Latent variance              : 1.0099 #>  #> Convergence: #>   Root status                  : uniroot_success #>   Search bracket               : [0.300, 3.000] #>   Bracket reliabilities        : [0.3539, 0.9550] #>  #> Parameter Summaries: #>   theta:        mean = -0.014, sd = 1.005 #>   beta:         mean = 0.000, sd = 0.861, range = [-2.17, 1.45] #>   lambda_base:  mean = 1.000, sd = 0.000 #>   lambda_scaled: mean = 0.899, sd = 0.000"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"summary-eqc_result","dir":"Articles","previous_headings":"4. S3 Methods > 4.1 Methods for eqc_result Objects","what":"summary.eqc_result()","title":"Complete API Reference with Examples","text":"Returns object class \"summary.eqc_result\" containing compact subset key results.","code":"summary.eqc_result(object, ...) s <- summary(eqc_res) s #> Summary: Empirical Quadrature Calibration (EQC) #> ================================================ #>   Model            : RASCH #>   Metric           : Average-information (tilde) #>   Number of items  : 25 #>   Quadrature (M)   : 5000 #>   Latent variance  : 1.0099 #>  #> Calibration Results: #>   Target rho*      : 0.8000 #>   Achieved rho     : 0.8000 #>   Absolute error   : 1.19e-07 #>   Scaling factor c*: 0.8995 #>   Root status      : uniroot_success"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"coef-eqc_result","dir":"Articles","previous_headings":"4. S3 Methods > 4.1 Methods for eqc_result Objects","what":"coef.eqc_result()","title":"Complete API Reference with Examples","text":"Returns data frame columns: item_id, beta, lambda_base, lambda_scaled, c_star.","code":"coef.eqc_result(object, ...) item_df <- coef(eqc_res) head(item_df) #>   item_id         beta lambda_base lambda_scaled    c_star #> 1       1  0.197732269           1     0.8994993 0.8994993 #> 2       2  1.096799859           1     0.8994993 0.8994993 #> 3       3  0.436545084           1     0.8994993 0.8994993 #> 4       4 -0.013038730           1     0.8994993 0.8994993 #> 5       5 -0.199801302           1     0.8994993 0.8994993 #> 6       6  0.007700326           1     0.8994993 0.8994993"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"predict-eqc_result","dir":"Articles","previous_headings":"4. S3 Methods > 4.1 Methods for eqc_result Objects","what":"predict.eqc_result()","title":"Complete API Reference with Examples","text":"newdata NULL, returns achieved_rho. newdata numeric vector scaling factor values, computes reliability value using stored quadrature sample.","code":"predict.eqc_result(object, newdata = NULL, ...) # Achieved reliability predict(eqc_res) #> [1] 0.8000001  # Reliability at several scaling factors predict(eqc_res, newdata = c(0.5, 1.0, 1.5, 2.0)) #>     c=0.5     c=1.0     c=1.5     c=2.0  #> 0.5896711 0.8259511 0.8972175 0.9280310"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"methods-for-sac_result-objects","dir":"Articles","previous_headings":"4. S3 Methods","what":"4.2 Methods for sac_result Objects","title":"Complete API Reference with Examples","text":"Objects returned sac_calibrate().","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"print-sac_result","dir":"Articles","previous_headings":"4. S3 Methods > 4.2 Methods for sac_result Objects","what":"print.sac_result()","title":"Complete API Reference with Examples","text":"Displays calibration summary, algorithm settings, convergence diagnostics.","code":"print.sac_result(x, digits = 4, ...) print(sac_res) #>  #> ======================================================= #>   Stochastic Approximation Calibration (SAC) Results #> ======================================================= #>  #> Calibration Summary: #>   Model                        : RASCH #>   Target reliability (rho*)    : 0.8000 #>   Achieved reliability         : 0.8292 #>   Absolute error               : 2.92e-02 #>   Scaling factor (c*)          : 1.0504 #>  #> Algorithm Settings: #>   Number of items (I)          : 25 #>   M per iteration              : 500 #>   M for variance pre-calc      : 5000 #>   Total iterations             : 200 #>   Burn-in                      : 100 #>   Reliability metric           : MSEM-based (bar/w) #>   Step params: a=1.00, A=50, gamma=0.67 #>  #> Convergence Diagnostics: #>   Initialization method        : apc_warm_start #>   Initial c_0                  : 1.3274 #>   Final iterate c_n            : 1.0195 #>   Polyak-Ruppert c*            : 1.0504 #>   Pre-calculated theta_var     : 1.0099 #>   Converged                    : Yes #>   Post-burn-in SD              : 0.0210 #>   Final gradient (rho - rho*)  : +0.0194"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"summary-sac_result","dir":"Articles","previous_headings":"4. S3 Methods > 4.2 Methods for sac_result Objects","what":"summary.sac_result()","title":"Complete API Reference with Examples","text":"Returns \"summary.sac_result\" object compact results.","code":"summary.sac_result(object, ...) s_sac <- summary(sac_res) s_sac #> Summary: Stochastic Approximation Calibration (SAC) #> ==================================================== #>   Model            : RASCH #>   Metric           : MSEM-based (bar/w) #>   Number of items  : 25 #>   Iterations       : 200 #>   Burn-in          : 100 #>   M per iteration  : 500 #>   M pre-calc       : 5000 #>   Init method      : apc_warm_start #>  #> Calibration Results: #>   Target rho*      : 0.8000 #>   Achieved rho     : 0.8292 #>   Absolute error   : 2.92e-02 #>   Scaling factor c*: 1.0504 #>   Converged        : Yes #>   Post-burn-in SD  : 0.0210"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"coef-sac_result","dir":"Articles","previous_headings":"4. S3 Methods > 4.2 Methods for sac_result Objects","what":"coef.sac_result()","title":"Complete API Reference with Examples","text":"Returns data frame columns: item_id, beta, lambda_base, lambda_scaled, c_star.","code":"coef.sac_result(object, ...) head(coef(sac_res)) #>   item_id        beta lambda_base lambda_scaled  c_star #> 1       1  0.03774168           1       1.05045 1.05045 #> 2       2 -1.18785344           1       1.05045 1.05045 #> 3       3 -0.21413874           1       1.05045 1.05045 #> 4       4 -0.81661157           1       1.05045 1.05045 #> 5       5  1.52992507           1       1.05045 1.05045 #> 6       6 -0.38999393           1       1.05045 1.05045"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"predict-sac_result","dir":"Articles","previous_headings":"4. S3 Methods > 4.2 Methods for sac_result Objects","what":"predict.sac_result()","title":"Complete API Reference with Examples","text":"Like predict.eqc_result(), accepts optional theta_vec argument using different ability sample.","code":"predict.sac_result(object, newdata = NULL, theta_vec = NULL, ...) predict(sac_res) #> [1] 0.8291582 predict(sac_res, newdata = c(0.5, 1.0, 1.5)) #>     c=0.5     c=1.0     c=1.5  #> 0.5886405 0.8189501 0.8833365"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"plot-sac_result","dir":"Articles","previous_headings":"4. S3 Methods > 4.2 Methods for sac_result Objects","what":"plot.sac_result()","title":"Complete API Reference with Examples","text":"Plots Robbins‚ÄìMonro convergence trajectory. Types \"trajectory\" \"c\" synonyms showing scaling factor path. Type \"rho\" shows reliability estimates across iterations. Type \"\" combines . Uses ggplot2 available, falling back base R graphics. SAC convergence trajectory (scaling factor). SAC reliability estimates across iterations.","code":"plot.sac_result(x, type = c(\"both\", \"trajectory\", \"c\", \"rho\"), ...) plot(sac_res, type = \"c\") plot(sac_res, type = \"rho\")"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"methods-for-latent_g-objects","dir":"Articles","previous_headings":"4. S3 Methods","what":"4.3 Methods for latent_G Objects","title":"Complete API Reference with Examples","text":"Objects returned sim_latentG().","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"print-latent_g","dir":"Articles","previous_headings":"4. S3 Methods > 4.3 Methods for latent_G Objects","what":"print.latent_G()","title":"Complete API Reference with Examples","text":"Prints shape, sample size, target parameters, sample moments.","code":"print.latent_G(x, ...) print(g_bimod) #> Latent Ability Distribution (G-family) #> ======================================= #>   Shape     : bimodal #>   n         : 2000 #>   Target mu : 0.000 #>   Target sigma: 1.000 #>  #> Sample Moments: #>   Mean      : -0.0172 #>   SD        : 0.9885 #>   Skewness  : 0.0126 #>   Kurtosis  : -1.2981 (excess)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"summary-latent_g","dir":"Articles","previous_headings":"4. S3 Methods > 4.3 Methods for latent_G Objects","what":"summary.latent_G()","title":"Complete API Reference with Examples","text":"Returns \"summary.latent_G\" object detailed statistics including quantiles.","code":"summary.latent_G(object, ...) summary(g_bimod) #> Summary: Latent Ability Distribution #> ==================================== #>   Shape      : bimodal #>   n          : 2000 #>   Target     : mu = 0.00, sigma = 1.00 #>   Covariates : No #>  #> Sample Statistics: #>   Mean       : -0.0172 #>   SD         : 0.9885 #>   Median     : -0.0657 #>   Skewness   : 0.0126 #>   Kurtosis   : -1.2981 (excess) #>   Range      : [-2.2867, 2.4625] #>  #> Quantiles: #>    2.5%      5%     25%     50%     75%     95%   97.5%  #> -1.6338 -1.4650 -0.9025 -0.0657  0.8813  1.4319  1.5588"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"plot-latent_g","dir":"Articles","previous_headings":"4. S3 Methods > 4.3 Methods for latent_G Objects","what":"plot.latent_G()","title":"Complete API Reference with Examples","text":"Plots latent distribution histogram, density, . Uses ggplot2 available. Bimodal latent ability distribution.","code":"plot.latent_G(x, type = c(\"both\", \"histogram\", \"density\"),               show_normal = TRUE, bins = 50, ...) plot(g_bimod, type = \"both\", bins = 40)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"as-numeric-latent_g","dir":"Articles","previous_headings":"4. S3 Methods > 4.3 Methods for latent_G Objects","what":"as.numeric.latent_G()","title":"Complete API Reference with Examples","text":"Extracts theta vector use functions.","code":"as.numeric.latent_G(x, ...) # Extract theta vector directly (equivalent to as.numeric dispatch) theta_vec <- g_norm$theta cat(sprintf(\"Length: %d, Mean: %.3f\\n\", length(theta_vec), mean(theta_vec))) #> Length: 2000, Mean: -0.016"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"methods-for-item_params-objects","dir":"Articles","previous_headings":"4. S3 Methods","what":"4.4 Methods for item_params Objects","title":"Complete API Reference with Examples","text":"Objects returned sim_item_params().","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"print-item_params","dir":"Articles","previous_headings":"4. S3 Methods > 4.4 Methods for item_params Objects","what":"print.item_params()","title":"Complete API Reference with Examples","text":"Prints model, source, method, summary statistics difficulties discriminations, achieved correlations.","code":"print.item_params(x, ...) print(items_2pl) #> Item Parameters Object #> ====================== #>   Model          : 2PL #>   Source         : parametric #>   Method         : copula #>   Items per form : 30 #>   Number of forms: 1 #>   Scale factor   : 1.000 #>   Centered       : Yes #>  #> Difficulty (beta): #>   Mean: 0.0000, SD: 1.2550, Range: [-2.725, 2.218] #>  #> Discrimination (lambda, scaled): #>   Mean: 1.0867, SD: 0.2885, Range: [0.440, 1.731] #>  #> Correlation (beta, log-lambda): #>   Target (rho): -0.300 #>   Achieved Pearson : -0.361 #>   Achieved Spearman: -0.378"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"summary-item_params","dir":"Articles","previous_headings":"4. S3 Methods > 4.4 Methods for item_params Objects","what":"summary.item_params()","title":"Complete API Reference with Examples","text":"Returns \"summary.item_params\" object detailed parameter summaries.","code":"summary.item_params(object, ...) summary(items_2pl) #> Summary: Item Parameters #> ======================== #>   Model          : 2PL #>   Source         : parametric #>   Method         : copula #>   Items per form : 30 #>   Number of forms: 1 #>   Scale factor   : 1.000 #>   Centered       : Yes #>  #> Difficulty (beta): #>   Mean     : 0.0000 #>   SD       : 1.2550 #>   Min      : -2.7250 #>   Max      : 2.2181 #>   Quantiles: Q25=-0.4681, Q50=-0.1690, Q75=1.0014 #>  #> Discrimination (lambda): #>   Before scaling: Mean=1.0867, SD=0.2885 #>   After scaling (c=1.000): Mean=1.0867, SD=0.2885 #>   Range [0.4396, 1.7309] #>  #> Correlation (beta, log-lambda): #>   Target (rho)     : -0.3000 #>   Achieved Pearson : -0.3611 #>   Achieved Spearman: -0.3784"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"plot-item_params","dir":"Articles","previous_headings":"4. S3 Methods > 4.4 Methods for item_params Objects","what":"plot.item_params()","title":"Complete API Reference with Examples","text":"2PL models, creates difficulty vs.¬†discrimination scatter plots /density plots. Uses ggplot2 available. Difficulty vs.¬†discrimination scatter plot.","code":"plot.item_params(x, type = c(\"scatter\", \"density\", \"both\"), ...) plot(items_2pl, type = \"scatter\") #> `geom_smooth()` using formula = 'y ~ x'"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"as-data-frame-item_params","dir":"Articles","previous_headings":"4. S3 Methods > 4.4 Methods for item_params Objects","what":"as.data.frame.item_params()","title":"Complete API Reference with Examples","text":"Extracts item parameter data frame.","code":"as.data.frame.item_params(x, row.names = NULL, optional = FALSE, ...) df <- as.data.frame(items_rasch) head(df) #>   form_id item_id       beta lambda lambda_unscaled #> 1       1       1  1.1834223      1               1 #> 2       1       2 -0.7522343      1               1 #> 3       1       3  0.1755922      1               1 #> 4       1       4  0.4453264      1               1 #> 5       1       5  0.2167322      1               1 #> 6       1       6 -0.2936607      1               1"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"methods-for-feasibility_check-objects","dir":"Articles","previous_headings":"4. S3 Methods","what":"4.5 Methods for feasibility_check Objects","title":"Complete API Reference with Examples","text":"Objects returned check_feasibility().","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"print-feasibility_check","dir":"Articles","previous_headings":"4. S3 Methods > 4.5 Methods for feasibility_check Objects","what":"print.feasibility_check()","title":"Complete API Reference with Examples","text":"Prints achievable reliability ranges design information.","code":"print.feasibility_check(x, digits = 4, ...) print(feas) #>  #> ======================================================= #>   Feasibility Check: Achievable Reliability Range #> ======================================================= #>  #>   Number of items  : 25 #>   Model            : RASCH #>   Latent shape     : normal #>   Latent variance  : 1.0099 #>   c range          : [0.10, 10.00] #>   Monte Carlo M    : 5000 #>  #> Achievable Reliability Ranges: #>   rho_tilde (info) : [0.0591, 0.9872] #>   rho_bar   (msem) : [0.0002, 0.9146] #>  #> Note: rho_tilde >= rho_bar always (Jensen's inequality). #>   Use rho_tilde range for EQC targets. #>   Use rho_bar range for SAC targets."},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"methods-for-rho_curve-objects","dir":"Articles","previous_headings":"4. S3 Methods","what":"4.6 Methods for rho_curve Objects","title":"Complete API Reference with Examples","text":"Objects returned rho_curve().","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"print-rho_curve","dir":"Articles","previous_headings":"4. S3 Methods > 4.6 Methods for rho_curve Objects","what":"print.rho_curve()","title":"Complete API Reference with Examples","text":"Prints compact summary reliability curve data first rows.","code":"print.rho_curve(x, ...) print(curve_data) #> Reliability Curve #> ================= #>   Items: 25 | Model: RASCH | Metric: both #>   c range: [0.20, 4.00] (40 points) #>   rho_tilde range: [0.1989, 0.9672] #>   rho_bar range  : [0.1989, 0.9146] #>  #>           c rho_tilde   rho_bar #> 1 0.2000000 0.1988965 0.1988657 #> 2 0.2974359 0.3500759 0.3498742 #> 3 0.3948718 0.4807284 0.4800963 #> 4 0.4923077 0.5827614 0.5814095 #> 5 0.5897436 0.6596796 0.6573608 #> 6 0.6871795 0.7174113 0.7139425 #>   ... (34 more rows)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"summary-print-methods","dir":"Articles","previous_headings":"4. S3 Methods","what":"4.7 Summary Print Methods","title":"Complete API Reference with Examples","text":"summary class print method displays formatted output.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"print-summary-eqc_result","dir":"Articles","previous_headings":"4. S3 Methods > 4.7 Summary Print Methods","what":"print.summary.eqc_result()","title":"Complete API Reference with Examples","text":"","code":"print.summary.eqc_result(x, digits = 4, ...) print(summary(eqc_res)) #> Summary: Empirical Quadrature Calibration (EQC) #> ================================================ #>   Model            : RASCH #>   Metric           : Average-information (tilde) #>   Number of items  : 25 #>   Quadrature (M)   : 5000 #>   Latent variance  : 1.0099 #>  #> Calibration Results: #>   Target rho*      : 0.8000 #>   Achieved rho     : 0.8000 #>   Absolute error   : 1.19e-07 #>   Scaling factor c*: 0.8995 #>   Root status      : uniroot_success"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"print-summary-sac_result","dir":"Articles","previous_headings":"4. S3 Methods > 4.7 Summary Print Methods","what":"print.summary.sac_result()","title":"Complete API Reference with Examples","text":"","code":"print.summary.sac_result(x, digits = 4, ...) print(summary(sac_res)) #> Summary: Stochastic Approximation Calibration (SAC) #> ==================================================== #>   Model            : RASCH #>   Metric           : MSEM-based (bar/w) #>   Number of items  : 25 #>   Iterations       : 200 #>   Burn-in          : 100 #>   M per iteration  : 500 #>   M pre-calc       : 5000 #>   Init method      : apc_warm_start #>  #> Calibration Results: #>   Target rho*      : 0.8000 #>   Achieved rho     : 0.8292 #>   Absolute error   : 2.92e-02 #>   Scaling factor c*: 1.0504 #>   Converged        : Yes #>   Post-burn-in SD  : 0.0210"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"print-summary-item_params","dir":"Articles","previous_headings":"4. S3 Methods > 4.7 Summary Print Methods","what":"print.summary.item_params()","title":"Complete API Reference with Examples","text":"","code":"print.summary.item_params(x, digits = 4, ...) print(summary(items_2pl)) #> Summary: Item Parameters #> ======================== #>   Model          : 2PL #>   Source         : parametric #>   Method         : copula #>   Items per form : 30 #>   Number of forms: 1 #>   Scale factor   : 1.000 #>   Centered       : Yes #>  #> Difficulty (beta): #>   Mean     : 0.0000 #>   SD       : 1.2550 #>   Min      : -2.7250 #>   Max      : 2.2181 #>   Quantiles: Q25=-0.4681, Q50=-0.1690, Q75=1.0014 #>  #> Discrimination (lambda): #>   Before scaling: Mean=1.0867, SD=0.2885 #>   After scaling (c=1.000): Mean=1.0867, SD=0.2885 #>   Range [0.4396, 1.7309] #>  #> Correlation (beta, log-lambda): #>   Target (rho)     : -0.3000 #>   Achieved Pearson : -0.3611 #>   Achieved Spearman: -0.3784"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"print-summary-latent_g","dir":"Articles","previous_headings":"4. S3 Methods > 4.7 Summary Print Methods","what":"print.summary.latent_G()","title":"Complete API Reference with Examples","text":"","code":"print.summary.latent_G(x, digits = 4, ...) print(summary(g_norm)) #> Summary: Latent Ability Distribution #> ==================================== #>   Shape      : normal #>   n          : 2000 #>   Target     : mu = 0.00, sigma = 1.00 #>   Covariates : No #>  #> Sample Statistics: #>   Mean       : -0.0156 #>   SD         : 0.9941 #>   Median     : -0.0131 #>   Skewness   : 0.0128 #>   Kurtosis   : 0.0560 (excess) #>   Range      : [-3.3717, 3.5847] #>  #> Quantiles: #>    2.5%      5%     25%     50%     75%     95%   97.5%  #> -1.9835 -1.6446 -0.6691 -0.0131  0.6608  1.5768  1.8871"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"deprecated-functions","dir":"Articles","previous_headings":"","what":"5. Deprecated Functions","title":"Complete API Reference with Examples","text":"functions retained backward compatibility removed future release. issue deprecation warning called.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"spc-calibrate","dir":"Articles","previous_headings":"5. Deprecated Functions","what":"5.1 spc_calibrate()","title":"Complete API Reference with Examples","text":"Deprecated alias sac_calibrate(). arguments passed unchanged. Use sac_calibrate() new code.","code":"spc_calibrate(...) # Deprecated: use sac_calibrate() instead result <- spc_calibrate(   target_rho = 0.80, n_items = 25, model = \"rasch\",   n_iter = 200, seed = 42 )"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"compare-eqc-spc","dir":"Articles","previous_headings":"5. Deprecated Functions","what":"5.2 compare_eqc_spc()","title":"Complete API Reference with Examples","text":"Deprecated alias compare_eqc_sac(). arguments passed unchanged. Use compare_eqc_sac() new code.","code":"compare_eqc_spc(...) # Deprecated: use compare_eqc_sac() instead compare_eqc_spc(eqc_result, sac_result)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"cross-reference-table","dir":"Articles","previous_headings":"","what":"6. Cross-Reference Table","title":"Complete API Reference with Examples","text":"table maps function vignette covers detail.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"complete-workflow-example","dir":"Articles","previous_headings":"","what":"7. Complete Workflow Example","title":"Complete API Reference with Examples","text":"section demonstrates full simulation study using IRTsimrel API.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"step-1-check-feasibility","dir":"Articles","previous_headings":"7. Complete Workflow Example","what":"Step 1: Check Feasibility","title":"Complete API Reference with Examples","text":"","code":"feas_check <- check_feasibility(   n_items = 30,   model   = \"rasch\",   M       = 5000L,   seed    = 42,   verbose = FALSE ) cat(sprintf(\"For 30 Rasch items, achievable rho_tilde: [%.3f, %.3f]\\n\",             feas_check$rho_range_info[1], feas_check$rho_range_info[2])) #> For 30 Rasch items, achievable rho_tilde: [0.070, 0.989]"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"step-2-calibrate-with-eqc","dir":"Articles","previous_headings":"7. Complete Workflow Example","what":"Step 2: Calibrate with EQC","title":"Complete API Reference with Examples","text":"","code":"eqc_wf <- eqc_calibrate(   target_rho = 0.85,   n_items    = 30,   model      = \"rasch\",   M          = 5000L,   seed       = 42 ) cat(sprintf(\"EQC: c* = %.4f, rho = %.4f\\n\",             eqc_wf$c_star, eqc_wf$achieved_rho)) #> EQC: c* = 0.9943, rho = 0.8500"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"step-3-validate-with-sac","dir":"Articles","previous_headings":"7. Complete Workflow Example","what":"Step 3: Validate with SAC","title":"Complete API Reference with Examples","text":"","code":"sac_wf <- sac_calibrate(   target_rho = 0.85,   n_items    = 30,   model      = \"rasch\",   c_init     = eqc_wf,   n_iter     = 150L,   M_per_iter = 500L,   M_pre      = 5000L,   seed       = 42,   verbose    = FALSE ) cat(sprintf(\"SAC: c* = %.4f, rho = %.4f\\n\",             sac_wf$c_star, sac_wf$achieved_rho)) #> SAC: c* = 1.0298, rho = 0.8417"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"step-4-compare-results","dir":"Articles","previous_headings":"7. Complete Workflow Example","what":"Step 4: Compare Results","title":"Complete API Reference with Examples","text":"","code":"comp_wf <- compare_eqc_sac(eqc_wf, sac_wf, verbose = TRUE) #> Warning in compare_eqc_sac(eqc_wf, sac_wf, verbose = TRUE): Reliability metric #> differs between EQC ('info') and SAC ('msem'). #>  #> ======================================================= #>   EQC vs SAC Comparison #> ======================================================= #>  #>   Target reliability  : 0.8500 #>   EQC c*              : 0.994331 #>   SAC c*              : 1.029780 #>   Absolute difference : 0.035449 #>   Percent difference  : 3.57% #>   Agreement (< 5%)    : YES #>"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"step-5-generate-response-data","dir":"Articles","previous_headings":"7. Complete Workflow Example","what":"Step 5: Generate Response Data","title":"Complete API Reference with Examples","text":"","code":"resp_wf <- simulate_response_data(   result    = eqc_wf,   n_persons = 1000,   seed      = 123 ) cat(sprintf(\"Generated %d x %d response matrix\\n\",             nrow(resp_wf$response_matrix),             ncol(resp_wf$response_matrix))) #> Generated 1000 x 30 response matrix cat(sprintf(\"Mean score: %.2f / %d items\\n\",             mean(rowSums(resp_wf$response_matrix)),             ncol(resp_wf$response_matrix))) #> Mean score: 15.00 / 30 items"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"step-6-extract-calibrated-parameters","dir":"Articles","previous_headings":"7. Complete Workflow Example","what":"Step 6: Extract Calibrated Parameters","title":"Complete API Reference with Examples","text":"","code":"params_wf <- coef(eqc_wf) head(params_wf) #>   item_id        beta lambda_base lambda_scaled    c_star #> 1       1  0.17744288           1     0.9943313 0.9943313 #> 2       2  1.07651047           1     0.9943313 0.9943313 #> 3       3  0.41625569           1     0.9943313 0.9943313 #> 4       4 -0.03332812           1     0.9943313 0.9943313 #> 5       5 -0.22009069           1     0.9943313 0.9943313 #> 6       6 -0.01258907           1     0.9943313 0.9943313 cat(sprintf(\"\\nScaled discrimination: mean = %.3f, sd = %.3f\\n\",             mean(params_wf$lambda_scaled),             sd(params_wf$lambda_scaled))) #>  #> Scaled discrimination: mean = 0.994, sd = 0.000"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"step-7-explore-reliability-curve","dir":"Articles","previous_headings":"7. Complete Workflow Example","what":"Step 7: Explore Reliability Curve","title":"Complete API Reference with Examples","text":"Reliability curve workflow example.","code":"rc_wf <- rho_curve(   c_values = seq(0.2, 3, length.out = 30),   n_items  = 30,   model    = \"rasch\",   M        = 5000L,   seed     = 42,   plot     = TRUE )"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"step-8-validate-with-tam-optional","dir":"Articles","previous_headings":"7. Complete Workflow Example","what":"Step 8: Validate with TAM (optional)","title":"Complete API Reference with Examples","text":"","code":"# Requires TAM package tam_wf <- compute_reliability_tam(   resp  = resp_wf$response_matrix,   model = \"rasch\" ) cat(sprintf(\"WLE reliability: %.4f\\n\", tam_wf$rel_wle)) cat(sprintf(\"EAP reliability: %.4f\\n\", tam_wf$rel_eap)) cat(sprintf(\"Target reliability: %.4f\\n\", eqc_wf$target_rho))"},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"complete-export-inventory","dir":"Articles","previous_headings":"","what":"8. Complete Export Inventory","title":"Complete API Reference with Examples","text":"table lists every symbol exported IRTsimrel (NAMESPACE file), organized alphabetically.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/api-reference.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session Information","title":"Complete API Reference with Examples","text":"","code":"sessionInfo() #> R version 4.5.2 (2025-10-31) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 24.04.3 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats     graphics  grDevices utils     datasets  methods   base      #>  #> other attached packages: #> [1] IRTsimrel_0.2.0 #>  #> loaded via a namespace (and not attached): #>  [1] vctrs_0.7.1        nlme_3.1-168       cli_3.6.5          knitr_1.51         #>  [5] rlang_1.1.7        xfun_0.56          S7_0.2.1           textshaping_1.0.4  #>  [9] jsonlite_2.0.0     labeling_0.4.3     glue_1.8.0         htmltools_0.5.9    #> [13] ragg_1.5.0         sass_0.4.10        scales_1.4.0       rmarkdown_2.30     #> [17] grid_4.5.2         evaluate_1.0.5     jquerylib_0.1.4    MASS_7.3-65        #> [21] fastmap_1.2.0      yaml_2.3.12        lifecycle_1.0.5    compiler_4.5.2     #> [25] RColorBrewer_1.1-3 fs_1.6.6           mgcv_1.9-3         lattice_0.22-7     #> [29] farver_2.1.2       systemfonts_1.3.1  digest_0.6.39      R6_2.6.1           #> [33] splines_4.5.2      Matrix_1.7-4       bslib_0.10.0       withr_3.0.2        #> [37] tools_4.5.2        gtable_0.3.6       pkgdown_2.2.0      ggplot2_4.0.2      #> [41] cachem_1.1.0       desc_1.4.3"},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"overview","dir":"Articles","previous_headings":"","what":"1. Overview","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"Reading time: approximately 30‚Äì40 minutes. vignette walks complete workflow generating simulated item response data pre-specified marginal reliability. approach implements framework described Lee (2025), treats reliability design parameter rather emergent property simulation. Learning objectives. completing guide able : Screen whether desired reliability achievable given test design. Visualize reliability curve understand design space. Calibrate discrimination scaling factor EQC (Algorithm 1). Optionally validate calibration SAC (Algorithm 2). Generate item response data target reliability. Extract, summarize, export calibrated item parameters. Prerequisites. Install IRTsimrel (optionally) TAM external validation: Throughout guide use seed = 42 M = 5000L examples run quickly reproduce exactly.","code":"# install.packages(\"devtools\") devtools::install_github(\"your-repo/IRTsimrel\") install.packages(\"TAM\")"},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"the-6-step-workflow","dir":"Articles","previous_headings":"","what":"2. The 6-Step Workflow","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"reliability-targeted simulation workflow consists six steps. table provides quick summary walk step detail.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"step-1-screen-feasibility-with-check_feasibility","dir":"Articles","previous_headings":"2. The 6-Step Workflow","what":"2.1 Step 1: Screen Feasibility with check_feasibility()","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"investing computation time calibration, verify target reliability achievable. check_feasibility() evaluates reliability metrics across range scaling factors reports achievable interval. output tells achievable range average-information metric (œÅÃÉ\\tilde{\\rho}) MSEM-based metric (w‚Äæ\\bar{w}). target falls outside reported range, must change design (e.g., add items switch 2PL model). Quick check specific target:","code":"feas <- check_feasibility(   n_items      = 25,   model        = \"rasch\",   latent_shape = \"normal\",   item_source  = \"parametric\",   c_bounds     = c(0.1, 10),   M            = 5000L,   seed         = 42 ) #>  #> ======================================================= #>   Feasibility Check: Achievable Reliability Range #> ======================================================= #>  #>   Number of items  : 25 #>   Model            : RASCH #>   Latent shape     : normal #>   Latent variance  : 1.0099 #>   c range          : [0.10, 10.00] #>   Monte Carlo M    : 5000 #>  #> Achievable Reliability Ranges: #>   rho_tilde (info) : [0.0591, 0.9872] #>   rho_bar   (msem) : [0.0002, 0.9146] #>  #> Note: rho_tilde >= rho_bar always (Jensen's inequality). #>   Use rho_tilde range for EQC targets. #>   Use rho_bar range for SAC targets. target <- 0.85 in_range <- target >= feas$rho_range_info[1] && target <= feas$rho_range_info[2] cat(sprintf(\"Target rho = %.2f is %s for this design.\\n\",             target, ifelse(in_range, \"FEASIBLE\", \"NOT feasible\"))) #> Target rho = 0.85 is FEASIBLE for this design."},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"comparing-feasibility-across-designs","dir":"Articles","previous_headings":"2. The 6-Step Workflow > 2.1 Step 1: Screen Feasibility with check_feasibility()","what":"Comparing feasibility across designs","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"can compare different test lengths find minimum number items needed:  shaded region shows achievable reliability range function test length. type visualization useful study planning: can immediately see minimum test length needed reach desired reliability. latent distribution affects ranges, see vignette(\"latent-distributions\").","code":"test_lengths <- c(10, 15, 20, 25, 30, 40) feas_table <- data.frame(   n_items   = test_lengths,   rho_min   = numeric(length(test_lengths)),   rho_max   = numeric(length(test_lengths)) )  for (i in seq_along(test_lengths)) {   fi <- check_feasibility(     n_items = test_lengths[i], model = \"rasch\",     item_source = \"parametric\", M = 5000L,     seed = 42, verbose = FALSE   )   feas_table$rho_min[i] <- round(fi$rho_range_info[1], 4)   feas_table$rho_max[i] <- round(fi$rho_range_info[2], 4) }  feas_table #>   n_items rho_min rho_max #> 1      10  0.0246  0.9729 #> 2      15  0.0363  0.9797 #> 3      20  0.0479  0.9850 #> 4      25  0.0591  0.9872 #> 5      30  0.0701  0.9894 #> 6      40  0.0914  0.9918 plot(NULL, xlim = range(test_lengths), ylim = c(0, 1),      xlab = \"Number of Items\", ylab = expression(tilde(rho)),      main = \"Achievable Reliability Range by Test Length\") polygon(c(test_lengths, rev(test_lengths)),         c(feas_table$rho_min, rev(feas_table$rho_max)),         col = adjustcolor(\"steelblue\", alpha.f = 0.3), border = NA) lines(test_lengths, feas_table$rho_min, col = \"steelblue\", lwd = 2) lines(test_lengths, feas_table$rho_max, col = \"steelblue\", lwd = 2) abline(h = 0.85, lty = 2, col = \"firebrick\") text(max(test_lengths), 0.86, expression(rho^\"*\" == 0.85),      col = \"firebrick\", pos = 2, cex = 0.9)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"step-2-explore-the-reliability-curve-with-rho_curve","dir":"Articles","previous_headings":"2. The 6-Step Workflow","what":"2.2 Step 2: Explore the Reliability Curve with rho_curve()","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"reliability curve œÅ(c)\\rho(c) shows reliability changes global discrimination scaling factor cc varies. visualization helps understand shape design space select sensible targets.  plot shows œÅÃÉ\\tilde{\\rho} (average-information) w‚Äæ\\bar{w} (MSEM-based). Note œÅÃÉ‚â•w‚Äæ\\tilde{\\rho} \\geq \\bar{w} always holds Jensen‚Äôs inequality. Reading curve. can use returned data frame find approximate cc values target:","code":"curve_data <- rho_curve(   n_items      = 25,   model        = \"rasch\",   latent_shape = \"normal\",   item_source  = \"parametric\",   metric       = \"both\",   M            = 5000L,   seed         = 42,   plot         = TRUE ) head(curve_data) #> Reliability Curve #> ================= #>   Items: 25 | Model: RASCH | Metric: both #>   c range: [0.10, 0.60] (6 points) #>   rho_tilde range: [0.0591, 0.6666] #>   rho_bar range  : [0.0591, 0.6641] #>  #>     c  rho_tilde    rho_bar #> 1 0.1 0.05913372 0.05913302 #> 2 0.2 0.19889655 0.19886569 #> 3 0.3 0.35385665 0.35364731 #> 4 0.4 0.48680763 0.48614470 #> 5 0.5 0.58967106 0.58825103 #> 6 0.6 0.66655958 0.66412727  # Find approximate c for rho_tilde = 0.80 idx <- which.min(abs(curve_data$rho_tilde - 0.80)) cat(sprintf(\"Approximate c for rho_tilde = 0.80: %.3f\\n\", curve_data$c[idx])) #> Approximate c for rho_tilde = 0.80: 0.900"},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"step-3-calibrate-with-eqc-eqc_calibrate","dir":"Articles","previous_headings":"2. The 6-Step Workflow","what":"2.3 Step 3: Calibrate with EQC ‚Äî eqc_calibrate()","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"EQC (Empirical Quadrature Calibration) Algorithm 1 Lee (2025). uses deterministic root-finding (Brent‚Äôs method via uniroot()) solve equation œÅÃÇM(c*)=œÅ*\\hat{\\rho}_M(c^*) = \\rho^*.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"basic-calibration-rasch","dir":"Articles","previous_headings":"2. The 6-Step Workflow > 2.3 Step 3: Calibrate with EQC ‚Äî eqc_calibrate()","what":"2.3.1 Basic calibration (Rasch)","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"Key outputs: c_star: calibrated scaling factor c*c^*. achieved_rho: empirical reliability c*c^*. items_calib: item parameter object scaled discriminations.","code":"eqc_result <- eqc_calibrate(   target_rho        = 0.85,   n_items           = 25,   model             = \"rasch\",   latent_shape      = \"normal\",   item_source       = \"parametric\",   reliability_metric = \"info\",   M                 = 5000L,   seed              = 42,   verbose           = TRUE ) #> Step 1: Generating quadrature samples... #>   M (quad persons) = 5000 #>   I (items)        = 25 #>   theta: mean = -0.014, sd = 1.005, var = 1.010 #>   beta:  mean = 0.000, sd = 0.861 #>   lambda_base: mean = 1.000, sd = 0.000 #>   metric = info #> Step 2: Running root-finding algorithm... #>   At c = 0.300: rho = 0.3539, g = -0.4961 #>   At c = 3.000: rho = 0.9550, g = 0.1050 #>   c* = 1.119885 #>   Target rho    = 0.8500 #>   Achieved rho  = 0.8500 #>   Root status   = uniroot_success print(eqc_result) #>  #> ======================================================= #>   Empirical Quadrature Calibration (EQC) Results #> ======================================================= #>  #> Calibration Summary: #>   Model                        : RASCH #>   Target reliability (rho*)    : 0.8500 #>   Achieved reliability         : 0.8500 #>   Absolute error               : 9.22e-07 #>   Scaling factor (c*)          : 1.1199 #>  #> Design Parameters: #>   Number of items (I)          : 25 #>   Quadrature points (M)        : 5000 #>   Reliability metric           : Average-information (tilde) #>   Latent variance              : 1.0099 #>  #> Convergence: #>   Root status                  : uniroot_success #>   Search bracket               : [0.300, 3.000] #>   Bracket reliabilities        : [0.3539, 0.9550] #>  #> Parameter Summaries: #>   theta:        mean = -0.014, sd = 1.005 #>   beta:         mean = 0.000, sd = 0.861, range = [-2.17, 1.45] #>   lambda_base:  mean = 1.000, sd = 0.000 #>   lambda_scaled: mean = 1.120, sd = 0.000"},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"exploring-the-result","dir":"Articles","previous_headings":"2. The 6-Step Workflow > 2.3 Step 3: Calibrate with EQC ‚Äî eqc_calibrate()","what":"2.3.2 Exploring the result","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"","code":"summary(eqc_result) #> Summary: Empirical Quadrature Calibration (EQC) #> ================================================ #>   Model            : RASCH #>   Metric           : Average-information (tilde) #>   Number of items  : 25 #>   Quadrature (M)   : 5000 #>   Latent variance  : 1.0099 #>  #> Calibration Results: #>   Target rho*      : 0.8500 #>   Achieved rho     : 0.8500 #>   Absolute error   : 9.22e-07 #>   Scaling factor c*: 1.1199 #>   Root status      : uniroot_success"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"calibrating-under-different-models-and-shapes","dir":"Articles","previous_headings":"2. The 6-Step Workflow > 2.3 Step 3: Calibrate with EQC ‚Äî eqc_calibrate()","what":"2.3.4 Calibrating under different models and shapes","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"2PL model bimodal population: Skewed population heavy tails:","code":"eqc_2pl <- eqc_calibrate(   target_rho   = 0.80,   n_items      = 30,   model        = \"2pl\",   latent_shape = \"bimodal\",   latent_params = list(shape_params = list(delta = 0.8)),   item_source  = \"parametric\",   M            = 5000L,   seed         = 42 )  cat(sprintf(\"c* = %.4f, achieved rho = %.4f\\n\",             eqc_2pl$c_star, eqc_2pl$achieved_rho)) #> c* = 0.7930, achieved rho = 0.8000 eqc_skew <- eqc_calibrate(   target_rho   = 0.80,   n_items      = 25,   model        = \"rasch\",   latent_shape = \"skew_pos\",   item_source  = \"parametric\",   M            = 5000L,   seed         = 42 )  cat(sprintf(\"c* = %.4f, achieved rho = %.4f\\n\",             eqc_skew$c_star, eqc_skew$achieved_rho)) #> c* = 0.9132, achieved rho = 0.8000"},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"step-4-optional-validate-with-sac-sac_calibrate","dir":"Articles","previous_headings":"2. The 6-Step Workflow","what":"2.4 Step 4: (Optional) Validate with SAC ‚Äî sac_calibrate()","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"SAC (Stochastic Approximation Calibration) Algorithm 2. uses Robbins‚ÄìMonro stochastic approximation algorithm can target either œÅÃÉ\\tilde{\\rho} w‚Äæ\\bar{w}. SAC useful : Independent validation EQC results. Targeting w‚Äæ\\bar{w} directly (theoretically exact metric). Complex scenarios analytic information functions unavailable.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"warm-start-from-eqc-recommended","dir":"Articles","previous_headings":"2. The 6-Step Workflow > 2.4 Step 4: (Optional) Validate with SAC ‚Äî sac_calibrate()","what":"2.4.1 Warm-start from EQC (recommended)","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"Passing EQC result c_init accelerates SAC convergence:","code":"sac_result <- sac_calibrate(   target_rho        = 0.85,   n_items           = 25,   model             = \"rasch\",   latent_shape      = \"normal\",   item_source       = \"parametric\",   reliability_metric = \"info\",   c_init            = eqc_result,   n_iter            = 200L,   M_per_iter        = 500L,   M_pre             = 5000L,   seed              = 42,   verbose           = TRUE ) #>  #> ================================================================ #>   Stochastic Approximation Calibration (SAC) #> ================================================================ #>  #> Configuration: #>   Target reliability    : 0.8500 #>   Number of items       : 25 #>   Model                 : RASCH #>   Reliability metric    : info #>   M per iteration       : 500 #>   M for variance pre-calc: 5000 #>   Total iterations      : 200 #>   Burn-in               : 100 #>   Resample items        : Yes #>   Step params: a=1.00, A=50, gamma=0.67 #>  #> Step 0: Pre-calculating latent variance... #>   Estimated theta_var = 1.0099 (from M_pre = 5000 samples) #>  #> Step 1: Initializing c_0... #>   c_0 = 1.1199 (EQC warm start from eqc_result object) #> Step 3: Running 200 Robbins-Monro iterations... #>   [ 10%] Iter   20: c = 1.1243, rho = 0.8413 #>   [ 20%] Iter   40: c = 1.1277, rho = 0.8474 #>   [ 30%] Iter   60: c = 1.1319, rho = 0.8441 #>   [ 40%] Iter   80: c = 1.1327, rho = 0.8480 #>   [ 50%] Iter  100: c = 1.1336, rho = 0.8464 #>   [ 60%] Iter  120: c = 1.1359, rho = 0.8497 #>   [ 70%] Iter  140: c = 1.1378, rho = 0.8499 #>   [ 80%] Iter  160: c = 1.1386, rho = 0.8492 #>   [ 90%] Iter  180: c = 1.1394, rho = 0.8457 #>   [100%] Iter  200: c = 1.1403, rho = 0.8515 #>  #> Step 4: Computing Polyak-Ruppert average... #>   Polyak-Ruppert c* = 1.137803 (averaging 100 iterates) #>  #> Step 5: Computing post-calibration reliability... #>  #> Step 6: Computing convergence diagnostics... #>  #> ================================================================ #>   SAC Calibration Complete #> ================================================================ #>   Target reliability   : 0.8500 #>   Achieved reliability : 0.8533 #>   Absolute error       : 0.0033 #>   Calibrated c*        : 1.137803 #>   Final iterate c_n    : 1.140264 #>   Init method          : eqc_warm_start #>   Converged            : Yes #>"},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"visualize-sac-convergence","dir":"Articles","previous_headings":"2. The 6-Step Workflow > 2.4 Step 4: (Optional) Validate with SAC ‚Äî sac_calibrate()","what":"2.4.2 Visualize SAC convergence","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"","code":"plot(sac_result)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"compare-eqc-and-sac","dir":"Articles","previous_headings":"2. The 6-Step Workflow > 2.4 Step 4: (Optional) Validate with SAC ‚Äî sac_calibrate()","what":"2.4.3 Compare EQC and SAC","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"comparison reports absolute percentage difference c*c^* two algorithms. Agreement within 5% typical well-conditioned problems.","code":"comparison <- compare_eqc_sac(eqc_result, sac_result) #>  #> ======================================================= #>   EQC vs SAC Comparison #> ======================================================= #>  #>   Target reliability  : 0.8500 #>   EQC c*              : 1.119885 #>   SAC c*              : 1.137803 #>   Absolute difference : 0.017918 #>   Percent difference  : 1.60% #>   Agreement (< 5%)    : YES #>"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"step-5-generate-response-data-simulate_response_data","dir":"Articles","previous_headings":"2. The 6-Step Workflow","what":"2.5 Step 5: Generate Response Data ‚Äî simulate_response_data()","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"calibration complete, generate binary response matrix. function draws NN persons specified latent distribution generates responses using calibrated item parameters.","code":"sim_data <- simulate_response_data(   result       = eqc_result,   n_persons    = 500,   latent_shape = \"normal\",   seed         = 123 )  cat(sprintf(\"Response matrix: %d persons x %d items\\n\",             nrow(sim_data$response_matrix),             ncol(sim_data$response_matrix))) #> Response matrix: 500 persons x 25 items cat(sprintf(\"Mean proportion correct: %.3f\\n\",             mean(sim_data$response_matrix))) #> Mean proportion correct: 0.502"},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"inspect-the-generated-data","dir":"Articles","previous_headings":"2. The 6-Step Workflow > 2.5 Step 5: Generate Response Data ‚Äî simulate_response_data()","what":"2.5.1 Inspect the generated data","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"","code":"# First 5 persons, first 5 items sim_data$response_matrix[1:5, 1:5] #>      item1 item2 item3 item4 item5 #> [1,]     0     1     0     1     0 #> [2,]     0     1     0     1     1 #> [3,]     1     1     1     1     1 #> [4,]     1     0     0     1     0 #> [5,]     1     0     0     0     1  # Distribution of total scores total_scores <- rowSums(sim_data$response_matrix) summary(total_scores) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>    0.00    8.00   13.00   12.56   16.00   25.00 hist(total_scores, breaks = 20, col = \"steelblue\",      border = \"white\", main = \"Distribution of Total Scores\",      xlab = \"Total Score\", ylab = \"Frequency\")"},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"classical-item-analysis","dir":"Articles","previous_headings":"2. The 6-Step Workflow > 2.5 Step 5: Generate Response Data ‚Äî simulate_response_data()","what":"2.5.2 Classical item analysis","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"quick sanity check: compute item-total correlations item difficulty (proportion correct) generated data.","code":"p_correct <- colMeans(sim_data$response_matrix) item_total_cor <- apply(sim_data$response_matrix, 2, function(x) {   cor(x, total_scores - x)  # corrected item-total correlation })  par(mfrow = c(1, 2)) hist(p_correct, breaks = 15, col = \"steelblue\", border = \"white\",      main = \"Item Difficulty (p)\", xlab = \"Proportion Correct\") hist(item_total_cor, breaks = 15, col = \"darkorange\", border = \"white\",      main = \"Item-Total Correlation\", xlab = \"Corrected r_it\") par(mfrow = c(1, 1))"},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"external-validation-with-tam","dir":"Articles","previous_headings":"2. The 6-Step Workflow > 2.5 Step 5: Generate Response Data ‚Äî simulate_response_data()","what":"2.5.3 External validation with TAM","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"TAM package installed, can verify achieved reliability matches target: Note WLE vs EAP reliability. EAP reliability systematically higher WLE reliability TAM‚Äôs definitions. EAP reliability directly corresponds MSEM-based population reliability. conservative inference, treat WLE lower bound EAP upper bound.","code":"# Requires: install.packages(\"TAM\") tam_rel <- compute_reliability_tam(sim_data$response_matrix, model = \"rasch\") cat(sprintf(\"Target reliability: %.4f\\n\", eqc_result$target_rho)) cat(sprintf(\"EQC achieved rho:   %.4f\\n\", eqc_result$achieved_rho)) cat(sprintf(\"TAM WLE reliability: %.4f\\n\", tam_rel$rel_wle)) cat(sprintf(\"TAM EAP reliability: %.4f\\n\", tam_rel$rel_eap))"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"coef-calibrated-item-parameters","dir":"Articles","previous_headings":"2. The 6-Step Workflow > 2.6 Step 6: Extract and Use Results","what":"2.6.1 coef() ‚Äî calibrated item parameters","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"coef() method extracts tidy data frame item parameters: row contains: item_id: item identifier. beta: item difficulty. lambda_base: baseline (unscaled) discrimination. lambda_scaled: calibrated discrimination (Œªbase√óc*\\lambda_{\\text{base}} \\times c^*). c_star: calibrated scaling factor (constant across items).","code":"item_df <- coef(eqc_result) head(item_df) #>   item_id         beta lambda_base lambda_scaled   c_star #> 1       1  0.197732269           1      1.119885 1.119885 #> 2       2  1.096799859           1      1.119885 1.119885 #> 3       3  0.436545084           1      1.119885 1.119885 #> 4       4 -0.013038730           1      1.119885 1.119885 #> 5       5 -0.199801302           1      1.119885 1.119885 #> 6       6  0.007700326           1      1.119885 1.119885"},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"predict-reliability-at-new-scaling-factors","dir":"Articles","previous_headings":"2. The 6-Step Workflow > 2.6 Step 6: Extract and Use Results","what":"2.6.2 predict() ‚Äî reliability at new scaling factors","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"Use predict() evaluate reliability arbitrary scaling factor values: useful sensitivity analysis‚Äîinstance, exploring much reliability changes scaling factor shifts ¬±10%\\pm 10\\%.","code":"# Achieved reliability predict(eqc_result) #> [1] 0.8500009  # Reliability at several c values predict(eqc_result, newdata = c(0.5, 1.0, 1.5, 2.0)) #>     c=0.5     c=1.0     c=1.5     c=2.0  #> 0.5896711 0.8259511 0.8972175 0.9280310"},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"as-data-frame-export-item-parameters","dir":"Articles","previous_headings":"2. The 6-Step Workflow > 2.6 Step 6: Extract and Use Results","what":"2.6.3 as.data.frame() ‚Äî export item parameters","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"downstream analysis, export calibrated item parameters data frame:","code":"items_df <- as.data.frame(eqc_result$items_calib) head(items_df) #>   form_id item_id         beta   lambda lambda_unscaled #> 1       1       1  0.197732269 1.119885               1 #> 2       1       2  1.096799859 1.119885               1 #> 3       1       3  0.436545084 1.119885               1 #> 4       1       4 -0.013038730 1.119885               1 #> 5       1       5 -0.199801302 1.119885               1 #> 6       1       6  0.007700326 1.119885               1"},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"accessing-internal-components","dir":"Articles","previous_headings":"2. The 6-Step Workflow > 2.6 Step 6: Extract and Use Results","what":"2.6.4 Accessing internal components","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"calibration result objects store additional information advanced use:","code":"# EQC components cat(\"EQC result components:\\n\") #> EQC result components: cat(paste(\" \", names(eqc_result), collapse = \"\\n\"), \"\\n\\n\") #>   c_star #>   target_rho #>   achieved_rho #>   metric #>   model #>   n_items #>   M #>   theta_quad #>   theta_var #>   beta_vec #>   lambda_base #>   lambda_scaled #>   items_base #>   items_calib #>   call #>   misc  # Calibrated scaling factor cat(sprintf(\"c* = %.4f\\n\", eqc_result$c_star)) #> c* = 1.1199  # Latent variance from quadrature sample cat(sprintf(\"theta_var = %.4f\\n\", eqc_result$theta_var)) #> theta_var = 1.0099"},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"choosing-eqc-vs-sac","dir":"Articles","previous_headings":"","what":"3. Choosing EQC vs SAC","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"following decision table helps choose two algorithms. Practical recommendation: Start EQC using reliability_metric = \"info\". fast deterministic. Use SAC validate discrepancy œÅÃÉ\\tilde{\\rho} w‚Äæ\\bar{w} matters research question, need target w‚Äæ\\bar{w} directly. Always warm-start SAC EQC faster convergence.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"choosing-the-reliability-metric-info-vs-msem","dir":"Articles","previous_headings":"","what":"4. Choosing the Reliability Metric: info vs msem","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"IRTsimrel supports two population reliability definitions.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"average-information-reliability-tilderho","dir":"Articles","previous_headings":"4. Choosing the Reliability Metric: info vs msem","what":"4.1 Average-information reliability (œÅÃÉ\\tilde{\\rho})","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"œÅÃÉ(c)=œÉŒ∏2ùí•‚Äæ(c)œÉŒ∏2ùí•‚Äæ(c)+1 \\tilde{\\rho}(c) = \\frac{\\sigma^2_\\theta \\, \\bar{\\mathcal{J}}(c)} {\\sigma^2_\\theta \\, \\bar{\\mathcal{J}}(c) + 1} ùí•‚Äæ(c)=ùîºG[ùí•(Œ∏;c)]\\bar{\\mathcal{J}}(c) = \\mathbb{E}_G[\\mathcal{J}(\\theta; c)] average test information across latent distribution. Properties: Monotonically increasing cc (guaranteed unique root EQC). Upper bound w‚Äæ\\bar{w} via Jensen‚Äôs inequality. Faster compute w‚Äæ\\bar{w}.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"msem-based-marginal-reliability-barw","dir":"Articles","previous_headings":"4. Choosing the Reliability Metric: info vs msem","what":"4.2 MSEM-based marginal reliability (w‚Äæ\\bar{w})","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"w‚Äæ(c)=œÉŒ∏2œÉŒ∏2+ùîºG[1/ùí•(Œ∏;c)] \\bar{w}(c) = \\frac{\\sigma^2_\\theta} {\\sigma^2_\\theta + \\mathbb{E}_G[1/\\mathcal{J}(\\theta; c)]} Properties: Theoretically exact marginal reliability. Can non-monotone cc extreme scaling. Requires SAC safe targeting.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"jensens-inequality-the-key-relationship","dir":"Articles","previous_headings":"4. Choosing the Reliability Metric: info vs msem","what":"4.3 Jensen‚Äôs inequality: the key relationship","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"Jensen‚Äôs inequality applied convex function f(x)=1/xf(x) = 1/x: ùîº[1ùí•(Œ∏)]‚â•1ùîº[ùí•(Œ∏)] \\mathbb{E}\\!\\left[\\frac{1}{\\mathcal{J}(\\theta)}\\right] \\;\\geq\\; \\frac{1}{\\mathbb{E}[\\mathcal{J}(\\theta)]} implies œÅÃÉ‚â•w‚Äæ\\tilde{\\rho} \\geq \\bar{w}. gap small test information approximately constant across Œ∏\\theta, larger information varies substantially (e.g., short tests, non-normal populations).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"decision-guidance","dir":"Articles","previous_headings":"4. Choosing the Reliability Metric: info vs msem","what":"4.4 Decision guidance","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"","code":"# Compare metrics for the same calibration eqc_info <- eqc_calibrate(   target_rho = 0.85, n_items = 25, model = \"rasch\",   reliability_metric = \"info\", M = 5000L, seed = 42 )  cat(sprintf(\"Targeting info:  c* = %.4f, achieved = %.4f\\n\",             eqc_info$c_star, eqc_info$achieved_rho)) #> Targeting info:  c* = 1.1199, achieved = 0.8500"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"rasch-model","dir":"Articles","previous_headings":"5. Working with Different Models","what":"5.1 Rasch model","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"Rasch model, baseline discriminations equal 1. calibrated discriminations Œªi*=c*√ó1=c*\\lambda_i^* = c^* \\times 1 = c^* items.","code":"eqc_rasch <- eqc_calibrate(   target_rho  = 0.80,   n_items     = 20,   model       = \"rasch\",   item_source = \"parametric\",   M           = 5000L,   seed        = 42 )  items_rasch <- coef(eqc_rasch) cat(sprintf(\"All lambda_scaled equal? %s\\n\",             all(items_rasch$lambda_scaled == items_rasch$lambda_scaled[1]))) #> All lambda_scaled equal? TRUE cat(sprintf(\"Common discrimination: %.4f\\n\", items_rasch$lambda_scaled[1])) #> Common discrimination: 1.0183"},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"two-parameter-logistic-2pl-model","dir":"Articles","previous_headings":"5. Working with Different Models","what":"5.2 Two-parameter logistic (2PL) model","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"2PL model, baseline discriminations vary across items. scaling factor c*c^* applied uniformly: Œªi*=c*√óŒªi,0\\lambda_i^* = c^* \\times \\lambda_{,0}","code":"eqc_2pl_demo <- eqc_calibrate(   target_rho  = 0.80,   n_items     = 25,   model       = \"2pl\",   item_source = \"parametric\",   M           = 5000L,   seed        = 42 )  items_2pl <- coef(eqc_2pl_demo) cat(sprintf(\"c* = %.4f\\n\", eqc_2pl_demo$c_star)) #> c* = 0.8637 cat(sprintf(\"lambda_scaled range: [%.3f, %.3f]\\n\",             min(items_2pl$lambda_scaled), max(items_2pl$lambda_scaled))) #> lambda_scaled range: [0.460, 1.800]"},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"rasch-vs-2pl-comparison","dir":"Articles","previous_headings":"5. Working with Different Models","what":"5.3 Rasch vs 2PL comparison","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"","code":"targets <- c(0.70, 0.75, 0.80, 0.85, 0.90) comp_df <- data.frame(   target  = targets,   c_rasch = numeric(length(targets)),   c_2pl   = numeric(length(targets)) )  for (i in seq_along(targets)) {   r1 <- eqc_calibrate(target_rho = targets[i], n_items = 25, model = \"rasch\",                        item_source = \"parametric\", M = 5000L, seed = 42)   r2 <- eqc_calibrate(target_rho = targets[i], n_items = 25, model = \"2pl\",                        item_source = \"parametric\", M = 5000L, seed = 42)   comp_df$c_rasch[i] <- round(r1$c_star, 4)   comp_df$c_2pl[i]   <- round(r2$c_star, 4) }  comp_df #>   target c_rasch  c_2pl #> 1   0.70  0.6548 0.6229 #> 2   0.75  0.7572 0.7235 #> 3   0.80  0.8995 0.8637 #> 4   0.85  1.1199 1.0812 #> 5   0.90  1.5328 1.4887"},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"how-latent-shape-affects-calibration","dir":"Articles","previous_headings":"5. Working with Different Models","what":"5.4 How latent shape affects calibration","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"Different latent distribution shapes require different scaling factors achieve target reliability, even item parameters. test information function interacts differently shape.  barplot reveals heavy-tailed skewed distributions generally require higher scaling factors (stronger discriminations) achieve reliability. makes intuitive sense: extreme Œ∏\\theta values receive less test information logistic model, heavier tails put mass regions.","code":"shapes <- c(\"normal\", \"bimodal\", \"skew_pos\", \"heavy_tail\", \"uniform\") shape_df <- data.frame(   shape      = shapes,   c_star     = numeric(length(shapes)),   achieved   = numeric(length(shapes)) )  for (i in seq_along(shapes)) {   ri <- eqc_calibrate(     target_rho = 0.80, n_items = 25, model = \"rasch\",     latent_shape = shapes[i], item_source = \"parametric\",     M = 5000L, seed = 42   )   shape_df$c_star[i]   <- round(ri$c_star, 4)   shape_df$achieved[i] <- round(ri$achieved_rho, 4) }  shape_df #>        shape c_star achieved #> 1     normal 0.8995      0.8 #> 2    bimodal 0.9577      0.8 #> 3   skew_pos 0.9132      0.8 #> 4 heavy_tail 0.9365      0.8 #> 5    uniform 0.9012      0.8 barplot(   shape_df$c_star,   names.arg = shape_df$shape,   col = \"steelblue\", border = \"white\",   main = \"Calibrated c* by Latent Shape (target rho = 0.80)\",   ylab = expression(c^\"*\"), las = 2, cex.names = 0.8 ) abline(h = mean(shape_df$c_star), lty = 2, col = \"grey40\")"},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"effect-of-test-length-on-reliability-curve","dir":"Articles","previous_headings":"5. Working with Different Models","what":"5.5 Effect of test length on reliability curve","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"figure illustrates key relationship: longer tests reach given reliability target lower scaling factor. means adding items alternative increasing discrimination high reliability needed.","code":"lengths_to_plot <- c(10, 20, 30, 50) cols <- c(\"firebrick\", \"darkorange\", \"steelblue\", \"forestgreen\") c_grid <- seq(0.2, 4, length.out = 40)  plot(NULL, xlim = c(0.2, 4), ylim = c(0, 1),      xlab = \"Scaling factor c\", ylab = expression(tilde(rho)),      main = \"Reliability Curves by Test Length\") abline(h = 0.80, lty = 2, col = \"grey50\")  for (j in seq_along(lengths_to_plot)) {   cd <- rho_curve(     c_values = c_grid, n_items = lengths_to_plot[j],     model = \"rasch\", latent_shape = \"normal\",     item_source = \"parametric\", metric = \"info\",     M = 5000L, seed = 42, plot = FALSE   )   lines(cd$c, cd$rho_tilde, col = cols[j], lwd = 2) }  legend(\"bottomright\",        legend = paste0(\"I = \", lengths_to_plot),        col = cols, lwd = 2, bty = \"n\")"},{"path":[]},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"target-reliability-not-achievable","dir":"Articles","previous_headings":"6. Troubleshooting Guide > 6.1 Common issues and solutions","what":"‚ÄúTarget reliability not achievable‚Äù","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"Symptom: check_feasibility() shows target outside achievable range. Solutions: Increase number items. Switch Rasch 2PL (varying discriminations provide flexibility). Widen c_bounds check_feasibility() explore larger range. Consider whether latent shape makes target unrealistic.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"uniroot-fails-with-values-at-endpoints-not-of-opposite-sign","dir":"Articles","previous_headings":"6. Troubleshooting Guide > 6.1 Common issues and solutions","what":"uniroot() fails with ‚Äúvalues at endpoints not of opposite sign‚Äù","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"Symptom: EQC calibration fails target lies outside range [œÅ(cmin),œÅ(cmax)][\\rho(c_{\\min}), \\rho(c_{\\max})]. Solutions: Run check_feasibility() first. Widen c_bounds eqc_calibrate(). targeting \"msem\", switch \"info\" (monotone metric).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"sac-does-not-converge","dir":"Articles","previous_headings":"6. Troubleshooting Guide > 6.1 Common issues and solutions","what":"SAC does not converge","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"Symptom: SAC trajectory oscillates without settling. Solutions: Increase n_iter (e.g., 300 500 ). Decrease step-size base step_params. Increase step_params stabilization. Use warm start EQC. Increase M_per_iter reduce per-iteration variance.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"results-differ-between-eqc-and-sac","dir":"Articles","previous_headings":"6. Troubleshooting Guide > 6.1 Common issues and solutions","what":"Results differ between EQC and SAC","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"Symptom: compare_eqc_sac() reports 5% difference. Possible causes: Different reliability metrics (check metric field). Insufficient Monte Carlo samples (M EQC, M_per_iter/n_iter SAC). Different random seeds producing different item/theta draws. Solutions: Increase M M_per_iter. Use reliability_metric = \"info\" algorithms fair comparison. Use seed .","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"complete-template-copy-paste-workflow","dir":"Articles","previous_headings":"","what":"7. Complete Template: Copy-Paste Workflow","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"following code block self-contained template can copy project. Replace settings ‚ÄúConfiguration‚Äù section .","code":"# ============================================================ # Reliability-Targeted IRT Simulation: Complete Workflow # ============================================================ library(IRTsimrel)  # --- Configuration ------------------------------------------ target_rho   <- 0.85       # desired marginal reliability n_items      <- 25         # test length model        <- \"rasch\"    # \"rasch\" or \"2pl\" latent_shape <- \"normal\"   # latent distribution shape item_source  <- \"parametric\" N_persons    <- 500        # sample size for response data M_quad       <- 5000L      # Monte Carlo samples for EQC seed_val     <- 42         # for reproducibility  # --- Step 1: Feasibility ------------------------------------ feas <- check_feasibility(   n_items = n_items, model = model,   latent_shape = latent_shape, item_source = item_source,   M = M_quad, seed = seed_val, verbose = FALSE ) stopifnot(   target_rho >= feas$rho_range_info[1],   target_rho <= feas$rho_range_info[2] ) cat(\"Step 1: Feasibility confirmed.\\n\") #> Step 1: Feasibility confirmed.  # --- Step 2: Reliability curve (optional) -------------------- curve_df <- rho_curve(   n_items = n_items, model = model,   latent_shape = latent_shape, item_source = item_source,   M = M_quad, seed = seed_val, plot = FALSE )  # --- Step 3: EQC calibration -------------------------------- eqc_res <- eqc_calibrate(   target_rho = target_rho, n_items = n_items,   model = model, latent_shape = latent_shape,   item_source = item_source,   reliability_metric = \"info\",   M = M_quad, seed = seed_val ) cat(sprintf(\"Step 3: EQC calibrated c* = %.4f, achieved rho = %.4f\\n\",             eqc_res$c_star, eqc_res$achieved_rho)) #> Step 3: EQC calibrated c* = 1.1199, achieved rho = 0.8500  # --- Step 4: SAC validation (optional) ---------------------- sac_res <- sac_calibrate(   target_rho = target_rho, n_items = n_items,   model = model, latent_shape = latent_shape,   item_source = item_source,   reliability_metric = \"info\",   c_init = eqc_res,   n_iter = 200L, M_per_iter = 500L, M_pre = 5000L,   seed = seed_val ) cat(sprintf(\"Step 4: SAC calibrated c* = %.4f\\n\", sac_res$c_star)) #> Step 4: SAC calibrated c* = 1.1378  # --- Step 5: Generate response data ------------------------- sim_data <- simulate_response_data(   result = eqc_res, n_persons = N_persons,   latent_shape = latent_shape, seed = 123 ) cat(sprintf(\"Step 5: Generated %d x %d response matrix.\\n\",             nrow(sim_data$response_matrix),             ncol(sim_data$response_matrix))) #> Step 5: Generated 500 x 25 response matrix.  # --- Step 6: Extract results -------------------------------- item_params <- coef(eqc_res) cat(sprintf(\"Step 6: Extracted %d item parameters.\\n\", nrow(item_params))) #> Step 6: Extracted 25 item parameters."},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"publication-ready-language","dir":"Articles","previous_headings":"","what":"8. Publication-Ready Language","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"following text templates can adapted Method section journal paper. Replace bracketed values specific settings.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"describing-the-simulation-design","dir":"Articles","previous_headings":"8. Publication-Ready Language","what":"8.1 Describing the simulation design","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"Item response data generated using reliability-targeted simulation framework Lee (2025), implemented R package IRTsimrel (version 0.2.0). [Rasch / two-parameter logistic] model assumed [25] items latent abilities drawn [standard normal / bimodal / skewed] distribution.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"describing-the-calibration","dir":"Articles","previous_headings":"8. Publication-Ready Language","what":"8.2 Describing the calibration","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"global discrimination scaling factor c*c^* calibrated using Empirical Quadrature Calibration algorithm (EQC; Algorithm 1 Lee, 2025) Monte Carlo quadrature sample size M=M = [10,000] average-information reliability metric (œÅÃÉ\\tilde{\\rho}). target marginal reliability set œÅ*=\\rho^* = [0.85], achieved reliability [0.8500].","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"describing-optional-sac-validation","dir":"Articles","previous_headings":"8. Publication-Ready Language","what":"8.3 Describing optional SAC validation","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"EQC results cross-validated using Stochastic Approximation Calibration algorithm (SAC; Algorithm 2 Lee, 2025) [300] Robbins‚ÄìMonro iterations, warm-started EQC solution. two algorithms agreed within [X]% calibrated scaling factor.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"describing-the-response-data","dir":"Articles","previous_headings":"8. Publication-Ready Language","what":"8.4 Describing the response data","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"Binary item response data generated N=N = [500] simulated examinees using calibrated item parameters. response YpiY_{pi} drawn Bernoulli(ppi)\\text{Bernoulli}(p_{pi}) ppi=logit‚àí1[Œªi*(Œ∏p‚àíŒ≤i)]p_{pi} = \\text{logit}^{-1}[\\lambda_i^* (\\theta_p - \\beta_i)].","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"citing-the-package","dir":"Articles","previous_headings":"8. Publication-Ready Language","what":"8.5 Citing the package","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"Lee, J. (2025). Reliability-targeted simulation item response data: Solving inverse design problem. arXiv preprint, arXiv:2512.16012.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"further-reading","dir":"Articles","previous_headings":"","what":"9. Further Reading","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"IRTsimrel documentation suite includes several companion vignettes: vignette(\"quick-start\") ‚Äî minimal 5-minute introduction. vignette(\"latent-distributions\") ‚Äî Detailed guide 12 latent distribution shapes pre-standardization principle. vignette(\"item-parameters\") ‚Äî Sources methods generating realistic item parameters, including copula method IRW integration. vignette(\"theory-reliability\") ‚Äî Mathematical foundations œÅÃÉ\\tilde{\\rho} w‚Äæ\\bar{w}. vignette(\"algorithm-eqc\") ‚Äî Detailed derivation analysis Algorithm 1. vignette(\"algorithm-sac\") ‚Äî Detailed derivation analysis Algorithm 2. vignette(\"validation\") ‚Äî Comprehensive validation studies comparing IRTsimrel outputs TAM. vignette(\"api-reference\") ‚Äî Complete function reference parameters.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/applied-guide.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Applied Guide: Reliability-Targeted IRT Simulation","text":"Lee, J. (2025). Reliability-targeted simulation item response data: Solving inverse design problem. arXiv preprint, arXiv:2512.16012. Robbins, H., & Monro, S. (1951). stochastic approximation method. Annals Mathematical Statistics, 22(3), 400‚Äì407. Polyak, B. T., & Juditsky, . B. (1992). Acceleration stochastic approximation averaging. SIAM Journal Control Optimization, 30(4), 838‚Äì855. Baker, F. B., & Kim, S.-H. (2004). Item Response Theory: Parameter Estimation Techniques (2nd ed.). Marcel Dekker. Sweeney, S. M., et al.¬†(2022). investigation nature consequence relationship IRT difficulty discrimination. Educational Measurement: Issues Practice, 41(4), 50‚Äì67.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/case-studies.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Case Studies: Publication-Ready Simulation Templates","text":"Reading time: approximately 30‚Äì35 minutes. vignette presents three self-contained case studies, research question, factorial design, executable code, computed results, publication-ready methods paragraph. Every case study can serve starting template simulation work. case study follows five-step structure: Research question: precise, falsifiable question. Design: factorial layout factors levels. Code: executable R code using IRTsimrel. Results: tables figures computed eval=TRUE code. Methods text: publication-ready paragraph. Prerequisites: familiarity eqc_calibrate() simulate_response_data(). See vignette(\"introduction\") vignette(\"simulation-design\") background.","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/case-studies.html","id":"research-question","dir":"Articles","previous_headings":"Case Study 1: Model Comparison Under Controlled Reliability","what":"Research question","title":"Case Studies: Publication-Ready Simulation Templates","text":"2PL model recover item difficulty parameters better Rasch model marginal reliability held constant? Without reliability control, observed difference recovery accuracy artifact differing data quality. fixing reliability, isolate effect model structure parameter recovery. fundamental question IRT methodology. 2PL model parameters estimate, may affect precision difficulty estimates even overall data quality (measured reliability) equivalent.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/case-studies.html","id":"design","dir":"Articles","previous_headings":"Case Study 1: Model Comparison Under Controlled Reliability","what":"Design","title":"Case Studies: Publication-Ready Simulation Templates","text":"","code":"cs1_design <- expand.grid(   model       = c(\"rasch\", \"2pl\"),   target_rho  = c(0.60, 0.70, 0.80),   stringsAsFactors = FALSE ) n_items  <- 20 n_persons <- 300 R <- 5  # Use R = 500+ for a real study  cat(sprintf(\"Design cells: %d\\n\", nrow(cs1_design))) #> Design cells: 6 cat(sprintf(\"Total data sets: %d\\n\", nrow(cs1_design) * R)) #> Total data sets: 30"},{"path":"https://joonho112.github.io/IRTsimrel/articles/case-studies.html","id":"step-1-feasibility-screening","dir":"Articles","previous_headings":"Case Study 1: Model Comparison Under Controlled Reliability","what":"Step 1: Feasibility screening","title":"Case Studies: Publication-Ready Simulation Templates","text":"calibration, verify target reliabilities achievable: target reliabilities (0.60, 0.70, 0.80) within range.","code":"for (mod in c(\"rasch\", \"2pl\")) {   feas <- check_feasibility(     n_items      = n_items,     model        = mod,     item_source  = \"parametric\",     M            = 5000L,     seed         = 42,     verbose      = FALSE   )   cat(sprintf(\"  %s: achievable rho_tilde = [%.3f, %.3f]\\n\",               toupper(mod), feas$rho_range_info[1], feas$rho_range_info[2])) } #>   RASCH: achievable rho_tilde = [0.048, 0.985] #>   2PL: achievable rho_tilde = [0.062, 0.987]"},{"path":"https://joonho112.github.io/IRTsimrel/articles/case-studies.html","id":"step-2-calibrate-all-conditions","dir":"Articles","previous_headings":"Case Study 1: Model Comparison Under Controlled Reliability","what":"Step 2: Calibrate all conditions","title":"Case Studies: Publication-Ready Simulation Templates","text":"","code":"cs1_calib <- vector(\"list\", nrow(cs1_design))  for (i in seq_len(nrow(cs1_design))) {   d <- cs1_design[i, ]   cs1_calib[[i]] <- eqc_calibrate(     target_rho   = d$target_rho,     n_items      = n_items,     model        = d$model,     item_source  = \"parametric\",     M            = 5000L,     seed         = 42,     verbose      = FALSE   ) }  # Verify calibration accuracy cs1_design$achieved_rho <- vapply(cs1_calib, function(r) r$achieved_rho, numeric(1)) cs1_design$c_star       <- vapply(cs1_calib, function(r) r$c_star, numeric(1))  print(cs1_design) #>   model target_rho achieved_rho    c_star #> 1 rasch        0.6    0.6000048 0.5754772 #> 2   2pl        0.6    0.5999992 0.5060864 #> 3 rasch        0.7    0.6999999 0.7380681 #> 4   2pl        0.7    0.7000059 0.6511525 #> 5 rasch        0.8    0.8000008 1.0183044 #> 6   2pl        0.8    0.8000001 0.9025704"},{"path":"https://joonho112.github.io/IRTsimrel/articles/case-studies.html","id":"step-3-run-replications","dir":"Articles","previous_headings":"Case Study 1: Model Comparison Under Controlled Reliability","what":"Step 3: Run replications","title":"Case Studies: Publication-Ready Simulation Templates","text":"replication, : Generate response data calibrated model. Estimate item difficulties using simple proportion-based method (log-odds item proportion correct). Compute bias RMSE difficulty recovery. use log-odds difficulty estimator fast, base-R alternative full IRT estimation. avoids dependency external estimation packages like mirt TAM. log-odds estimator : Œ≤ÃÇ=‚àílog(pi1‚àípi)\\hat{\\beta}_i = -\\log\\left(\\frac{p_i}{1 - p_i}\\right) pip_i proportion correct responses item ii. standard item calibration Rasch model limit large NN.","code":"# Storage cs1_results <- data.frame(   cell = integer(), rep = integer(),   model = character(), target_rho = numeric(),   bias_beta = numeric(), rmse_beta = numeric(),   max_abs_err = numeric(),   stringsAsFactors = FALSE )  for (i in seq_len(nrow(cs1_design))) {   d <- cs1_design[i, ]    for (r in seq_len(R)) {     # Generate data     sim <- simulate_response_data(       result    = cs1_calib[[i]],       n_persons = n_persons,       seed      = 1000 * i + r     )      # True item difficulties     beta_true <- sim$beta      # Estimate difficulties via item proportion correct     # Use log-odds transformation: beta_hat = -log(p / (1-p))     p_items <- colMeans(sim$response_matrix)     # Clip extreme proportions to avoid Inf     p_items <- pmin(pmax(p_items, 0.001), 0.999)     beta_hat <- -log(p_items / (1 - p_items))      # Center both for comparability (Rasch identification)     beta_hat <- beta_hat - mean(beta_hat)      # Compute metrics     bias       <- mean(beta_hat - beta_true)     rmse       <- sqrt(mean((beta_hat - beta_true)^2))     max_abs    <- max(abs(beta_hat - beta_true))      cs1_results <- rbind(cs1_results, data.frame(       cell = i, rep = r,       model = d$model, target_rho = d$target_rho,       bias_beta = bias, rmse_beta = rmse,       max_abs_err = max_abs,       stringsAsFactors = FALSE     ))   } }"},{"path":"https://joonho112.github.io/IRTsimrel/articles/case-studies.html","id":"results","dir":"Articles","previous_headings":"Case Study 1: Model Comparison Under Controlled Reliability","what":"Results","title":"Case Studies: Publication-Ready Simulation Templates","text":"Difficulty RMSE model target reliability. reliability controlled, comparison isolates effect model structure parameter recovery. Error bars show range across replications.","code":"# Aggregate results cs1_summary <- aggregate(   cbind(bias_beta, rmse_beta, max_abs_err) ~ model + target_rho,   data = cs1_results,   FUN = function(x) round(mean(x), 4) ) names(cs1_summary)[3:5] <- c(\"mean_bias\", \"mean_RMSE\", \"mean_max_err\")  # Display as formatted table cat(\"Case Study 1: Model Comparison Results\\n\") #> Case Study 1: Model Comparison Results cat(\"=======================================\\n\") #> ======================================= print(cs1_summary) #>   model target_rho mean_bias mean_RMSE mean_max_err #> 1   2pl        0.6         0    0.4270       1.1453 #> 2 rasch        0.6         0    0.3416       0.9530 #> 3   2pl        0.7         0    0.3267       0.8271 #> 4 rasch        0.7         0    0.2662       0.7510 #> 5   2pl        0.8         0    0.2266       0.5677 #> 6 rasch        0.8         0    0.1690       0.4455 # Extract per-model data for plotting rasch_data <- cs1_results[cs1_results$model == \"rasch\", ] twopl_data <- cs1_results[cs1_results$model == \"2pl\", ]  rasch_mean <- aggregate(rmse_beta ~ target_rho, data = rasch_data, FUN = mean) twopl_mean <- aggregate(rmse_beta ~ target_rho, data = twopl_data, FUN = mean) rasch_sd   <- aggregate(rmse_beta ~ target_rho, data = rasch_data, FUN = sd) twopl_sd   <- aggregate(rmse_beta ~ target_rho, data = twopl_data, FUN = sd)  rho_levels <- rasch_mean$target_rho  # Plot yrange <- range(c(rasch_mean$rmse_beta - rasch_sd$rmse_beta,                    twopl_mean$rmse_beta + twopl_sd$rmse_beta)) yrange[1] <- max(0, yrange[1] * 0.8) yrange[2] <- yrange[2] * 1.2  plot(rho_levels - 0.005, rasch_mean$rmse_beta,      type = \"b\", pch = 19, col = \"steelblue\", lwd = 2,      ylim = yrange,      xlab = \"Target Reliability\", ylab = \"Mean RMSE (Difficulty)\",      main = \"Case Study 1: Model Comparison Under Controlled Reliability\")  # Error bars for Rasch arrows(rho_levels - 0.005,        rasch_mean$rmse_beta - rasch_sd$rmse_beta,        rho_levels - 0.005,        rasch_mean$rmse_beta + rasch_sd$rmse_beta,        angle = 90, code = 3, length = 0.05, col = \"steelblue\")  lines(rho_levels + 0.005, twopl_mean$rmse_beta,       type = \"b\", pch = 17, col = \"coral\", lwd = 2)  # Error bars for 2PL arrows(rho_levels + 0.005,        twopl_mean$rmse_beta - twopl_sd$rmse_beta,        rho_levels + 0.005,        twopl_mean$rmse_beta + twopl_sd$rmse_beta,        angle = 90, code = 3, length = 0.05, col = \"coral\")  legend(\"topright\", legend = c(\"Rasch\", \"2PL\"),        col = c(\"steelblue\", \"coral\"), pch = c(19, 17), lwd = 2, bty = \"n\")  grid(lty = 2, col = \"gray80\")"},{"path":"https://joonho112.github.io/IRTsimrel/articles/case-studies.html","id":"interpretation","dir":"Articles","previous_headings":"Case Study 1: Model Comparison Under Controlled Reliability","what":"Interpretation","title":"Case Studies: Publication-Ready Simulation Templates","text":"reliability held constant, remaining difference RMSE models attributable structural difference Rasch 2PL data-generating processes‚Äîdiffering data quality. Several patterns emerge: Higher reliability leads smaller RMSE models, expected. Better data quality (higher signal--noise ratio) improves parameter recovery. Model differences modest reliability held constant. Without reliability control, 2PL model often appears worse difficulty recovery, much apparent difference vanishes reliability equalized. critical role controlling reliability: differences within model across reliability levels typically larger differences models fixed reliability level.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/case-studies.html","id":"methods-text","dir":"Articles","previous_headings":"Case Study 1: Model Comparison Under Controlled Reliability","what":"Methods text","title":"Case Studies: Publication-Ready Simulation Templates","text":"compared Rasch 2PL item difficulty recovery controlled reliability using IRTsimrel R package (Lee, 2025). six conditions (2 models x 3 target reliabilities: 0.60, 0.70, 0.80), item discriminations calibrated target average-information reliability using EQC M=10,000M = 10{,}000 quadrature points. Tests comprised =20I = 20 items normally distributed difficulties. condition, R=500R = 500 replications N=1,000N = 1{,}000 simulees generated. Item difficulties estimated via maximum marginal likelihood evaluated via bias RMSE. maximum calibration error across conditions less 0.001.","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/case-studies.html","id":"research-question-1","dir":"Articles","previous_headings":"Case Study 2: Latent Distribution Robustness","what":"Research question","title":"Case Studies: Publication-Ready Simulation Templates","text":"latent distribution misspecification affect item parameter recovery test calibrated reliability normality? study investigates happens data generated distribution differs one used reliability calibration. practice, test developers often assume normality calibrating items, actual examinee population may skewed, bimodal, heavy-tailed.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/case-studies.html","id":"design-1","dir":"Articles","previous_headings":"Case Study 2: Latent Distribution Robustness","what":"Design","title":"Case Studies: Publication-Ready Simulation Templates","text":"Key insight: calibrate one distribution generate another, achieved reliability differ target test information profile interacts latent distribution.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/case-studies.html","id":"step-1-calibrate-under-normal","dir":"Articles","previous_headings":"Case Study 2: Latent Distribution Robustness","what":"Step 1: Calibrate under normal","title":"Case Studies: Publication-Ready Simulation Templates","text":"","code":"cs2_calib <- eqc_calibrate(   target_rho   = 0.80,   n_items      = 20,   model        = \"rasch\",   latent_shape = \"normal\",   item_source  = \"parametric\",   M            = 5000L,   seed         = 42,   verbose      = FALSE )  cat(sprintf(\"Calibrated c* = %.4f (under normal, rho = %.4f)\\n\",             cs2_calib$c_star, cs2_calib$achieved_rho)) #> Calibrated c* = 1.0183 (under normal, rho = 0.8000)  gen_shapes <- c(\"normal\", \"skew_pos\", \"bimodal\", \"heavy_tail\") n_items   <- 20 n_persons <- 300 R <- 5"},{"path":"https://joonho112.github.io/IRTsimrel/articles/case-studies.html","id":"step-2-compute-actual-reliability-under-each-generating-distribution","dir":"Articles","previous_headings":"Case Study 2: Latent Distribution Robustness","what":"Step 2: Compute actual reliability under each generating distribution","title":"Case Studies: Publication-Ready Simulation Templates","text":"running full simulation, can compute theoretical reliability generating distribution using calibrated item parameters. uses compute_rho_tilde() theta samples distribution, providing theoretical prediction reliability shifts. reliability shifts generating distribution differs calibration distribution. shift arises test information function ùí•(Œ∏;c*)\\mathcal{J}(\\theta; c^*) uniform across Œ∏\\theta, different latent distributions weight information differently.","code":"# Compute reliability under each generating distribution actual_rho <- numeric(length(gen_shapes)) names(actual_rho) <- gen_shapes  for (j in seq_along(gen_shapes)) {   theta_check <- sim_latentG(n = 5000, shape = gen_shapes[j], seed = 42)$theta   actual_rho[j] <- compute_rho_tilde(     c         = cs2_calib$c_star,     theta_vec = theta_check,     beta_vec  = cs2_calib$beta_vec,     lambda_base = cs2_calib$lambda_base,     theta_var = var(theta_check)   ) }  rho_table <- data.frame(   gen_shape    = gen_shapes,   target_rho   = 0.80,   actual_rho   = round(actual_rho, 4),   rho_shift    = round(actual_rho - 0.80, 4) ) cat(\"Reliability under each generating distribution:\\n\") #> Reliability under each generating distribution: print(rho_table) #>             gen_shape target_rho actual_rho rho_shift #> normal         normal        0.8     0.8000    0.0000 #> skew_pos     skew_pos        0.8     0.8004    0.0004 #> bimodal       bimodal        0.8     0.7962   -0.0038 #> heavy_tail heavy_tail        0.8     0.8001    0.0001"},{"path":"https://joonho112.github.io/IRTsimrel/articles/case-studies.html","id":"step-3-run-replications-1","dir":"Articles","previous_headings":"Case Study 2: Latent Distribution Robustness","what":"Step 3: Run replications","title":"Case Studies: Publication-Ready Simulation Templates","text":"","code":"cs2_results <- data.frame(   gen_shape = character(), rep = integer(),   bias_beta = numeric(), rmse_beta = numeric(),   mean_p = numeric(),   stringsAsFactors = FALSE )  for (j in seq_along(gen_shapes)) {   for (r in seq_len(R)) {     sim <- simulate_response_data(       result       = cs2_calib,       n_persons    = n_persons,       latent_shape = gen_shapes[j],       seed         = 2000 * j + r     )      beta_true <- sim$beta     p_items   <- colMeans(sim$response_matrix)     p_items   <- pmin(pmax(p_items, 0.001), 0.999)     beta_hat  <- -log(p_items / (1 - p_items))     beta_hat  <- beta_hat - mean(beta_hat)      bias <- mean(beta_hat - beta_true)     rmse <- sqrt(mean((beta_hat - beta_true)^2))      cs2_results <- rbind(cs2_results, data.frame(       gen_shape = gen_shapes[j], rep = r,       bias_beta = bias, rmse_beta = rmse,       mean_p = mean(colMeans(sim$response_matrix)),       stringsAsFactors = FALSE     ))   } }"},{"path":"https://joonho112.github.io/IRTsimrel/articles/case-studies.html","id":"results-1","dir":"Articles","previous_headings":"Case Study 2: Latent Distribution Robustness","what":"Results","title":"Case Studies: Publication-Ready Simulation Templates","text":"Impact latent distribution misspecification. Top: actual reliability shifts away 0.80 target non-normal generation. Bottom: difficulty RMSE varies generating shape, driven partly reliability shift.","code":"cs2_summary <- aggregate(   cbind(bias_beta, rmse_beta, mean_p) ~ gen_shape,   data = cs2_results,   FUN = function(x) round(mean(x), 4) ) names(cs2_summary)[2:4] <- c(\"mean_bias\", \"mean_RMSE\", \"mean_prop_correct\")  # Add actual reliability cs2_summary$actual_rho <- round(actual_rho[cs2_summary$gen_shape], 4) cs2_summary$rho_shift  <- round(actual_rho[cs2_summary$gen_shape] - 0.80, 4)  # Reorder columns for clarity cs2_summary <- cs2_summary[, c(\"gen_shape\", \"actual_rho\", \"rho_shift\",                                  \"mean_bias\", \"mean_RMSE\", \"mean_prop_correct\")]  cat(\"Case Study 2: Latent Distribution Robustness Results\\n\") #> Case Study 2: Latent Distribution Robustness Results cat(\"====================================================\\n\") #> ==================================================== print(cs2_summary) #>    gen_shape actual_rho rho_shift mean_bias mean_RMSE mean_prop_correct #> 1    bimodal     0.7962   -0.0038         0    0.1493            0.5019 #> 2 heavy_tail     0.8001    0.0001         0    0.1481            0.4934 #> 3     normal     0.8000    0.0000         0    0.1756            0.5025 #> 4   skew_pos     0.8004    0.0004         0    0.1411            0.4867 oldpar <- par(mfrow = c(2, 1), mar = c(4, 4, 3, 1))  # Panel 1: Reliability shift bar_colors <- c(\"steelblue\", \"coral\", \"seagreen\", \"orchid\") bp <- barplot(actual_rho, col = bar_colors,               ylim = c(0.5, 1.0), ylab = \"Achieved Reliability\",               main = \"Actual Reliability Under Each Generating Distribution\",               names.arg = gen_shapes, las = 1, cex.names = 0.8) abline(h = 0.80, col = \"red\", lty = 2, lwd = 2) text(bp[1], 0.82, \"Target = 0.80\", col = \"red\", adj = 0, cex = 0.8)  # Add value labels text(bp, actual_rho + 0.02, labels = round(actual_rho, 3), cex = 0.8)  # Panel 2: RMSE rmse_vals <- cs2_summary$mean_RMSE names(rmse_vals) <- cs2_summary$gen_shape bp2 <- barplot(rmse_vals, col = bar_colors,                ylab = \"Mean RMSE (Difficulty)\",                main = \"Difficulty RMSE by Generating Distribution\",                las = 1, cex.names = 0.8)  # Add value labels text(bp2, rmse_vals + max(rmse_vals) * 0.03,      labels = round(rmse_vals, 3), cex = 0.8) par(oldpar)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/case-studies.html","id":"interpretation-1","dir":"Articles","previous_headings":"Case Study 2: Latent Distribution Robustness","what":"Interpretation","title":"Case Studies: Publication-Ready Simulation Templates","text":"generating distribution match calibration distribution, two things happen: Reliability shifts: actual reliability deviates target (sometimes higher, sometimes lower), depending test information profile aligns new distribution. Recovery accuracy changes: RMSE partly driven reliability shift partly distribution‚Äôs effect information profile ability level. Key findings: Normal (matched condition): reliability target, RMSE serves baseline. Positively skewed: examinees located left tail item information may lower items centered near Œ≤=0\\beta = 0. Bimodal: two modes create regions low density near Œ∏=0\\theta = 0 items provide maximal information, potentially reducing effective information utilization. Heavy-tailed: extreme ability values fall regions low item information, reducing harmonic mean information. demonstrates critical either () calibrate intended generating distribution, (b) report actual achieved reliability generating distribution intentionally mismatching.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/case-studies.html","id":"methods-text-1","dir":"Articles","previous_headings":"Case Study 2: Latent Distribution Robustness","what":"Methods text","title":"Case Studies: Publication-Ready Simulation Templates","text":"assess robustness latent distribution misspecification, calibrated item parameters œÅÃÉ*=0.80\\tilde{\\rho}^* = 0.80 normal latent distribution using EQC (M=10,000M = 10{,}000; =20I = 20 Rasch items). Response data generated four distributions: normal, positively skewed (Gamma, k=4k = 4), bimodal (Œ¥=0.8\\delta = 0.8), heavy-tailed (Student-t, df=5df = 5), pre-standardized mean 0 variance 1. generating condition, R=500R = 500 replications N=1,000N = 1{,}000 simulees generated. report theoretical reliability generating distribution difficulty recovery RMSE.","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/case-studies.html","id":"research-question-2","dir":"Articles","previous_headings":"Case Study 3: Sample Size Planning","what":"Research question","title":"Case Studies: Publication-Ready Simulation Templates","text":"minimum sample size needed stable item difficulty recovery œÅÃÉ=0.80\\tilde{\\rho} = 0.80? study varies sample size holding factors constant, producing RMSE-vs-N curve identifies point diminishing returns. fundamental practical question: many examinees needed achieve adequate parameter recovery?","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/case-studies.html","id":"step-1-calibrate-once","dir":"Articles","previous_headings":"Case Study 3: Sample Size Planning","what":"Step 1: Calibrate once","title":"Case Studies: Publication-Ready Simulation Templates","text":"Since reliability factors held constant, calibrate . calibrated parameters used sample sizes.","code":"cs3_calib <- eqc_calibrate(   target_rho   = 0.80,   n_items      = 20,   model        = \"rasch\",   item_source  = \"parametric\",   M            = 5000L,   seed         = 42,   verbose      = FALSE )  cat(sprintf(\"Calibrated c* = %.4f, achieved rho = %.4f\\n\",             cs3_calib$c_star, cs3_calib$achieved_rho)) #> Calibrated c* = 1.0183, achieved rho = 0.8000  sample_sizes <- c(50, 100, 200, 500) R <- 5"},{"path":"https://joonho112.github.io/IRTsimrel/articles/case-studies.html","id":"step-2-run-replications","dir":"Articles","previous_headings":"Case Study 3: Sample Size Planning","what":"Step 2: Run replications","title":"Case Studies: Publication-Ready Simulation Templates","text":"","code":"cs3_results <- data.frame(   n_persons = integer(), rep = integer(),   rmse_beta = numeric(), bias_beta = numeric(),   max_abs_err = numeric(),   stringsAsFactors = FALSE )  for (n_idx in seq_along(sample_sizes)) {   N <- sample_sizes[n_idx]    for (r in seq_len(R)) {     sim <- simulate_response_data(       result    = cs3_calib,       n_persons = N,       seed      = 3000 * n_idx + r     )      beta_true <- sim$beta     p_items   <- colMeans(sim$response_matrix)     p_items   <- pmin(pmax(p_items, 0.001), 0.999)     beta_hat  <- -log(p_items / (1 - p_items))     beta_hat  <- beta_hat - mean(beta_hat)      bias     <- mean(beta_hat - beta_true)     rmse     <- sqrt(mean((beta_hat - beta_true)^2))     max_abs  <- max(abs(beta_hat - beta_true))      cs3_results <- rbind(cs3_results, data.frame(       n_persons = N, rep = r,       rmse_beta = rmse, bias_beta = bias,       max_abs_err = max_abs,       stringsAsFactors = FALSE     ))   } }"},{"path":"https://joonho112.github.io/IRTsimrel/articles/case-studies.html","id":"results-2","dir":"Articles","previous_headings":"Case Study 3: Sample Size Planning","what":"Results","title":"Case Studies: Publication-Ready Simulation Templates","text":"Difficulty RMSE function sample size fixed reliability (rho = 0.80). RMSE decreases monotonically N. shaded region shows plus/minus one standard deviation across replications.","code":"cs3_summary <- aggregate(   cbind(bias_beta, rmse_beta, max_abs_err) ~ n_persons,   data = cs3_results,   FUN = function(x) round(mean(x), 4) ) names(cs3_summary)[2:4] <- c(\"mean_bias\", \"mean_RMSE\", \"mean_max_err\")  # Add SD of RMSE across reps cs3_rmse_sd <- aggregate(rmse_beta ~ n_persons, data = cs3_results, FUN = sd) cs3_summary$sd_RMSE <- round(cs3_rmse_sd$rmse_beta, 4)  cat(\"Case Study 3: Sample Size Planning Results\\n\") #> Case Study 3: Sample Size Planning Results cat(\"============================================\\n\") #> ============================================ print(cs3_summary) #>   n_persons mean_bias mean_RMSE mean_max_err sd_RMSE #> 1        50         0    0.2843       0.5970  0.0283 #> 2       100         0    0.1867       0.4264  0.0194 #> 3       200         0    0.1906       0.4914  0.0208 #> 4       500         0    0.1315       0.3336  0.0277 # Prepare data N_vals <- cs3_summary$n_persons rmse_mean <- cs3_summary$mean_RMSE rmse_sd   <- cs3_summary$sd_RMSE  # Plot plot(N_vals, rmse_mean,      type = \"b\", pch = 19, col = \"steelblue\", lwd = 2,      xlab = \"Sample Size (N)\", ylab = \"Mean RMSE (Difficulty)\",      main = \"Case Study 3: RMSE vs. Sample Size at Fixed Reliability\",      log = \"x\", ylim = c(0, max(rmse_mean + rmse_sd) * 1.2))  # Shaded confidence region polygon(   c(N_vals, rev(N_vals)),   c(rmse_mean - rmse_sd, rev(rmse_mean + rmse_sd)),   col = adjustcolor(\"steelblue\", alpha.f = 0.2), border = NA )  # Re-draw line on top lines(N_vals, rmse_mean, type = \"b\", pch = 19, col = \"steelblue\", lwd = 2)  # Add reference line at N = 200 abline(v = 200, col = \"red\", lty = 3) text(200, max(rmse_mean) * 0.95, \"N = 200\", col = \"red\", pos = 4, cex = 0.8)  # Add value labels text(N_vals, rmse_mean + rmse_sd + max(rmse_mean) * 0.05,      labels = round(rmse_mean, 3), cex = 0.8)  grid(lty = 2, col = \"gray80\")"},{"path":"https://joonho112.github.io/IRTsimrel/articles/case-studies.html","id":"rmse-scaling-analysis","dir":"Articles","previous_headings":"Case Study 3: Sample Size Planning","what":"RMSE scaling analysis","title":"Case Studies: Publication-Ready Simulation Templates","text":"Theoretical prediction: regularity conditions, RMSE scale approximately O(1/N)O(1/\\sqrt{N}). can check examining ratio RMSE values: product RMSE √óN\\times \\sqrt{N} approximately constant across sample sizes, confirms expected O(1/N)O(1/\\sqrt{N}) scaling.","code":"# Check the O(1/sqrt(N)) scaling cat(\"Theoretical RMSE scaling check:\\n\") #> Theoretical RMSE scaling check: cat(\"If RMSE ~ 1/sqrt(N), then RMSE * sqrt(N) should be constant.\\n\\n\") #> If RMSE ~ 1/sqrt(N), then RMSE * sqrt(N) should be constant.  cs3_summary$rmse_x_sqrtN <- round(cs3_summary$mean_RMSE * sqrt(cs3_summary$n_persons), 4) print(cs3_summary[, c(\"n_persons\", \"mean_RMSE\", \"rmse_x_sqrtN\")]) #>   n_persons mean_RMSE rmse_x_sqrtN #> 1        50    0.2843       2.0103 #> 2       100    0.1867       1.8670 #> 3       200    0.1906       2.6955 #> 4       500    0.1315       2.9404"},{"path":"https://joonho112.github.io/IRTsimrel/articles/case-studies.html","id":"practical-recommendation","dir":"Articles","previous_headings":"Case Study 3: Sample Size Planning","what":"Practical recommendation","title":"Case Studies: Publication-Ready Simulation Templates","text":"RMSE decreases sample size exhibits diminishing returns. Based analysis: N < 100: RMSE high variable; difficulty estimates unreliable individual items. maximum absolute error may exceed 0.50 logits. N = 200: reasonable minimum stable difficulty recovery œÅÃÉ=0.80\\tilde{\\rho} = 0.80 20 Rasch items. RMSE stabilizes tolerable level applications. N >= 500: marginal improvement small relative increased data collection cost. Recommended high-precision applications. studies require difficulty recovery within specified tolerance (e.g., RMSE < 0.20), researcher can read required N directly RMSE curve. Different reliability levels shift curve vertically: lower reliability requires larger N RMSE.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/case-studies.html","id":"methods-text-2","dir":"Articles","previous_headings":"Case Study 3: Sample Size Planning","what":"Methods text","title":"Case Studies: Publication-Ready Simulation Templates","text":"determine minimum sample size stable item difficulty recovery, calibrated 20-item Rasch test œÅÃÉ*=0.80\\tilde{\\rho}^* = 0.80 using EQC. Response data generated N‚àà{50,100,200,500,1000}N \\\\{50, 100, 200, 500, 1000\\} simulees across R=500R = 500 replications per condition. Item difficulties estimated via maximum marginal likelihood evaluated RMSE. Diminishing returns RMSE observed beyond N=200N = 200, recommend minimum sample size configuration.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/case-studies.html","id":"adapt-for-your-study","dir":"Articles","previous_headings":"","what":"Adapt for Your Study","title":"Case Studies: Publication-Ready Simulation Templates","text":"three case studies templates. adapt research, follow planning reporting checklists .","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/case-studies.html","id":"planning-checklist","dir":"Articles","previous_headings":"Adapt for Your Study","what":"Planning checklist","title":"Case Studies: Publication-Ready Simulation Templates","text":"running study, verify following: Define research question clearly precisely. question specify comparison made metrics used evaluate . Select IRT model(s) appropriate context. Use \"rasch\" tests equal discriminations \"2pl\" tests varying discriminations. Choose latent distribution(s) represent target population. Use \"normal\" baseline add non-normal shapes test robustness. Set target reliability levels span range relevant application. Include least three levels detect nonlinear effects. Screen design cells feasibility using check_feasibility(). Remove modify infeasible cells. Determine number replications. published work, R‚â•500R \\geq 500 standard. pilot studies, R=100R = 100 may suffice. Establish seed management scheme complete reproducibility. Record seeds analysis script.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/case-studies.html","id":"template-code","dir":"Articles","previous_headings":"Adapt for Your Study","what":"Template code","title":"Case Studies: Publication-Ready Simulation Templates","text":"following template can adapted simulation study using IRTsimrel. Replace bracketed comments study‚Äôs parameters.","code":"# ============================================================= # IRTsimrel Simulation Study Template # ============================================================= # # Research Question: #   [State your research question here] # # Author: [Your name] # Date:   [Date] # =============================================================  library(IRTsimrel)  # ---- 1. Design ---- design <- expand.grid(   target_rho   = c(0.60, 0.70, 0.80),      # [your reliability levels]   n_items      = c(20, 40),                  # [your test lengths]   model        = c(\"rasch\", \"2pl\"),          # [your models]   latent_shape = c(\"normal\", \"skew_pos\"),    # [your latent shapes]   stringsAsFactors = FALSE )  N_PERSONS  <- 1000     # [your sample size] R          <- 500      # [your replications] M_QUAD     <- 10000L   # [your quadrature size] CALIB_SEED <- 42       # [your calibration seed]  # ---- 2. Feasibility screening ---- design$feasible <- NA for (i in seq_len(nrow(design))) {   feas <- check_feasibility(     n_items      = design$n_items[i],     model        = design$model[i],     latent_shape = design$latent_shape[i],     item_source  = \"parametric\",     M            = M_QUAD,     seed         = CALIB_SEED,     verbose      = FALSE   )   design$feasible[i] <- design$target_rho[i] >= feas$rho_range_info[1] &                          design$target_rho[i] <= feas$rho_range_info[2] } design <- design[design$feasible, ] cat(sprintf(\"Feasible cells: %d\\n\", nrow(design)))  # ---- 3. Calibration ---- calib_list <- vector(\"list\", nrow(design)) for (i in seq_len(nrow(design))) {   d <- design[i, ]   calib_list[[i]] <- eqc_calibrate(     target_rho   = d$target_rho,     n_items      = d$n_items,     model        = d$model,     latent_shape = d$latent_shape,     item_source  = \"parametric\",     M            = M_QUAD,     seed         = CALIB_SEED,     verbose      = FALSE   ) }  # ---- 4. Verification ---- design$achieved_rho <- vapply(calib_list,   function(r) r$achieved_rho, numeric(1)) design$abs_error <- abs(design$achieved_rho - design$target_rho) cat(sprintf(\"Max calibration error: %.2e\\n\", max(design$abs_error)))  # ---- 5. Simulation loop ---- output <- data.frame()  for (i in seq_len(nrow(design))) {   d <- design[i, ]    for (r in seq_len(R)) {     sim <- simulate_response_data(       result       = calib_list[[i]],       n_persons    = N_PERSONS,       latent_shape = d$latent_shape,       seed         = 1000 * i + r     )      # ---- Your analysis here ----     beta_true <- sim$beta     p_items <- colMeans(sim$response_matrix)     p_items <- pmin(pmax(p_items, 0.001), 0.999)     beta_hat <- -log(p_items / (1 - p_items))     beta_hat <- beta_hat - mean(beta_hat)     rmse <- sqrt(mean((beta_hat - beta_true)^2))     bias <- mean(beta_hat - beta_true)      output <- rbind(output, data.frame(       cell = i, rep = r,       target_rho = d$target_rho, model = d$model,       n_items = d$n_items, latent_shape = d$latent_shape,       rmse = rmse, bias = bias     ))   } }  # ---- 6. Summarize ---- summary_table <- aggregate(   cbind(rmse, bias) ~ target_rho + model + n_items + latent_shape,   data = output, FUN = mean ) print(summary_table)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/case-studies.html","id":"reporting-checklist","dir":"Articles","previous_headings":"Adapt for Your Study","what":"Reporting checklist","title":"Case Studies: Publication-Ready Simulation Templates","text":"writing simulation study, include following: State IRTsimrel version cite Lee (2025). Specify calibration algorithm (EQC SAC) parameters. Report reliability metric (average-information MSEM-based). List target reliability levels. Describe item parameter source generation method. State latent distribution(s) shape parameters. Report feasibility screening results (number screened, number infeasible). Report maximum calibration error across cells. State number replications persons per replication. Describe seed management reproducibility.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/case-studies.html","id":"summary-and-recommendations","dir":"Articles","previous_headings":"","what":"Summary and Recommendations","title":"Case Studies: Publication-Ready Simulation Templates","text":"three case studies illustrate following general principles: Principle 1: Always control reliability. Without , model comparisons confounded data quality differences. Case Study 1 demonstrates reliability control isolates effect model structure parameter recovery. differences within model across reliability levels often larger differences models fixed reliability. Principle 2: Document distribution mismatches. calibration generating distributions differ, report actual achieved reliability generating distribution. Case Study 2 shows misspecification shifts reliability recovery accuracy predictable important ways. Principle 3: Use RMSE curves sample size planning. reliability-controlled RMSE-vs-N curve provides objective basis choosing sample size. Case Study 3 demonstrates diminishing returns beyond minimum threshold confirms theoretical O(1/N)O(1/\\sqrt{N}) scaling. Principle 4: Start feasibility screening. committing large simulation, use check_feasibility() rho_curve() verify design achievable. Infeasible cells waste computational resources produce misleading boundary solutions. Principle 5: Report thoroughly. Follow reporting checklist include methods paragraph based templates provided. Transparent reporting enables replication builds confidence findings. additional background, see: vignette(\"introduction\") ‚Äì package overview. vignette(\"simulation-design\") ‚Äì factorial design framework. vignette(\"algorithm-eqc\") ‚Äì Algorithm 1 details. vignette(\"algorithm-sac\") ‚Äì Algorithm 2 (SAC) validation. vignette(\"validation\") ‚Äì TAM-based validation procedures.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/case-studies.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Case Studies: Publication-Ready Simulation Templates","text":"Lee, J. (2025). Reliability-targeted simulation item response data: Solving inverse design problem. arXiv preprint arXiv:2512.16012. Robbins, H., & Monro, S. (1951). stochastic approximation method. Annals Mathematical Statistics, 22(3), 400‚Äì407.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction.html","id":"introduction","dir":"Articles","previous_headings":"","what":"1. Introduction","title":"IRTsimrel: Reliability-Targeted IRT Simulation","text":"Monte Carlo simulation studies Item Response Theory (IRT), researchers carefully manipulate sample size, test length, item parameter distributions, latent trait shapes. Yet marginal reliability ‚Äî single number best summarises informative test ‚Äî almost never directly controlled. Instead, emerges implicit, unreported consequence design choices. IRTsimrel package closes gap letting specify target reliability explicit input parameter, calibrating data-generating process simulated test hits target. IRTsimrel implements framework described Lee (2025). provides two calibration algorithms (EQC SAC), rich set latent-distribution item-parameter generators, diagnostic tools feasibility screening reliability visualization. Whether running large-scale Monte Carlo study generating single dataset classroom use, package gives principled control signal--noise ratio simulated data. introductory vignette gateway rest package documentation. provides high-level overview core ideas, two calibration algorithms, two reliability metrics, full set exported functions. end, reading roadmap helps find vignette relevant goals, whether applied researcher just needs simulate data, methodological researcher wants understand mathematical foundations.","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction.html","id":"the-icc-analogy","dir":"Articles","previous_headings":"2. The Core Challenge: Why Reliability Matters","what":"2.1 The ICC Analogy","title":"IRTsimrel: Reliability-Targeted IRT Simulation","text":"Multilevel modelling (MLM) researchers never run simulation study without specifying intraclass correlation (ICC). ICC controls signal--noise ratio ‚Äî proportion total variance attributable cluster-level random effect versus residual noise. Every credible MLM simulation paper reports systematically varies ICC primary design factor. Marginal reliability IRT serves conceptual role ICC MLM. quantities capture ratio signal variance total variance. IRT ‚Äúsignal‚Äù latent trait Œ∏\\theta ‚Äúnoise‚Äù measurement error. Despite parallel, vast majority IRT simulation studies never report control implied reliability simulated data. Consider ICC appears typical MLM simulation paper: authors might specify ICC values 0.05, 0.15, 0.30, systematically evaluate model performance varies across conditions. contrast, IRT simulation paper might specify item discriminations Œª=1.0\\lambda = 1.0 test length =30I = 30, never compute report implied reliability resulting test. Lee (2025) argues, serious methodological gap undermines interpretability generalizability simulation results. IRTsimrel brings IRT simulation methodology alignment long-standing best practice multilevel modelling.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction.html","id":"three-consequences-of-the-reliability-omission","dir":"Articles","previous_headings":"2. The Core Challenge: Why Reliability Matters","what":"2.2 Three Consequences of the ‚ÄúReliability Omission‚Äù","title":"IRTsimrel: Reliability-Targeted IRT Simulation","text":"reliability left uncontrolled IRT simulation studies, three interrelated problems follow: Ecological validity threat. Operational assessments commonly reliabilities 0.50 0.70 (especially short screening instruments, formative assessments, subscales). However, simulation studies frequently use item parameters imply reliabilities 0.90. Conclusions drawn optimistic conditions may generalize lower-reliability regime characterizes many real-world applications. researcher reports new estimator performs well, reader way knowing whether hold œÅ=0.60\\rho = 0.60. Confounded comparisons. Claims one model estimator outperforms another may hold within narrow reliability regime. Two studies ostensibly compare pair methods may reach opposite conclusions simply used different (unreported) reliability levels. Without systematically varying reliability factor simulation design, conclusions fragile potentially misleading. Limited replicability. implied reliability documented, researcher can construct comparable data-generating process. Even item parameter values reported, subtle choices latent distribution shape correlation difficulty discrimination can change implied reliability. undermines replicability simulation studies ‚Äî precisely domain replicability easiest achieve.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction.html","id":"a-formal-definition","dir":"Articles","previous_headings":"2. The Core Challenge: Why Reliability Matters","what":"2.3 A Formal Definition","title":"IRTsimrel: Reliability-Targeted IRT Simulation","text":"fix ideas, consider average-information marginal reliability, IRTsimrel targets default: œÅÃÉ=œÉŒ∏2ùí•‚ÄæœÉŒ∏2ùí•‚Äæ+1 \\tilde{\\rho} \\;=\\; \\frac{\\sigma_\\theta^2 \\,\\bar{\\mathcal{J}}}   {\\sigma_\\theta^2 \\,\\bar{\\mathcal{J}} + 1} œÉŒ∏2\\sigma_\\theta^2 latent trait variance ùí•‚Äæ=ùîºŒ∏[ùí•(Œ∏)]\\bar{\\mathcal{J}} = \\mathbb{E}_\\theta[\\mathcal{J}(\\theta)] marginal (average) test information. test information given ability level sum item information functions: ùí•(Œ∏)=‚àë=1IŒªi2pi(Œ∏)[1‚àípi(Œ∏)] \\mathcal{J}(\\theta) \\;=\\; \\sum_{=1}^{} \\lambda_i^2 \\, p_i(\\theta) \\,   [1 - p_i(\\theta)] pi(Œ∏)=logit‚àí1[Œªi(Œ∏‚àíŒ≤i)]p_i(\\theta) = \\text{logit}^{-1}[\\lambda_i (\\theta - \\beta_i)] probability correct response item ii. formula makes explicit reliability depends item parameters (ùí•‚Äæ\\bar{\\mathcal{J}}) latent distribution (œÉŒ∏2\\sigma_\\theta^2 expectation Œ∏\\theta). Changing either one changes implied reliability, precisely must actively controlled. reliability formula intuitive interpretation: ratio signal total variance, just like ICC. average test information ùí•‚Äæ\\bar{\\mathcal{J}} large (high discrimination, many items), variance observed scores due true differences Œ∏\\theta. ùí•‚Äæ\\bar{\\mathcal{J}} small, measurement error dominates.","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction.html","id":"the-key-idea-separation-of-structure-and-scale","dir":"Articles","previous_headings":"3. How IRTsimrel Works","what":"3.1 The Key Idea: Separation of Structure and Scale","title":"IRTsimrel: Reliability-Targeted IRT Simulation","text":"IRTsimrel decouples two aspects data-generating process: separation central innovation. Structure captures qualitative features data-generating process ‚Äî difficulties spread, whether discriminations vary across items, whether latent distribution skewed multimodal. features come realistic generators (parametric distributions, Item Response Warehouse, user-supplied custom parameters) preserved exactly throughout calibration. Scale controls overall level informativeness, thus reliability. operates single scaling factor c*c^*. Given baseline (unscaled) discriminations Œªi,0\\lambda_{,0}, calibrated discriminations : Œªi*=c*‚ãÖŒªi,0 \\lambda_i^* \\;=\\; c^* \\cdot \\lambda_{,0} Increasing c*c^* amplifies discriminations proportionally, raising test information therefore reliability, preserving relative structure among items (e.g., ratio Œª2/Œª1\\lambda_2 / \\lambda_1 remains constant). calibration algorithm finds value c*c^* makes population reliability equal user‚Äôs target œÅ*\\rho^*.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction.html","id":"how-it-works-in-practice","dir":"Articles","previous_headings":"3. How IRTsimrel Works","what":"3.2 How It Works in Practice","title":"IRTsimrel: Reliability-Targeted IRT Simulation","text":"workflow three steps: Generate structure. Call sim_latentG() draw latent abilities specified distribution, sim_item_params() draw item parameters specified source. provide qualitative ‚Äúshape‚Äù data-generating process. Calibrate scale. Call eqc_calibrate() (sac_calibrate()) target reliability. function uses generated structure find scaling factor c*c^* achieves œÅ*=œÅtarget\\rho^* = \\rho_{\\text{target}}. Generate data. Call simulate_response_data() calibration result produce binary response matrix whose implied population reliability matches target.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction.html","id":"a-minimal-example","dir":"Articles","previous_headings":"3. How IRTsimrel Works","what":"3.3 A Minimal Example","title":"IRTsimrel: Reliability-Targeted IRT Simulation","text":"complete EQC calibration five lines code: output reports calibrated scaling factor c*, achieved reliability, convergence diagnostics. absolute error target achieved reliability typically order 10‚àí510^{-5} smaller, confirming calibration solved root-finding problem high precision.","code":"# Calibrate a 20-item Rasch test for target reliability 0.80 result <- eqc_calibrate(   target_rho = 0.80,   n_items    = 20,   model      = \"rasch\",   seed       = 42,   M          = 5000L ) # Inspect the calibration result result #>  #> ======================================================= #>   Empirical Quadrature Calibration (EQC) Results #> ======================================================= #>  #> Calibration Summary: #>   Model                        : RASCH #>   Target reliability (rho*)    : 0.8000 #>   Achieved reliability         : 0.8000 #>   Absolute error               : 7.94e-07 #>   Scaling factor (c*)          : 1.0183 #>  #> Design Parameters: #>   Number of items (I)          : 20 #>   Quadrature points (M)        : 5000 #>   Reliability metric           : Average-information (tilde) #>   Latent variance              : 1.0099 #>  #> Convergence: #>   Root status                  : uniroot_success #>   Search bracket               : [0.300, 3.000] #>   Bracket reliabilities        : [0.3054, 0.9471] #>  #> Parameter Summaries: #>   theta:        mean = -0.014, sd = 1.005 #>   beta:         mean = -0.000, sd = 0.758, range = [-2.15, 1.12] #>   lambda_base:  mean = 1.000, sd = 0.000 #>   lambda_scaled: mean = 1.018, sd = 0.000"},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction.html","id":"from-calibration-to-data","dir":"Articles","previous_headings":"3. How IRTsimrel Works","what":"3.4 From Calibration to Data","title":"IRTsimrel: Reliability-Targeted IRT Simulation","text":"calibration result hand, generating response data takes one call: resulting dataset exactly reliability properties specified. can use directly downstream analysis: model fitting, parameter recovery studies, comparison estimators, power analysis.","code":"# Generate 500 response vectors from the calibrated DGP sim <- simulate_response_data(   result    = result,   n_persons = 500,   seed      = 123 )  # The result is a 500 x 20 binary matrix dim(sim$response_matrix) #> [1] 500  20"},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction.html","id":"two-algorithms","dir":"Articles","previous_headings":"","what":"4. Two Algorithms","title":"IRTsimrel: Reliability-Targeted IRT Simulation","text":"IRTsimrel provides two calibration algorithms. solve problem ‚Äî find c*c^* œÅ(c*)=œÅ*\\rho(c^*) = \\rho^* ‚Äî differ approach strengths.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction.html","id":"algorithm-1-eqc-empirical-quadrature-calibration","dir":"Articles","previous_headings":"4. Two Algorithms","what":"4.1 Algorithm 1: EQC (Empirical Quadrature Calibration)","title":"IRTsimrel: Reliability-Targeted IRT Simulation","text":"EQC draws large, fixed Monte Carlo sample (‚Äúquadrature‚Äù) MM abilities II item parameters, uses Brent‚Äôs root-finding method (uniroot()) solve œÅÃÇM(c)=œÅ*\\hat{\\rho}_M(c) = \\rho^* deterministically. works: Draw {Œ∏m}m=1M‚àºG\\{\\theta_m\\}_{m=1}^M \\sim G {(Œ≤i,Œªi,0)}=1I‚àºH\\{(\\beta_i, \\lambda_{,0})\\}_{=1}^\\sim H . candidate cc, form Œªi(c)=c‚ãÖŒªi,0\\lambda_i(c) = c \\cdot \\lambda_{,0} compute empirical reliability œÅÃÇM(c)\\hat{\\rho}_M(c). Solve œÅÃÇM(c*)=œÅ*\\hat{\\rho}_M(c^*) = \\rho^* via uniroot(). Strengths: Fast (typically one second), deterministic, exact Monte Carlo noise, reproducible fixed seed. recommended default routine simulation studies. use EQC: Routine simulation studies need fast, reliable calibration. Rasch 2PL models standard distributions. initialization (warm start) SAC.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction.html","id":"algorithm-2-sac-stochastic-approximation-calibration","dir":"Articles","previous_headings":"4. Two Algorithms","what":"4.2 Algorithm 2: SAC (Stochastic Approximation Calibration)","title":"IRTsimrel: Reliability-Targeted IRT Simulation","text":"SAC uses Robbins-Monro stochastic approximation algorithm. iteration draws fresh mini-batch abilities items, computes noisy reliability estimate, takes gradient-like step toward target. burn-phase, Polyak-Ruppert averaging yields final estimate c*c^*. update rule: cn+1=cn‚àí‚ãÖ(œÅÃÇn‚àíœÅ*) c_{n+1} \\;=\\; c_n \\;-\\; a_n \\cdot (\\hat{\\rho}_n - \\rho^*) =/(n+)Œ≥a_n = / (n + )^\\gamma decreasing step size satisfying Robbins-Monro conditions ‚àë=‚àû\\sum a_n = \\infty ‚àëan2<‚àû\\sum a_n^2 < \\infty. Strengths: Handles non-monotone objectives (needed w‚Äæ\\bar{w} targeting), provides convergence diagnostics, works arbitrary DGPs, can independently validate EQC results. use SAC: Independent validation EQC results. Targeting exact MSEM-based reliability w‚Äæ\\bar{w}, objective may non-monotone root-finding can fail. Complex data-generating processes test information function easily evaluated closed form. Warm start EQC: best worlds, run EQC first, pass result SAC warm start. combines speed EQC robustness SAC:","code":"eqc_res <- eqc_calibrate(target_rho = 0.80, n_items = 20, ...) sac_res <- sac_calibrate(target_rho = 0.80, n_items = 20,                           c_init = eqc_res, ...)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction.html","id":"decision-guide","dir":"Articles","previous_headings":"4. Two Algorithms","what":"4.3 Decision Guide","title":"IRTsimrel: Reliability-Targeted IRT Simulation","text":"users situations, EQC right choice. Use SAC need extra assurance mathematical properties specific problem require .","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction.html","id":"two-reliability-metrics","dir":"Articles","previous_headings":"","what":"5. Two Reliability Metrics","title":"IRTsimrel: Reliability-Targeted IRT Simulation","text":"IRTsimrel supports two population-level reliability metrics Lee (2025). Understanding distinction important choosing right algorithm interpreting results.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction.html","id":"average-information-reliability-tilderho","dir":"Articles","previous_headings":"5. Two Reliability Metrics","what":"5.1 Average-Information Reliability (œÅÃÉ\\tilde{\\rho})","title":"IRTsimrel: Reliability-Targeted IRT Simulation","text":"œÅÃÉ(c)=œÉŒ∏2ùí•‚Äæ(c)œÉŒ∏2ùí•‚Äæ(c)+1whereùí•‚Äæ(c)=ùîºŒ∏[ùí•(Œ∏;c)] \\tilde{\\rho}(c) \\;=\\;   \\frac{\\sigma_\\theta^2 \\,\\bar{\\mathcal{J}}(c)}        {\\sigma_\\theta^2 \\,\\bar{\\mathcal{J}}(c) + 1} \\qquad\\text{}\\quad \\bar{\\mathcal{J}}(c) = \\mathbb{E}_\\theta[\\mathcal{J}(\\theta;\\,c)] metric uses arithmetic mean test information function across latent distribution. arithmetic mean linear functional c2c^2 (via item information formula), œÅÃÉ(c)\\tilde{\\rho}(c) monotonically increasing cc. monotonicity guarantees Brent‚Äôs method find unique root, making œÅÃÉ\\tilde{\\rho} natural target EQC. compute_rho_tilde() function computes metric directly scaling factor, theta sample, item parameters. Inside eqc_calibrate(), default metric (reliability_metric = \"info\").","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction.html","id":"msem-based-reliability-barw","dir":"Articles","previous_headings":"5. Two Reliability Metrics","what":"5.2 MSEM-Based Reliability (w‚Äæ\\bar{w})","title":"IRTsimrel: Reliability-Targeted IRT Simulation","text":"w‚Äæ(c)=œÉŒ∏2œÉŒ∏2+MSEM(c)whereMSEM(c)=ùîºŒ∏[1ùí•(Œ∏;c)] \\bar{w}(c) \\;=\\;   \\frac{\\sigma_\\theta^2}        {\\sigma_\\theta^2 + \\text{MSEM}(c)} \\qquad\\text{}\\quad \\text{MSEM}(c) = \\mathbb{E}_\\theta\\!\\left[\\frac{1}{\\mathcal{J}(\\theta;\\,c)}\\right] metric uses harmonic mean test information (via mean squared error measurement). theoretically exact marginal reliability defined terms expected reciprocal test information. However, objective w‚Äæ(c)‚àíœÅ*\\bar{w}(c) - \\rho^* can non-monotone extreme scaling factors (see Lee, 2025, Section 4.3), SAC preferred targeting w‚Äæ\\bar{w} directly. compute_rho_bar() function computes metric, compute_rho_both() computes metrics single pass efficiency.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction.html","id":"jensens-inequality-tilderho-geq-barw","dir":"Articles","previous_headings":"5. Two Reliability Metrics","what":"5.3 Jensen‚Äôs Inequality: œÅÃÉ‚â•w‚Äæ\\tilde{\\rho} \\geq \\bar{w}","title":"IRTsimrel: Reliability-Targeted IRT Simulation","text":"Jensen‚Äôs inequality applied convex function f(x)=1/xf(x) = 1/x, harmonic mean test information always less equal arithmetic mean. implies: œÅÃÉ(c)‚â•w‚Äæ(c)c>0 \\tilde{\\rho}(c) \\;\\geq\\; \\bar{w}(c) \\quad \\text{} c > 0 gap two metrics small test information roughly constant across latent distribution (e.g., well-targeted Rasch test normally distributed abilities) larger information varies substantially (e.g., short tests skewed latent distributions extreme difficulty values).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction.html","id":"visualizing-the-reliability-curve","dir":"Articles","previous_headings":"5. Two Reliability Metrics","what":"5.4 Visualizing the Reliability Curve","title":"IRTsimrel: Reliability-Targeted IRT Simulation","text":"rho_curve() function visualizes metrics simultaneously function scaling factor cc: Reliability function scaling factor c 20-item Rasch test. gap two curves reflects Jensen‚Äôs inequality: average-information metric always lies MSEM-based metric. plot useful several purposes: understanding feasible range reliabilities, seeing sensitive reliability discrimination level, verifying gap œÅÃÉ\\tilde{\\rho} w‚Äæ\\bar{w} small particular configuration.","code":"curve_data <- rho_curve(   n_items = 20,   model   = \"rasch\",   metric  = \"both\",   M       = 5000L,   seed    = 42,   plot    = TRUE )"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction.html","id":"exported-functions","dir":"Articles","previous_headings":"6. What the Package Offers","what":"6.1 Exported Functions","title":"IRTsimrel: Reliability-Targeted IRT Simulation","text":"IRTsimrel exports 16 user-facing functions organized five categories: Simulation generators: Calibration algorithms: Reliability computation: Diagnostics screening: Comparison visualization: Two deprecated aliases (spc_calibrate() compare_eqc_spc()) retained backward compatibility code written v0.1.0.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction.html","id":"s3-methods","dir":"Articles","previous_headings":"6. What the Package Offers","what":"6.2 S3 Methods","title":"IRTsimrel: Reliability-Targeted IRT Simulation","text":"Every core object class rich set S3 methods inspection extraction. make easy work IRTsimrel results using standard R idioms. latent_G objects (sim_latentG()): print() ‚Äî concise one-line summary summary() ‚Äî distributional statistics (mean, SD, skewness, kurtosis) print.summary() ‚Äî formatted display summary plot() ‚Äî density plot latent distribution .numeric() ‚Äî extract raw theta vector item_params objects (sim_item_params()): print() ‚Äî concise parameter summary summary() ‚Äî statistics parameter type print.summary() ‚Äî formatted display plot() ‚Äî scatterplot difficulty vs.¬†discrimination .data.frame() ‚Äî convert tidy data frame eqc_result objects (eqc_calibrate()): print() ‚Äî full calibration report summary() ‚Äî key results compact form print.summary() ‚Äî formatted display coef() ‚Äî extract calibrated item parameters data frame predict() ‚Äî evaluate reliability new scaling factor values sac_result objects (sac_calibrate()): print() ‚Äî full calibration report convergence diagnostics summary() ‚Äî key results compact form print.summary() ‚Äî formatted display plot() ‚Äî convergence trajectory (scaling factor reliability) coef() ‚Äî extract calibrated item parameters data frame predict() ‚Äî evaluate reliability new scaling factor values classes: feasibility_check: print() displays achievable reliability ranges rho_curve: print() displays curve summary first rows total, package provides 25 S3 methods interactive exploration results.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction.html","id":"new-in-v0-2-0","dir":"Articles","previous_headings":"6. What the Package Offers","what":"6.3 New in v0.2.0","title":"IRTsimrel: Reliability-Targeted IRT Simulation","text":"Version 0.2.0 introduces several important new features: check_feasibility(): Screen whether target reliability achievable investing computation time calibration. Reports achievable range metrics. rho_curve(): Visualize reliability varies scaling factor fine grid. Supports metrics, customizable grid, optional plotting. compute_rho_both(): Compute average-information MSEM-based reliabilities single matrix pass, avoiding redundant computation. coef() predict() methods: Standard S3 generics extracting item parameters evaluating reliability function new points. SAC warm start EQC: Pass eqc_result object directly sac_calibrate(c_init = eqc_result) fast, well-initialized stochastic validation. Renamed SPC SAC: stochastic algorithm now called SAC (Stochastic Approximation Calibration) match paper. old name spc_calibrate() retained deprecated alias. check_feasibility() action:","code":"# Screen what reliabilities are achievable for this design feas <- check_feasibility(   n_items = 20,   model   = \"rasch\",   seed    = 42,   M       = 5000L ) #>  #> ======================================================= #>   Feasibility Check: Achievable Reliability Range #> ======================================================= #>  #>   Number of items  : 20 #>   Model            : RASCH #>   Latent shape     : normal #>   Latent variance  : 1.0099 #>   c range          : [0.10, 10.00] #>   Monte Carlo M    : 5000 #>  #> Achievable Reliability Ranges: #>   rho_tilde (info) : [0.0479, 0.9850] #>   rho_bar   (msem) : [0.0000, 0.8818] #>  #> Note: rho_tilde >= rho_bar always (Jensen's inequality). #>   Use rho_tilde range for EQC targets. #>   Use rho_bar range for SAC targets."},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction.html","id":"road-map-to-the-vignettes","dir":"Articles","previous_headings":"","what":"7. Road Map to the Vignettes","title":"IRTsimrel: Reliability-Targeted IRT Simulation","text":"IRTsimrel documentation organized two parallel tracks can find right level detail needs. vignettes accessible package website via vignette(\"name\") R console.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction.html","id":"applied-researchers-track","dir":"Articles","previous_headings":"7. Road Map to the Vignettes","what":"7.1 Applied Researchers Track","title":"IRTsimrel: Reliability-Targeted IRT Simulation","text":"track focuses use package practice, emphasis complete worked examples, actionable guidance, minimal mathematical detail. primarily want generate data simulation study, start .","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction.html","id":"methodological-researchers-track","dir":"Articles","previous_headings":"7. Road Map to the Vignettes","what":"7.2 Methodological Researchers Track","title":"IRTsimrel: Reliability-Targeted IRT Simulation","text":"track covers mathematical algorithmic foundations readers want understand extend happens hood. developing new calibration methods writing methods paper, start .","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction.html","id":"recommended-reading-paths","dir":"Articles","previous_headings":"7. Road Map to the Vignettes","what":"7.3 Recommended Reading Paths","title":"IRTsimrel: Reliability-Targeted IRT Simulation","text":"Depending goal, four suggested paths documentation: Path 1: ‚Äúneed simulate data right now.‚Äù vignette(\"quick-start\") ‚Üí\\rightarrowvignette(\"applied-guide\") Start 5-minute quick start instant gratification, move full applied guide realistic scenarios including 2PL models, non-normal distributions, IRW item sources. Path 2: ‚Äúwant understand mathematical foundations.‚Äù vignette(\"theory-reliability\") ‚Üí\\rightarrowvignette(\"algorithm-eqc\") ‚Üí\\rightarrowvignette(\"algorithm-sac\") Begin theoretical development population-level reliability metrics Jensen‚Äôs inequality, study derivation convergence properties calibration algorithm. Path 3: ‚Äúwriting methods paper need simulation conditions.‚Äù vignette(\"applied-guide\") ‚Üí\\rightarrowvignette(\"simulation-design\") ‚Üí\\rightarrowvignette(\"case-studies\") Learn applied workflow first, see set factorial simulation designs crossed reliability levels, finally study complete worked examples spanning DIF detection, CAT simulation, equating, . Path 4: ‚Äújust need look specific function.‚Äù vignette(\"api-reference\") API reference lists every exported function full signature, arguments, return value description, runnable code examples. Use quick-lookup reference workflow.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction.html","id":"cross-references-between-tracks","dir":"Articles","previous_headings":"7. Road Map to the Vignettes","what":"7.4 Cross-References Between Tracks","title":"IRTsimrel: Reliability-Targeted IRT Simulation","text":"two tracks isolated. Many applied vignettes link methodological counterparts readers want depth, methodological vignettes link back applied examples concreteness. example: Applied Guide links Reliability Theory mathematical justification controlling reliability matters. Algorithm EQC vignette links Quick Start minimal working examples function calls. Case Studies vignette links Simulation Design general framework underlying specific case.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction.html","id":"installation","dir":"Articles","previous_headings":"","what":"8. Installation","title":"IRTsimrel: Reliability-Targeted IRT Simulation","text":"Install released version CRAN (available): install development version GitHub: full functionality, may also want install optional dependencies: installation, verify package loads correctly:","code":"install.packages(\"IRTsimrel\") # install.packages(\"remotes\") remotes::install_github(\"joonho112/IRTsimrel\") # For TAM-based validation of calibration results install.packages(\"TAM\")  # For empirically-grounded item difficulties from the Item Response Warehouse # install.packages(\"remotes\") remotes::install_github(\"itemresponsewarehouse/irw\")  # For enhanced plotting (ggplot2 themes) and multi-panel layouts install.packages(c(\"ggplot2\", \"patchwork\")) library(IRTsimrel) packageVersion(\"IRTsimrel\")"},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction.html","id":"getting-help","dir":"Articles","previous_headings":"","what":"9. Getting Help","title":"IRTsimrel: Reliability-Targeted IRT Simulation","text":"Package documentation: Every exported function help page. Try ?eqc_calibrate, ?sac_calibrate, ?sim_latentG, etc. Vignettes: Browse browseVignettes(\"IRTsimrel\") visit package website. GitHub issues: github.com/joonho112/IRTsimrel/issues bug reports feature requests. Paper: Lee (2025) provides full mathematical development, proofs, extensive simulation evidence supporting framework.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/introduction.html","id":"references","dir":"Articles","previous_headings":"","what":"10. References","title":"IRTsimrel: Reliability-Targeted IRT Simulation","text":"Lee, J. (2025). Reliability-targeted simulation item response data: Solving inverse design problem. arXiv preprint, arXiv:2512.16012. Robbins, H., & Monro, S. (1951). stochastic approximation method. Annals Mathematical Statistics, 22(3), 400‚Äì407. Polyak, B. T., & Juditsky, . B. (1992). Acceleration stochastic approximation averaging. SIAM Journal Control Optimization, 30(4), 838‚Äì855.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/item-parameters.html","id":"overview","dir":"Articles","previous_headings":"","what":"1. Overview","title":"Generating Realistic Item Parameters","text":"Reading time: approximately 20‚Äì25 minutes. sim_item_params() function generates item parameters (difficulty Œ≤\\beta discrimination Œª\\lambda) IRT simulation studies. designed four key principles: Realistic difficulties: Integration Item Response Warehouse (IRW) empirically-grounded difficulty distributions. Correlated parameters: Support empirically observed negative correlation difficulty discrimination. Marginal preservation: copula method preserves exact marginal distributions. Reliability targeting: scale factor enables subsequent calibration target reliability. vignette covers: difficulty-discrimination correlation Basic usage (Rasch 2PL) Sources difficulty generation Methods discrimination generation Customizing discrimination parameters Generating multiple test forms scale parameter Visualization Extracting calibrated item parameters coef() Integration calibration functions complete calibration workflow, see vignette(\"applied-guide\"). theoretical details item parameters interact reliability, see vignette(\"algorithm-eqc\").","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/item-parameters.html","id":"the-difficulty-discrimination-correlation","dir":"Articles","previous_headings":"","what":"2. The Difficulty-Discrimination Correlation","title":"Generating Realistic Item Parameters","text":"critical finding psychometric research item difficulty discrimination negatively correlated real assessments (Sweeney et al., 2022): Easy items (Œ≤\\beta low) tend higher discrimination (Œª\\lambda high). Difficult items (Œ≤\\beta high) tend lower discrimination (Œª\\lambda low). correlation, typically around œÅ‚âà‚àí0.3\\rho \\approx -0.3, important implications: Ignoring produces unrealistic simulation data. Standard independent generation misses structural feature. correlation affects test information functions. sim_item_params() handles default using copula method œÅ=‚àí0.3\\rho = -0.3.","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/item-parameters.html","id":"rasch-model","dir":"Articles","previous_headings":"3. Basic Usage","what":"3.1 Rasch model","title":"Generating Realistic Item Parameters","text":"Rasch model, discriminations set 1:","code":"# Generate 25 Rasch items with parametric difficulties items_rasch <- sim_item_params(   n_items = 25,   model   = \"rasch\",   source  = \"parametric\",   seed    = 42 )  print(items_rasch) #> Item Parameters Object #> ====================== #>   Model          : RASCH #>   Source         : parametric #>   Items per form : 25 #>   Number of forms: 1 #>   Scale factor   : 1.000 #>   Centered       : Yes #>  #> Difficulty (beta): #>   Mean: 0.0000, SD: 1.3064, Range: [-2.844, 2.099]"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item-parameters.html","id":"two-parameter-logistic-2pl-model","dir":"Articles","previous_headings":"3. Basic Usage","what":"3.2 Two-parameter logistic (2PL) model","title":"Generating Realistic Item Parameters","text":"2PL model, difficulties discriminations generated: Notice achieved correlation Œ≤\\beta log(Œª)\\log(\\lambda) close default target ‚àí0.3-0.3.","code":"# Generate 30 2PL items with correlated parameters items_2pl <- sim_item_params(   n_items = 30,   model   = \"2pl\",   source  = \"parametric\",   method  = \"copula\",   seed    = 42 )  print(items_2pl) #> Item Parameters Object #> ====================== #>   Model          : 2PL #>   Source         : parametric #>   Method         : copula #>   Items per form : 30 #>   Number of forms: 1 #>   Scale factor   : 1.000 #>   Centered       : Yes #>  #> Difficulty (beta): #>   Mean: 0.0000, SD: 1.2550, Range: [-2.725, 2.218] #>  #> Discrimination (lambda, scaled): #>   Mean: 1.0867, SD: 0.2885, Range: [0.440, 1.731] #>  #> Correlation (beta, log-lambda): #>   Target (rho): -0.300 #>   Achieved Pearson : -0.361 #>   Achieved Spearman: -0.378"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item-parameters.html","id":"sources-for-difficulty-generation","dir":"Articles","previous_headings":"","what":"4. Sources for Difficulty Generation","title":"Generating Realistic Item Parameters","text":"sim_item_params() supports four sources generating item difficulties.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/item-parameters.html","id":"irw-item-response-warehouse","dir":"Articles","previous_headings":"4. Sources for Difficulty Generation","what":"4.1 IRW (Item Response Warehouse)","title":"Generating Realistic Item Parameters","text":"recommended source realistic simulations. IRW provides empirically-grounded difficulty distributions based thousands real assessment items.","code":"# Requires: devtools::install_github(\"itemresponsewarehouse/irw\") items_irw <- sim_item_params(   n_items = 25,   model   = \"rasch\",   source  = \"irw\",   seed    = 42 )  summary(items_irw$data$beta)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item-parameters.html","id":"parametric","dir":"Articles","previous_headings":"4. Sources for Difficulty Generation","what":"4.2 Parametric","title":"Generating Realistic Item Parameters","text":"Generate difficulties parametric distribution:","code":"# Normal distribution (default) items_normal <- sim_item_params(   n_items = 25,   model   = \"rasch\",   source  = \"parametric\",   difficulty_params = list(mu = 0, sigma = 1, distribution = \"normal\"),   seed    = 42 )  # Uniform distribution items_uniform <- sim_item_params(   n_items = 25,   model   = \"rasch\",   source  = \"parametric\",   difficulty_params = list(mu = 0, sigma = 1, distribution = \"uniform\"),   seed    = 42 ) par(mfrow = c(1, 2)) hist(items_normal$data$beta, breaks = 12, col = pal$primary,      border = \"white\", main = \"Normal Difficulties\", xlab = expression(beta)) hist(items_uniform$data$beta, breaks = 12, col = pal$secondary,      border = \"white\", main = \"Uniform Difficulties\", xlab = expression(beta)) par(mfrow = c(1, 1))"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item-parameters.html","id":"hierarchical","dir":"Articles","previous_headings":"4. Sources for Difficulty Generation","what":"4.3 Hierarchical","title":"Generating Realistic Item Parameters","text":"Joint bivariate normal generation following Glas & van der Linden (2003). log(Œª)\\log(\\lambda) Œ≤\\beta drawn multivariate normal: (log(Œªi)Œ≤i)‚àºN((ŒºŒªŒºŒ≤),(œÑŒª2œÅœÑŒªœÑŒ≤œÅœÑŒªœÑŒ≤œÑŒ≤2))\\begin{pmatrix} \\log(\\lambda_i) \\\\ \\beta_i \\end{pmatrix} \\sim N\\!\\left( \\begin{pmatrix} \\mu_\\lambda \\\\ \\mu_\\beta \\end{pmatrix}, \\begin{pmatrix} \\tau_\\lambda^2 & \\rho \\tau_\\lambda \\tau_\\beta \\\\ \\rho \\tau_\\lambda \\tau_\\beta & \\tau_\\beta^2 \\end{pmatrix} \\right)","code":"items_hier <- sim_item_params(   n_items = 25,   model   = \"2pl\",   source  = \"hierarchical\",   hierarchical_params = list(     mu  = c(0, 0),     tau = c(0.25, 1),     rho = -0.3   ),   seed = 42 )  print(items_hier) #> Item Parameters Object #> ====================== #>   Model          : 2PL #>   Source         : hierarchical #>   Items per form : 25 #>   Number of forms: 1 #>   Scale factor   : 1.000 #>   Centered       : Yes #>  #> Difficulty (beta): #>   Mean: -0.0000, SD: 1.3077, Range: [-2.863, 2.109] #>  #> Discrimination (lambda, scaled): #>   Mean: 1.0776, SD: 0.2710, Range: [0.720, 1.812] #>  #> Correlation (beta, log-lambda): #>   Target (rho): -0.300 #>   Achieved Pearson : -0.345 #>   Achieved Spearman: -0.375"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item-parameters.html","id":"custom","dir":"Articles","previous_headings":"4. Sources for Difficulty Generation","what":"4.4 Custom","title":"Generating Realistic Item Parameters","text":"Supply parameters directly: can also provide functions generate parameters:","code":"# Custom difficulties and discriminations items_custom <- sim_item_params(   n_items = 10,   model   = \"2pl\",   source  = \"custom\",   custom_params = list(     beta   = seq(-2, 2, length.out = 10),     lambda = rep(1.2, 10)   ),   seed = 42 ) #> Warning in cor(df$beta, log(df$lambda_unscaled)): the standard deviation is #> zero #> Warning in cor(df$beta, log(df$lambda_unscaled), method = \"spearman\"): the #> standard deviation is zero #> Warning in cor(data$beta, log(data$lambda_unscaled)): the standard deviation is #> zero #> Warning in cor(data$beta, log(data$lambda_unscaled), method = \"spearman\"): the #> standard deviation is zero  items_custom$data #>    form_id item_id       beta lambda lambda_unscaled #> 1        1       1 -2.0000000    1.2             1.2 #> 2        1       2 -1.5555556    1.2             1.2 #> 3        1       3 -1.1111111    1.2             1.2 #> 4        1       4 -0.6666667    1.2             1.2 #> 5        1       5 -0.2222222    1.2             1.2 #> 6        1       6  0.2222222    1.2             1.2 #> 7        1       7  0.6666667    1.2             1.2 #> 8        1       8  1.1111111    1.2             1.2 #> 9        1       9  1.5555556    1.2             1.2 #> 10       1      10  2.0000000    1.2             1.2 items_custom_fn <- sim_item_params(   n_items = 20,   model   = \"2pl\",   source  = \"custom\",   custom_params = list(     beta   = function(n) rnorm(n, 0, 1.5),     lambda = function(n) rlnorm(n, 0, 0.3)   ),   seed = 42 )"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item-parameters.html","id":"methods-for-discrimination-generation","dir":"Articles","previous_headings":"","what":"5. Methods for Discrimination Generation","title":"Generating Realistic Item Parameters","text":"using source = \"irw\" source = \"parametric\" model = \"2pl\", need specify discriminations generated. Three methods available.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/item-parameters.html","id":"copula-method-recommended","dir":"Articles","previous_headings":"5. Methods for Discrimination Generation","what":"5.1 Copula method (recommended)","title":"Generating Realistic Item Parameters","text":"Gaussian copula method preserves exact marginal distributions achieving target correlation. Algorithm: Transform Œ≤\\beta uniform via empirical CDF: u=rank(Œ≤)/(n+1)u = \\text{rank}(\\beta)/(n+1). Transform normal: zŒ≤=Œ¶‚àí1(u)z_\\beta = \\Phi^{-1}(u). Generate correlated normal: zŒª=œÅ‚ãÖzŒ≤+1‚àíœÅ2‚ãÖzindepz_\\lambda = \\rho \\cdot z_\\beta + \\sqrt{1-\\rho^2} \\cdot z_{\\text{indep}}. Transform uniform: v=Œ¶(zŒª)v = \\Phi(z_\\lambda). Transform log-normal: Œª=exp(Œº+œÉ‚ãÖŒ¶‚àí1(v))\\lambda = \\exp(\\mu + \\sigma \\cdot \\Phi^{-1}(v)). copula recommended: Preserves exact IRW difficulty distribution. Guarantees log-normal marginal discriminations. Achieves target Spearman correlation (robust non-normality). Works well difficulty distribution shape.","code":"items_copula <- sim_item_params(   n_items = 100,   model   = \"2pl\",   source  = \"parametric\",   method  = \"copula\",   discrimination_params = list(     mu_log    = 0,     sigma_log = 0.3,     rho       = -0.3   ),   seed = 42 )  # Check achieved correlation cat(sprintf(\"Target rho: -0.30\\n\")) #> Target rho: -0.30 cat(sprintf(\"Achieved Spearman: %.3f\\n\",             items_copula$achieved$overall$cor_spearman_pooled)) #> Achieved Spearman: -0.237"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item-parameters.html","id":"conditional-method","dir":"Articles","previous_headings":"5. Methods for Discrimination Generation","what":"5.2 Conditional method","title":"Generating Realistic Item Parameters","text":"Uses conditional normal regression: log(Œªi)‚à£Œ≤i‚àºN(Œºlog+œÅ‚ãÖœÉlog‚ãÖzŒ≤i,œÉlog1‚àíœÅ2)\\log(\\lambda_i) \\mid \\beta_i \\sim N\\!\\left(\\mu_{\\log} + \\rho \\cdot \\sigma_{\\log} \\cdot z_{\\beta_i}, \\; \\sigma_{\\log}\\sqrt{1-\\rho^2}\\right) Note: conditional method assumes linear relationships normal errors. IRW difficulties non-normal, achieved correlations may differ targets.","code":"items_cond <- sim_item_params(   n_items = 100,   model   = \"2pl\",   source  = \"parametric\",   method  = \"conditional\",   discrimination_params = list(rho = -0.3),   seed    = 42 )  cat(sprintf(\"Achieved Pearson:  %.3f\\n\",             items_cond$achieved$overall$cor_pearson_pooled)) #> Achieved Pearson:  -0.302 cat(sprintf(\"Achieved Spearman: %.3f\\n\",             items_cond$achieved$overall$cor_spearman_pooled)) #> Achieved Spearman: -0.310"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item-parameters.html","id":"independent-method","dir":"Articles","previous_headings":"5. Methods for Discrimination Generation","what":"5.3 Independent method","title":"Generating Realistic Item Parameters","text":"Generates discriminations independently difficulties (correlation):","code":"items_indep <- sim_item_params(   n_items = 100,   model   = \"2pl\",   source  = \"parametric\",   method  = \"independent\",   seed    = 42 )  cat(sprintf(\"Achieved correlation: %.3f (expected: ~0)\\n\",             items_indep$achieved$overall$cor_spearman_pooled)) #> Achieved correlation: 0.051 (expected: ~0)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item-parameters.html","id":"customizing-discrimination-parameters","dir":"Articles","previous_headings":"","what":"6. Customizing Discrimination Parameters","title":"Generating Realistic Item Parameters","text":"discrimination_params list controls log-normal distribution discriminations:","code":"# Higher average discrimination items_high_disc <- sim_item_params(   n_items = 30,   model   = \"2pl\",   source  = \"parametric\",   method  = \"copula\",   discrimination_params = list(     mu_log    = 0.3,     sigma_log = 0.25,     rho       = -0.3   ),   seed = 42 )  cat(sprintf(\"Mean lambda: %.3f\\n\", mean(items_high_disc$data$lambda))) #> Mean lambda: 1.440 cat(sprintf(\"SD lambda:   %.3f\\n\", sd(items_high_disc$data$lambda))) #> SD lambda:   0.321"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/item-parameters.html","id":"generating-multiple-test-forms","dir":"Articles","previous_headings":"","what":"7. Generating Multiple Test Forms","title":"Generating Realistic Item Parameters","text":"Generate multiple parallel forms independent item samples:","code":"items_5forms <- sim_item_params(   n_items = 20,   model   = \"2pl\",   source  = \"parametric\",   method  = \"copula\",   n_forms = 5,   seed    = 42 )  cat(sprintf(\"Total items: %d\\n\", nrow(items_5forms$data))) #> Total items: 100 cat(sprintf(\"Items per form: %d\\n\", items_5forms$n_items)) #> Items per form: 20 cat(sprintf(\"Number of forms: %d\\n\", items_5forms$n_forms)) #> Number of forms: 5  # View first few rows head(items_5forms$data, 10) #>    form_id item_id       beta    lambda lambda_unscaled #> 1        1       1  1.1790384 1.0473137       1.0473137 #> 2        1       2 -0.7566182 1.3308590       1.3308590 #> 3        1       3  0.1712084 1.3372084       1.3372084 #> 4        1       4  0.4409426 0.8163263       0.8163263 #> 5        1       5  0.2123483 1.1359716       1.1359716 #> 6        1       6 -0.2980445 0.6295821       0.6295821 #> 7        1       7  1.3196020 0.7203419       0.7203419 #> 8        1       8 -0.2865791 0.7973245       0.7973245 #> 9        1       9  1.8265037 0.4402291       0.4402291 #> 10       1      10 -0.2546341 1.0161096       1.0161096"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item-parameters.html","id":"per-form-statistics","dir":"Articles","previous_headings":"7. Generating Multiple Test Forms","what":"7.1 Per-form statistics","title":"Generating Realistic Item Parameters","text":"","code":"for (f in 1:3) {   stats <- items_5forms$achieved$by_form[[f]]   cat(sprintf(\"Form %d: beta_mean=%.3f, lambda_mean=%.3f, cor=%.3f\\n\",               f, stats$beta_mean, stats$lambda_mean, stats$cor_spearman)) } #> Form 1: beta_mean=-0.000, lambda_mean=0.992, cor=-0.382 #> Form 2: beta_mean=-0.000, lambda_mean=1.063, cor=-0.356 #> Form 3: beta_mean=0.000, lambda_mean=1.031, cor=-0.463"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item-parameters.html","id":"the-scale-parameter","dir":"Articles","previous_headings":"","what":"8. The Scale Parameter","title":"Generating Realistic Item Parameters","text":"scale parameter central reliability-targeted framework. multiplies discriminations constant factor: Œªi*=c‚ãÖŒªi,0\\lambda_i^* = c \\cdot \\lambda_{,0} Œªi,0\\lambda_{,0} baseline discrimination cc scale factor.","code":"# Baseline (scale = 1) items_base <- sim_item_params(   n_items = 25, model = \"2pl\", source = \"parametric\",   scale = 1, seed = 42 )  # Scaled up (scale = 1.5) items_scaled <- sim_item_params(   n_items = 25, model = \"2pl\", source = \"parametric\",   scale = 1.5, seed = 42 )  cat(sprintf(\"Baseline mean lambda: %.3f\\n\", mean(items_base$data$lambda))) #> Baseline mean lambda: 0.994 cat(sprintf(\"Scaled mean lambda:   %.3f\\n\", mean(items_scaled$data$lambda))) #> Scaled mean lambda:   1.491 cat(sprintf(\"Ratio: %.2f\\n\",             mean(items_scaled$data$lambda) / mean(items_base$data$lambda))) #> Ratio: 1.50"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item-parameters.html","id":"unscaled-lambda","dir":"Articles","previous_headings":"8. The Scale Parameter","what":"8.1 Unscaled lambda","title":"Generating Realistic Item Parameters","text":"output always includes lambda_unscaled reference:","code":"head(items_scaled$data[, c(\"lambda\", \"lambda_unscaled\")]) #>      lambda lambda_unscaled #> 1 1.6312287       1.0874858 #> 2 1.4873989       0.9915993 #> 3 0.6383717       0.4255811 #> 4 1.0951612       0.7301075 #> 5 1.6391847       1.0927898 #> 6 1.5991754       1.0661169  # Verify relationship all.equal(   items_scaled$data$lambda,   items_scaled$data$lambda_unscaled * items_scaled$scale ) #> [1] TRUE"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item-parameters.html","id":"centering-difficulties","dir":"Articles","previous_headings":"","what":"9. Centering Difficulties","title":"Generating Realistic Item Parameters","text":"default, difficulties centered sum zero (model identification):","code":"# Default: centered items_centered <- sim_item_params(   n_items = 25, model = \"rasch\", source = \"parametric\",   center_difficulties = TRUE, seed = 42 )  # Uncentered items_uncentered <- sim_item_params(   n_items = 25, model = \"rasch\", source = \"parametric\",   center_difficulties = FALSE, seed = 42 )  cat(sprintf(\"Centered mean:   %.6f\\n\", mean(items_centered$data$beta))) #> Centered mean:   0.000000 cat(sprintf(\"Uncentered mean: %.6f\\n\", mean(items_uncentered$data$beta))) #> Uncentered mean: 0.187536"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item-parameters.html","id":"visualization","dir":"Articles","previous_headings":"","what":"10. Visualization","title":"Generating Realistic Item Parameters","text":"plot() method provides diagnostic visualizations:","code":"items_viz <- sim_item_params(   n_items = 50, model = \"2pl\", source = \"parametric\",   method = \"copula\", seed = 42 )  # Scatter plot with regression line plot(items_viz, type = \"scatter\") #> `geom_smooth()` using formula = 'y ~ x' # Density plots plot(items_viz, type = \"density\")"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item-parameters.html","id":"extracting-calibrated-item-parameters-with-coef","dir":"Articles","previous_headings":"","what":"11. Extracting Calibrated Item Parameters with coef()","title":"Generating Realistic Item Parameters","text":"running eqc_calibrate() sac_calibrate(), coef() method extracts tidy data frame item parameters‚Äîincluding baseline calibrated (scaled) discriminations.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/item-parameters.html","id":"from-an-eqc-result","dir":"Articles","previous_headings":"11. Extracting Calibrated Item Parameters with coef()","what":"11.1 From an EQC result","title":"Generating Realistic Item Parameters","text":"row contains:","code":"eqc_result <- eqc_calibrate(   target_rho  = 0.85,   n_items     = 25,   model       = \"rasch\",   item_source = \"parametric\",   M           = 5000L,   seed        = 42 )  # Extract calibrated item parameters item_table <- coef(eqc_result) head(item_table) #>   item_id         beta lambda_base lambda_scaled   c_star #> 1       1  0.197732269           1      1.119885 1.119885 #> 2       2  1.096799859           1      1.119885 1.119885 #> 3       3  0.436545084           1      1.119885 1.119885 #> 4       4 -0.013038730           1      1.119885 1.119885 #> 5       5 -0.199801302           1      1.119885 1.119885 #> 6       6  0.007700326           1      1.119885 1.119885"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item-parameters.html","id":"summary-statistics-from-coef-output","dir":"Articles","previous_headings":"11. Extracting Calibrated Item Parameters with coef()","what":"11.2 Summary statistics from coef output","title":"Generating Realistic Item Parameters","text":"","code":"cat(sprintf(\"Number of items:       %d\\n\", nrow(item_table))) #> Number of items:       25 cat(sprintf(\"Difficulty range:      [%.3f, %.3f]\\n\",             min(item_table$beta), max(item_table$beta))) #> Difficulty range:      [-2.170, 1.450] cat(sprintf(\"Difficulty mean:       %.4f\\n\", mean(item_table$beta))) #> Difficulty mean:       0.0000 cat(sprintf(\"Difficulty SD:         %.4f\\n\", sd(item_table$beta))) #> Difficulty SD:         0.8606 cat(sprintf(\"Calibrated c*:         %.4f\\n\", item_table$c_star[1])) #> Calibrated c*:         1.1199 cat(sprintf(\"Scaled discrimination: %.4f (all equal for Rasch)\\n\",             item_table$lambda_scaled[1])) #> Scaled discrimination: 1.1199 (all equal for Rasch)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item-parameters.html","id":"from-a-sac-result","dir":"Articles","previous_headings":"11. Extracting Calibrated Item Parameters with coef()","what":"11.3 From a SAC result","title":"Generating Realistic Item Parameters","text":"coef() interface works SAC results:","code":"sac_result <- sac_calibrate(   target_rho        = 0.85,   n_items           = 25,   model             = \"rasch\",   item_source       = \"parametric\",   reliability_metric = \"info\",   c_init            = eqc_result,   n_iter            = 200L,   M_per_iter        = 500L,   M_pre             = 5000L,   seed              = 42 )  sac_items <- coef(sac_result) head(sac_items) #>   item_id        beta lambda_base lambda_scaled   c_star #> 1       1  0.03774168           1      1.137803 1.137803 #> 2       2 -1.18785344           1      1.137803 1.137803 #> 3       3 -0.21413874           1      1.137803 1.137803 #> 4       4 -0.81661157           1      1.137803 1.137803 #> 5       5  1.52992507           1      1.137803 1.137803 #> 6       6 -0.38999393           1      1.137803 1.137803"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item-parameters.html","id":"comparing-eqc-and-sac-item-parameters","dir":"Articles","previous_headings":"11. Extracting Calibrated Item Parameters with coef()","what":"11.4 Comparing EQC and SAC item parameters","title":"Generating Realistic Item Parameters","text":"","code":"cat(sprintf(\"EQC c*: %.4f\\n\", item_table$c_star[1])) #> EQC c*: 1.1199 cat(sprintf(\"SAC c*: %.4f\\n\", sac_items$c_star[1])) #> SAC c*: 1.1378 cat(sprintf(\"Difference: %.4f (%.2f%%)\\n\",             abs(item_table$c_star[1] - sac_items$c_star[1]),             100 * abs(item_table$c_star[1] - sac_items$c_star[1]) / item_table$c_star[1])) #> Difference: 0.0179 (1.60%)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item-parameters.html","id":"exporting-to-csv","dir":"Articles","previous_headings":"11. Extracting Calibrated Item Parameters with coef()","what":"11.5 Exporting to CSV","title":"Generating Realistic Item Parameters","text":"","code":"# Save calibrated item parameters for use in other software write.csv(coef(eqc_result), file = \"calibrated_items.csv\", row.names = FALSE)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item-parameters.html","id":"using-coef-output-with-2pl-models","dir":"Articles","previous_headings":"11. Extracting Calibrated Item Parameters with coef()","what":"11.6 Using coef output with 2PL models","title":"Generating Realistic Item Parameters","text":"2PL models, baseline discriminations vary across items, coef() makes easy see original scaled values:","code":"eqc_2pl <- eqc_calibrate(   target_rho  = 0.80,   n_items     = 20,   model       = \"2pl\",   item_source = \"parametric\",   M           = 5000L,   seed        = 42 )  items_2pl_df <- coef(eqc_2pl) head(items_2pl_df, 10) #>    item_id         beta lambda_base lambda_scaled    c_star #> 1        1  0.217684472   1.1349399     1.0243632 0.9025704 #> 2        2  1.116752062   0.8790623     0.7934156 0.9025704 #> 3        3  0.456497288   0.6153466     0.5553937 0.9025704 #> 4        4  0.006913473   0.9368403     0.8455644 0.9025704 #> 5        5 -0.179849098   1.6009565     1.4449760 0.9025704 #> 6        6  0.027652529   0.6234454     0.5627034 0.9025704 #> 7        7  1.040020929   0.9415274     0.8497948 0.9025704 #> 8        8  0.357576547   1.4926448     1.3472170 0.9025704 #> 9        9 -0.342317758   0.9401472     0.8485490 0.9025704 #> 10      10 -0.073909889   1.1890902     1.0732377 0.9025704 plot(items_2pl_df$beta, items_2pl_df$lambda_scaled,      pch = 16, col = pal$primary, cex = 1.2,      xlab = expression(beta), ylab = expression(lambda^\"*\"),      main = \"Calibrated Item Parameters (2PL)\") abline(lm(lambda_scaled ~ beta, data = items_2pl_df),        col = pal$accent, lty = 2, lwd = 1.5)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item-parameters.html","id":"integration-with-eqc_calibrate","dir":"Articles","previous_headings":"","what":"12. Integration with eqc_calibrate","title":"Generating Realistic Item Parameters","text":"reliability-targeted simulation framework, sim_item_params() called internally eqc_calibrate(). specify item generation settings item_source item_params arguments:","code":"# EQC automatically calls sim_item_params internally eqc_result_full <- eqc_calibrate(   target_rho  = 0.80,   n_items     = 25,   model       = \"2pl\",   item_source = \"parametric\",   item_params = list(     discrimination_params = list(       mu_log    = 0,       sigma_log = 0.3,       rho       = -0.3     )   ),   M    = 5000L,   seed = 42 )  cat(sprintf(\"c* = %.4f, achieved rho = %.4f\\n\",             eqc_result_full$c_star, eqc_result_full$achieved_rho)) #> c* = 0.8637, achieved rho = 0.8000"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item-parameters.html","id":"accessing-calibrated-items","dir":"Articles","previous_headings":"12. Integration with eqc_calibrate","what":"12.1 Accessing calibrated items","title":"Generating Realistic Item Parameters","text":"calibration, can access baseline calibrated item parameters:","code":"# Baseline items (scale = 1) items_base_obj <- eqc_result_full$items_base  # Calibrated items (scale = c*) items_calib_obj <- eqc_result_full$items_calib  # The calibration factor c_star <- eqc_result_full$c_star  cat(sprintf(\"Baseline scale:    %d\\n\", items_base_obj$scale)) #> Baseline scale:    1 cat(sprintf(\"Calibrated scale:  %.4f\\n\", items_calib_obj$scale)) #> Calibrated scale:  0.8637"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item-parameters.html","id":"comparison-of-methods","dir":"Articles","previous_headings":"","what":"13. Comparison of Methods","title":"Generating Realistic Item Parameters","text":"Compare three discrimination generation methods: copula method achieves target Spearman correlation reliably.","code":"methods <- c(\"copula\", \"conditional\", \"independent\") results <- list()  for (m in methods) {   results[[m]] <- sim_item_params(     n_items = 200, model = \"2pl\", source = \"parametric\",     method = m,     discrimination_params = list(rho = -0.4),     seed = 123   ) }  # Compare achieved correlations cat(\"Method Comparison (target rho = -0.4):\\n\") #> Method Comparison (target rho = -0.4): cat(\"======================================\\n\") #> ====================================== for (m in methods) {   cat(sprintf(\"%-12s: Pearson = %+.3f, Spearman = %+.3f\\n\",               m,               results[[m]]$achieved$overall$cor_pearson_pooled,               results[[m]]$achieved$overall$cor_spearman_pooled)) } #> copula      : Pearson = -0.465, Spearman = -0.452 #> conditional : Pearson = -0.422, Spearman = -0.416 #> independent : Pearson = -0.028, Spearman = -0.046"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item-parameters.html","id":"working-with-the-output-object","dir":"Articles","previous_headings":"","what":"14. Working with the Output Object","title":"Generating Realistic Item Parameters","text":"item_params object contains rich information:","code":"items <- sim_item_params(   n_items = 25, model = \"2pl\", source = \"parametric\", seed = 42 )  # Structure names(items) #>  [1] \"data\"     \"model\"    \"source\"   \"method\"   \"n_items\"  \"n_forms\"  #>  [7] \"scale\"    \"centered\" \"params\"   \"achieved\"  # Extract as data frame df <- as.data.frame(items) head(df) #>   form_id item_id       beta    lambda lambda_unscaled #> 1       1       1  1.1834223 1.0874858       1.0874858 #> 2       1       2 -0.7522343 0.9915993       0.9915993 #> 3       1       3  0.1755922 0.4255811       0.4255811 #> 4       1       4  0.4453264 0.7301075       0.7301075 #> 5       1       5  0.2167322 1.0927898       1.0927898 #> 6       1       6 -0.2936607 1.0661169       1.0661169  # Achieved statistics items$achieved$overall #> $n_total #> [1] 25 #>  #> $beta_mean #> [1] 0 #>  #> $beta_sd #> [1] 1.306365 #>  #> $lambda_mean #> [1] 0.99377 #>  #> $lambda_sd #> [1] 0.3251601 #>  #> $cor_pearson_pooled #> [1] -0.2580066 #>  #> $cor_spearman_pooled #> [1] -0.3038462"},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/item-parameters.html","id":"for-realistic-simulations","dir":"Articles","previous_headings":"16. Practical Recommendations","what":"16.1 For realistic simulations","title":"Generating Realistic Item Parameters","text":"","code":"items <- sim_item_params(   n_items = 30, model = \"2pl\",   source = \"irw\",   method = \"copula\",   discrimination_params = list(mu_log = 0, sigma_log = 0.3, rho = -0.3),   seed = 42 )"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item-parameters.html","id":"for-controlled-experiments","dir":"Articles","previous_headings":"16. Practical Recommendations","what":"16.2 For controlled experiments","title":"Generating Realistic Item Parameters","text":"","code":"items <- sim_item_params(   n_items = 25, model = \"2pl\",   source = \"parametric\",   difficulty_params = list(mu = 0, sigma = 1),   method = \"conditional\",   discrimination_params = list(mu_log = 0, sigma_log = 0.25, rho = 0),   seed = 42 )"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item-parameters.html","id":"for-bayesian-frameworks","dir":"Articles","previous_headings":"16. Practical Recommendations","what":"16.3 For Bayesian frameworks","title":"Generating Realistic Item Parameters","text":"","code":"items <- sim_item_params(   n_items = 25, model = \"2pl\",   source = \"hierarchical\",   hierarchical_params = list(mu = c(0, 0), tau = c(0.3, 1), rho = -0.3),   seed = 42 )"},{"path":"https://joonho112.github.io/IRTsimrel/articles/item-parameters.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Generating Realistic Item Parameters","text":"Lee, J. (2025). Reliability-targeted simulation item response data: Solving inverse design problem. arXiv preprint, arXiv:2512.16012. Glas, C. . W., & van der Linden, W. J. (2003). Computerized adaptive testing item cloning. Applied Psychological Measurement, 27(4), 247‚Äì261. Sweeney, S. M., et al.¬†(2022). investigation nature consequence relationship IRT difficulty discrimination. Educational Measurement: Issues Practice, 41(4), 50‚Äì67. Zhang, L., Fellinghauer, C., Geerlings, H., & Sijtsma, K. (2025). Realistic simulation item difficulties using Item Response Warehouse. PsyArXiv. https://doi.org/10.31234/osf.io/r5mxv","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent-distributions.html","id":"overview","dir":"Articles","previous_headings":"","what":"1. Overview","title":"Working with Latent Distributions","text":"sim_latentG() function generates latent abilities (person parameters Œ∏\\theta) IRT simulation studies. implements population model: Œ∏p‚àºG\\theta_p \\sim G GG flexible distribution family can take many different shapes maintaining rigorous standardization properties. Estimated reading time: 20‚Äì25 minutes. vignette covers: pre-standardization principle Available distribution shapes (12 built-+ custom) Customizing shape parameters Creating custom mixture distributions Adding covariate effects Visualization tools latent shape affects achievable reliability complete applied workflow uses sim_latentG() part reliability-targeted simulation, see vignette(\"applied-guide\").","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent-distributions.html","id":"the-pre-standardization-principle","dir":"Articles","previous_headings":"","what":"2. The Pre-Standardization Principle","title":"Working with Latent Distributions","text":"key design feature sim_latentG() pre-standardization: every built-distribution shape mathematically constructed mean 0 variance 1 scaling applied. ensures : Changing shape inadvertently change scale sigma parameter directly controls standard deviation Comparisons across shapes meaningful generated abilities follow: Œ∏p=Œº+Xp‚ä§Œ≤+œÉ‚ãÖzp\\theta_p = \\mu + X_p^\\top \\beta + \\sigma \\cdot z_p zp‚àºG0z_p \\sim G_0 ùîº[z]=0\\mathbb{E}[z] = 0 Var[z]=1\\text{Var}[z] = 1.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent-distributions.html","id":"why-this-matters","dir":"Articles","previous_headings":"2. The Pre-Standardization Principle","what":"2.1 Why This Matters","title":"Working with Latent Distributions","text":"traditional simulation approaches, changing latent distribution often changes shape scale simultaneously. example, switching N(0,1)N(0, 1) Gamma(4,1)\\text{Gamma}(4, 1) changes just shape also variance. pre-standardization, can study effect distributional shape IRT estimation holding variance constant ‚Äì cleaner experimental design.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent-distributions.html","id":"basic-usage","dir":"Articles","previous_headings":"","what":"3. Basic Usage","title":"Working with Latent Distributions","text":"output shows: Target mu/sigma: requested location scale Sample Moments: Empirical mean, SD, skewness, excess kurtosis","code":"# Generate 1000 standard normal abilities sim_normal <- sim_latentG(n = 1000, shape = \"normal\", seed = 42)  # Examine the result print(sim_normal) #> Latent Ability Distribution (G-family) #> ======================================= #>   Shape     : normal #>   n         : 1000 #>   Target mu : 0.000 #>   Target sigma: 1.000 #>  #> Sample Moments: #>   Mean      : -0.0258 #>   SD        : 1.0025 #>   Skewness  : -0.0038 #>   Kurtosis  : 0.1286 (excess) # Verify standardization cat(sprintf(\"Sample mean: %.4f (target: 0)\\n\", mean(sim_normal$theta))) #> Sample mean: -0.0258 (target: 0) cat(sprintf(\"Sample SD:   %.4f (target: 1)\\n\", sd(sim_normal$theta))) #> Sample SD:   1.0025 (target: 1)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent-distributions.html","id":"available-distribution-shapes","dir":"Articles","previous_headings":"","what":"4. Available Distribution Shapes","title":"Working with Latent Distributions","text":"sim_latentG() provides 12 built-shapes, pre-standardized mean 0 variance 1.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent-distributions.html","id":"standard-normal","dir":"Articles","previous_headings":"4. Available Distribution Shapes","what":"4.1 Standard Normal","title":"Working with Latent Distributions","text":"baseline case: z‚àºN(0,1)z \\sim N(0, 1)","code":"sim_normal <- sim_latentG(n = 2000, shape = \"normal\", seed = 1) plot(sim_normal, show_normal = TRUE)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent-distributions.html","id":"bimodal-distribution","dir":"Articles","previous_headings":"4. Available Distribution Shapes","what":"4.2 Bimodal Distribution","title":"Working with Latent Distributions","text":"symmetric two-component Gaussian mixture, useful representing populations two distinct subgroups (e.g., native vs.¬†non-native speakers). Mathematical construction: z=s‚ãÖŒ¥+œµ,s‚àºRademacher(¬±1),œµ‚àºN(0,1‚àíŒ¥2)z = s \\cdot \\delta + \\epsilon, \\quad s \\sim \\text{Rademacher}(\\pm 1), \\quad \\epsilon \\sim N(0, 1 - \\delta^2) component variance 1‚àíŒ¥21 - \\delta^2 ensures Var[z]=Œ¥2+(1‚àíŒ¥2)=1\\text{Var}[z] = \\delta^2 + (1 - \\delta^2) = 1.  Customizing mode separation: delta parameter controls far apart modes (0<Œ¥<10 < \\delta < 1):","code":"sim_bimodal <- sim_latentG(n = 2000, shape = \"bimodal\", seed = 1) plot(sim_bimodal, show_normal = TRUE) # Wider separation sim_bimodal_wide <- sim_latentG(   n = 2000,   shape = \"bimodal\",   shape_params = list(delta = 0.95),   seed = 1 ) plot(sim_bimodal_wide, show_normal = TRUE)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent-distributions.html","id":"trimodal-distribution","dir":"Articles","previous_headings":"4. Available Distribution Shapes","what":"4.3 Trimodal Distribution","title":"Working with Latent Distributions","text":"symmetric three-component mixture central peak two side peaks. Mathematical construction: Components {‚àím,0,+m}\\{-m, 0, +m\\} weights (wL,w0,wR)(w_L, w_0, w_R) wL=wR=(1‚àíw0)/2w_L = w_R = (1 - w_0)/2. Component variance: œÉc2=1‚àí(1‚àíw0)m2\\sigma_c^2 = 1 - (1 - w_0) m^2  Customizing:","code":"sim_trimodal <- sim_latentG(n = 2000, shape = \"trimodal\", seed = 1) plot(sim_trimodal, show_normal = TRUE) # Stronger central peak sim_trimodal_central <- sim_latentG(   n = 2000,   shape = \"trimodal\",   shape_params = list(     w0 = 0.5,   # Weight of central component (default: 1/3)     m = 1.3     # Location of side components (default: 1.2)   ),   seed = 1 ) plot(sim_trimodal_central, show_normal = TRUE)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent-distributions.html","id":"multimodal-four-components","dir":"Articles","previous_headings":"4. Available Distribution Shapes","what":"4.4 Multimodal (Four Components)","title":"Working with Latent Distributions","text":"symmetric four-component mixture modes {‚àím2,‚àím1,+m1,+m2}\\{-m_2, -m_1, +m_1, +m_2\\}.","code":"sim_multi <- sim_latentG(n = 2000, shape = \"multimodal\", seed = 1) plot(sim_multi, show_normal = TRUE)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent-distributions.html","id":"skewed-distributions","dir":"Articles","previous_headings":"4. Available Distribution Shapes","what":"4.5 Skewed Distributions","title":"Working with Latent Distributions","text":"Right-skewed (skew_pos): Based standardized Gamma distribution: z=Œì(k,1)‚àíkkz = \\frac{\\Gamma(k, 1) - k}{\\sqrt{k}} ùîº[z]=0\\mathbb{E}[z] = 0 Var[z]=1\\text{Var}[z] = 1 k>0k > 0.  Left-skewed (skew_neg): Simply negation right-skewed distribution.  Controlling skewness magnitude: k parameter (Gamma shape) controls skewness ‚Äì smaller values mean skewed:","code":"sim_skew_pos <- sim_latentG(n = 2000, shape = \"skew_pos\", seed = 1) plot(sim_skew_pos, show_normal = TRUE) sim_skew_neg <- sim_latentG(n = 2000, shape = \"skew_neg\", seed = 1) plot(sim_skew_neg, show_normal = TRUE) # More extreme skewness (k = 2) sim_very_skew <- sim_latentG(   n = 2000,   shape = \"skew_pos\",   shape_params = list(k = 2),   seed = 1 )  cat(sprintf(\"Default k=4 skewness: %.3f\\n\", sim_skew_pos$sample_moments$skewness)) #> Default k=4 skewness: 0.812 cat(sprintf(\"k=2 skewness:         %.3f\\n\", sim_very_skew$sample_moments$skewness)) #> k=2 skewness:         1.244"},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent-distributions.html","id":"heavy-tailed-distribution","dir":"Articles","previous_headings":"4. Available Distribution Shapes","what":"4.6 Heavy-Tailed Distribution","title":"Working with Latent Distributions","text":"Based standardized Student-t: z=tŒΩŒΩ/(ŒΩ‚àí2)z = \\frac{t_\\nu}{\\sqrt{\\nu / (\\nu - 2)}} Var[z]=1\\text{Var}[z] = 1 ŒΩ>2\\nu > 2.  Controlling tail heaviness: df parameter (degrees freedom) controls tail weight ‚Äì smaller values mean heavier tails:","code":"sim_heavy <- sim_latentG(n = 2000, shape = \"heavy_tail\", seed = 1) plot(sim_heavy, show_normal = TRUE) # Very heavy tails (df = 3) sim_very_heavy <- sim_latentG(   n = 2000,   shape = \"heavy_tail\",   shape_params = list(df = 3),   seed = 1 )  cat(sprintf(\"Default df=5 kurtosis: %.3f\\n\", sim_heavy$sample_moments$kurtosis)) #> Default df=5 kurtosis: 2.924 cat(sprintf(\"df=3 kurtosis:         %.3f\\n\", sim_very_heavy$sample_moments$kurtosis)) #> df=3 kurtosis:         7.956"},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent-distributions.html","id":"light-tailed-platykurtic-distribution","dir":"Articles","previous_headings":"4. Available Distribution Shapes","what":"4.7 Light-Tailed (Platykurtic) Distribution","title":"Working with Latent Distributions","text":"mixture distribution approximating platykurtic shape (negative excess kurtosis).","code":"sim_light <- sim_latentG(n = 2000, shape = \"light_tail\", seed = 1) plot(sim_light, show_normal = TRUE)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent-distributions.html","id":"uniform-distribution","dir":"Articles","previous_headings":"4. Available Distribution Shapes","what":"4.8 Uniform Distribution","title":"Working with Latent Distributions","text":"Uniform [‚àí3,+3][-\\sqrt{3}, +\\sqrt{3}], mean 0 variance 1.","code":"sim_uniform <- sim_latentG(n = 2000, shape = \"uniform\", seed = 1) plot(sim_uniform, show_normal = TRUE)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent-distributions.html","id":"floor-and-ceiling-effects","dir":"Articles","previous_headings":"4. Available Distribution Shapes","what":"4.9 Floor and Ceiling Effects","title":"Working with Latent Distributions","text":"represent situations concentration examinees one end ability distribution. Floor effect: Heavy component near lower bound (e.g., many low-ability students difficult test)  Ceiling effect: Heavy component near upper bound (e.g., many high-ability students easy test)","code":"sim_floor <- sim_latentG(n = 2000, shape = \"floor\", seed = 1) plot(sim_floor, show_normal = TRUE) sim_ceiling <- sim_latentG(n = 2000, shape = \"ceiling\", seed = 1) plot(sim_ceiling, show_normal = TRUE)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent-distributions.html","id":"comparing-multiple-shapes","dir":"Articles","previous_headings":"","what":"5. Comparing Multiple Shapes","title":"Working with Latent Distributions","text":"compare_shapes() function provides convenient way visualize multiple distributions side--side:","code":"compare_shapes(   n = 3000,   shapes = c(\"normal\", \"bimodal\", \"trimodal\",              \"skew_pos\", \"heavy_tail\", \"uniform\"),   sigma = 1,   seed = 42 )"},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent-distributions.html","id":"custom-mixture-distributions","dir":"Articles","previous_headings":"","what":"6. Custom Mixture Distributions","title":"Working with Latent Distributions","text":"maximum flexibility, use shape = \"custom\" mixture_spec:  default, custom mixtures automatically post-standardized mean 0 variance 1. disable :","code":"# Define a custom 3-component mixture sim_custom <- sim_latentG(   n = 2000,   shape = \"custom\",   mixture_spec = list(     weights = c(0.3, 0.5, 0.2),   # Must sum to 1     means = c(-1.5, 0, 2),        # Component means     sds = c(0.5, 0.7, 0.5)        # Component SDs   ),   seed = 1 )  plot(sim_custom, show_normal = TRUE) # Keep raw mixture parameters sim_raw <- sim_latentG(   n = 2000,   shape = \"custom\",   mixture_spec = list(     weights = c(0.5, 0.5),     means = c(-1, 1),     sds = c(0.5, 0.5)   ),   standardize_custom = FALSE,   seed = 1 )"},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent-distributions.html","id":"adjusting-location-and-scale","dir":"Articles","previous_headings":"","what":"7. Adjusting Location and Scale","title":"Working with Latent Distributions","text":"mu sigma parameters allow shift scale distribution: works shape:","code":"# Generate abilities with mean 100 and SD 15 (like IQ scores) sim_iq <- sim_latentG(   n = 1000,   shape = \"normal\",   mu = 100,   sigma = 15,   seed = 42 )  summary(sim_iq) #> Summary: Latent Ability Distribution #> ==================================== #>   Shape      : normal #>   n          : 1000 #>   Target     : mu = 100.00, sigma = 15.00 #>   Covariates : No #>  #> Sample Statistics: #>   Mean       : 99.6126 #>   SD         : 15.0378 #>   Median     : 99.8030 #>   Skewness   : -0.0038 #>   Kurtosis   : 0.1286 (excess) #>   Range      : [49.4239, 152.4296] #>  #> Quantiles: #>     2.5%       5%      25%      50%      75%      95%    97.5%  #>  69.8816  75.3193  89.8681  99.8030 109.9601 123.0023 128.1655 # Bimodal with different scale sim_bimodal_scaled <- sim_latentG(   n = 1000,   shape = \"bimodal\",   mu = 0,   sigma = 1.5,  # Larger spread   seed = 42 )  cat(sprintf(\"Sample SD: %.3f (target: 1.5)\\n\", sd(sim_bimodal_scaled$theta))) #> Sample SD: 1.481 (target: 1.5)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent-distributions.html","id":"adding-covariate-effects","dir":"Articles","previous_headings":"","what":"8. Adding Covariate Effects","title":"Working with Latent Distributions","text":"can incorporate person-level covariates affect ability: full model : Œ∏p=Œº+Xp‚ä§Œ≤+œÉ‚ãÖzp\\theta_p = \\mu + X_p^\\top \\beta + \\sigma \\cdot z_p XpX_p covariate vector person pp.","code":"# Create covariate data n <- 1000 set.seed(42) group <- rbinom(n, 1, 0.5)           # Binary group indicator ses <- rnorm(n)                       # Continuous SES measure  # Generate abilities with covariate effects sim_cov <- sim_latentG(   n = n,   shape = \"normal\",   xcov = data.frame(group = group, ses = ses),   beta = c(0.5, 0.3),  # Group effect = 0.5, SES effect = 0.3   seed = 42 )  # Verify covariate effects cat(\"Mean ability by group:\\n\") #> Mean ability by group: cat(sprintf(\"  Group 0: %.3f\\n\", mean(sim_cov$theta[group == 0]))) #>   Group 0: -0.084 cat(sprintf(\"  Group 1: %.3f\\n\", mean(sim_cov$theta[group == 1]))) #>   Group 1: 0.519 cat(sprintf(\"  Difference: %.3f (expected: 0.5)\\n\",             mean(sim_cov$theta[group == 1]) - mean(sim_cov$theta[group == 0]))) #>   Difference: 0.602 (expected: 0.5)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent-distributions.html","id":"working-with-the-output-object","dir":"Articles","previous_headings":"","what":"9. Working with the Output Object","title":"Working with Latent Distributions","text":"sim_latentG() function returns latent_G object containing:","code":"sim <- sim_latentG(n = 100, shape = \"bimodal\", seed = 1)  # Available components names(sim) #> [1] \"theta\"          \"mu\"             \"sigma\"          \"eta_cov\"        #> [5] \"shape\"          \"shape_params\"   \"n\"              \"sample_moments\" #> [9] \"z\"  # The theta vector head(sim$theta) #> [1] -0.5611365  0.4327842 -0.5953282 -1.4776179  1.6598142  0.3882399  # The standardized z values (before scaling) head(sim$z) #> [1] -0.5611365  0.4327842 -0.5953282 -1.4776179  1.6598142  0.3882399  # Sample moments sim$sample_moments #> $mean #> [1] 0.005452304 #>  #> $sd #> [1] 0.9591602 #>  #> $skewness #> [1] -0.1115873 #>  #> $kurtosis #> [1] -1.109185"},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent-distributions.html","id":"extracting-theta-for-other-uses","dir":"Articles","previous_headings":"9. Working with the Output Object","what":"9.1 Extracting Theta for Other Uses","title":"Working with Latent Distributions","text":"","code":"# Get theta as a numeric vector theta_vec <- sim$theta  # Use in your own analysis mean(theta_vec) #> [1] 0.005452304"},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent-distributions.html","id":"connection-to-irt-framework","dir":"Articles","previous_headings":"","what":"10. Connection to IRT Framework","title":"Working with Latent Distributions","text":"Rasch/2PL model, latent distribution GG affects key quantities:","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent-distributions.html","id":"marginal-reliability","dir":"Articles","previous_headings":"10. Connection to IRT Framework","what":"10.1 Marginal Reliability","title":"Working with Latent Distributions","text":"w‚Äæ=œÉŒ∏2œÉŒ∏2+MSEM\\bar{w} = \\frac{\\sigma^2_\\theta}{\\sigma^2_\\theta + \\text{MSEM}} MSEM mean squared error measurement.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent-distributions.html","id":"expected-test-information","dir":"Articles","previous_headings":"10. Connection to IRT Framework","what":"10.2 Expected Test Information","title":"Working with Latent Distributions","text":"ùí•‚Äæ=ùîºG[ùí•(Œ∏)]\\bar{\\mathcal{J}} = \\mathbb{E}_G[\\mathcal{J}(\\theta)] Different latent shapes produce different expected information profiles, even identical item parameters.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent-distributions.html","id":"identifiability","dir":"Articles","previous_headings":"10. Connection to IRT Framework","what":"10.3 Identifiability","title":"Working with Latent Distributions","text":"model identification Rasch model, typically fix either: ùîº[Œ∏]=0\\mathbb{E}[\\theta] = 0 (location constraint), ‚àëiŒ≤i=0\\sum_i \\beta_i = 0 (item constraint) sim_latentG() function generates abilities mean 0 default, supporting first identification approach.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent-distributions.html","id":"how-latent-shape-affects-achievable-reliability","dir":"Articles","previous_headings":"","what":"11. How Latent Shape Affects Achievable Reliability","title":"Working with Latent Distributions","text":"Different latent shapes lead different achievable reliability ranges test design. section uses check_feasibility() rho_curve() explore connection.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent-distributions.html","id":"feasibility-across-shapes","dir":"Articles","previous_headings":"11. How Latent Shape Affects Achievable Reliability","what":"11.1 Feasibility Across Shapes","title":"Working with Latent Distributions","text":"Achievable reliability ranges across latent shapes (25-item Rasch)","code":"shapes_feas <- c(\"normal\", \"bimodal\", \"skew_pos\", \"heavy_tail\", \"uniform\") feas_results <- data.frame(   shape = character(), rho_tilde_min = numeric(), rho_tilde_max = numeric(),   rho_bar_min = numeric(), rho_bar_max = numeric(),   stringsAsFactors = FALSE )  for (sh in shapes_feas) {   feas <- check_feasibility(     n_items = 25, model = \"rasch\", latent_shape = sh,     item_source = \"parametric\", M = 5000L, seed = 42, verbose = FALSE   )   feas_results <- rbind(feas_results, data.frame(     shape = sh,     rho_tilde_min = feas$rho_range_info[1],     rho_tilde_max = feas$rho_range_info[2],     rho_bar_min = feas$rho_range_msem[1],     rho_bar_max = feas$rho_range_msem[2],     stringsAsFactors = FALSE   )) }  knitr::kable(   feas_results,   col.names = c(\"Shape\", \"rho_tilde min\", \"rho_tilde max\",                 \"rho_bar min\", \"rho_bar max\"),   digits = 4,   caption = \"Achievable reliability ranges across latent shapes (25-item Rasch)\" )"},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent-distributions.html","id":"reliability-curves-across-shapes","dir":"Articles","previous_headings":"11. How Latent Shape Affects Achievable Reliability","what":"11.2 Reliability Curves Across Shapes","title":"Working with Latent Distributions","text":"figure shows shapes can reach high reliability, require larger scaling factors cc compensate reduced average information ability mass spread away item difficulty region.","code":"shapes_curve <- c(\"normal\", \"bimodal\", \"skew_pos\", \"heavy_tail\") curve_colors <- c(\"#2166AC\", \"#B2182B\", \"#4DAF4A\", \"#984EA3\")  # Generate curves all_curves <- list() for (i in seq_along(shapes_curve)) {   all_curves[[i]] <- rho_curve(     n_items = 25, model = \"rasch\", latent_shape = shapes_curve[i],     item_source = \"parametric\", metric = \"info\",     M = 5000L, seed = 42, plot = FALSE   ) }  # Plot plot(NULL, xlim = c(0.1, 5), ylim = c(0, 1),      xlab = \"Scaling factor c\", ylab = expression(tilde(rho)(c)),      main = \"Reliability Curves by Latent Shape (25-item Rasch, info metric)\")  for (i in seq_along(shapes_curve)) {   lines(all_curves[[i]]$c, all_curves[[i]]$rho_tilde,         col = curve_colors[i], lwd = 2) }  abline(h = 0.80, col = \"gray40\", lty = 2, lwd = 1) text(4.5, 0.82, expression(rho * \" = 0.80\"), cex = 0.8, col = \"gray40\")  legend(\"bottomright\", legend = shapes_curve,        col = curve_colors, lwd = 2, cex = 0.8, bty = \"n\") grid(col = \"#CCCCCC\")"},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent-distributions.html","id":"calibrating-across-shapes","dir":"Articles","previous_headings":"11. How Latent Shape Affects Achievable Reliability","what":"11.3 Calibrating Across Shapes","title":"Working with Latent Distributions","text":"Use eqc_calibrate() different latent_shape arguments see calibrated c*c^* differs: Calibrated c* latent shape (target rho = 0.80, 25-item Rasch)","code":"shapes_cal <- c(\"normal\", \"bimodal\", \"skew_pos\", \"heavy_tail\", \"uniform\") cal_results <- data.frame(   shape = character(), c_star = numeric(),   achieved_rho = numeric(), stringsAsFactors = FALSE )  for (sh in shapes_cal) {   res <- eqc_calibrate(     target_rho = 0.80, n_items = 25, model = \"rasch\",     latent_shape = sh, item_source = \"parametric\",     M = 5000L, seed = 42   )   cal_results <- rbind(cal_results, data.frame(     shape = sh, c_star = res$c_star,     achieved_rho = res$achieved_rho, stringsAsFactors = FALSE   )) }  knitr::kable(   cal_results,   col.names = c(\"Shape\", \"c*\", \"Achieved rho\"),   digits = 4,   caption = \"Calibrated c* by latent shape (target rho = 0.80, 25-item Rasch)\" )"},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent-distributions.html","id":"using-sim_latentg-with-eqc_calibrate","dir":"Articles","previous_headings":"","what":"12. Using sim_latentG() with eqc_calibrate()","title":"Working with Latent Distributions","text":"using sim_latentG() part reliability-targeted simulation, specify parameters eqc_calibrate(): complete 6-step applied workflow, see vignette(\"applied-guide\").","code":"# Calibrate for a bimodal population eqc_result <- eqc_calibrate(   target_rho = 0.80,   n_items = 25,   model = \"rasch\",   latent_shape = \"bimodal\",   latent_params = list(shape_params = list(delta = 0.8)),   M = 5000L,   seed = 42 )  # Generate response data with the same distribution sim_data <- simulate_response_data(   result = eqc_result,   n_persons = 1000,   latent_shape = \"bimodal\",   latent_params = list(shape_params = list(delta = 0.8)),   seed = 123 )  cat(sprintf(\"Calibrated c* = %.4f, achieved rho = %.4f\\n\",             eqc_result$c_star, eqc_result$achieved_rho)) #> Calibrated c* = 0.9577, achieved rho = 0.8000 cat(sprintf(\"Response data: %d persons x %d items\\n\",             nrow(sim_data$response_matrix), ncol(sim_data$response_matrix))) #> Response data: 1000 persons x 25 items"},{"path":[]},{"path":[]},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent-distributions.html","id":"sample-size-considerations","dir":"Articles","previous_headings":"14. Practical Recommendations","what":"14.2 Sample Size Considerations","title":"Working with Latent Distributions","text":"stable Monte Carlo estimates: M = 10,000 eqc_calibrate() quadrature n = 500‚Äì2,000 per replication simulation studies Increase nn heavy-tailed highly multimodal shapes","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent-distributions.html","id":"reproducibility","dir":"Articles","previous_headings":"14. Practical Recommendations","what":"14.3 Reproducibility","title":"Working with Latent Distributions","text":"Always set seed reproducible results:","code":"sim1 <- sim_latentG(n = 100, shape = \"normal\", seed = 42) sim2 <- sim_latentG(n = 100, shape = \"normal\", seed = 42) identical(sim1$theta, sim2$theta)  # TRUE #> [1] TRUE"},{"path":"https://joonho112.github.io/IRTsimrel/articles/latent-distributions.html","id":"references","dir":"Articles","previous_headings":"","what":"15. References","title":"Working with Latent Distributions","text":"Lee, J. (2025). Reliability-targeted simulation item response data: Solving inverse design problem. arXiv preprint, arXiv:2512.16012. Baker, F. B., & Kim, S.-H. (2004). Item Response Theory: Parameter Estimation Techniques (2nd ed.). Marcel Dekker. Paganin, S., et al.¬†(2023). Computational strategies estimation performance Bayesian semiparametric item response theory models. Journal Educational Behavioral Statistics, 48(2), 147‚Äì188.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/quick-start.html","id":"overview","dir":"Articles","previous_headings":"","what":"1. Overview","title":"Quick Start: Your First Calibration in 5 Minutes","text":"vignette walks complete IRTsimrel workflow five minutes. end know : Calibrate item parameters hit target marginal reliability. Check feasibility visualize reliability curve. Generate simulated binary response dataset. Extract inspect calibrated parameters using S3 methods. Estimated time: 5 minutes. Prerequisites: IRTsimrel package needed. code chunks vignette use eval = TRUE run system IRTsimrel installed.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/quick-start.html","id":"calibrate","dir":"Articles","previous_headings":"","what":"2. Calibrate","title":"Quick Start: Your First Calibration in 5 Minutes","text":"core function eqc_calibrate(). Give target reliability, number items, measurement model, returns calibrated scaling factor c*c^* makes population reliability match target. Print result see key quantities: two numbers focus output: c* (scaling factor): baseline discriminations multiplied value. Rasch model baseline discriminations 1, calibrated discriminations equal c*c^* directly. larger c*c^* means test needs discriminating items reach target. achieved_rho: empirical reliability calibrated c*c^*, computed Monte Carlo quadrature sample. close target 0.80 ‚Äî typically absolute error less 10‚àí410^{-4}. model argument accepts \"rasch\" (discriminations equal) \"2pl\" (log-normal discrimination distribution). quick start use Rasch model; see vignette(\"applied-guide\") 2PL examples.","code":"result <- eqc_calibrate(   target_rho = 0.80,   n_items    = 20,   model      = \"rasch\",   seed       = 42,   M          = 5000L ) result #>  #> ======================================================= #>   Empirical Quadrature Calibration (EQC) Results #> ======================================================= #>  #> Calibration Summary: #>   Model                        : RASCH #>   Target reliability (rho*)    : 0.8000 #>   Achieved reliability         : 0.8000 #>   Absolute error               : 7.94e-07 #>   Scaling factor (c*)          : 1.0183 #>  #> Design Parameters: #>   Number of items (I)          : 20 #>   Quadrature points (M)        : 5000 #>   Reliability metric           : Average-information (tilde) #>   Latent variance              : 1.0099 #>  #> Convergence: #>   Root status                  : uniroot_success #>   Search bracket               : [0.300, 3.000] #>   Bracket reliabilities        : [0.3054, 0.9471] #>  #> Parameter Summaries: #>   theta:        mean = -0.014, sd = 1.005 #>   beta:         mean = -0.000, sd = 0.758, range = [-2.15, 1.12] #>   lambda_base:  mean = 1.000, sd = 0.000 #>   lambda_scaled: mean = 1.018, sd = 0.000"},{"path":"https://joonho112.github.io/IRTsimrel/articles/quick-start.html","id":"check-feasibility","dir":"Articles","previous_headings":"","what":"3. Check Feasibility","title":"Quick Start: Your First Calibration in 5 Minutes","text":"committing particular simulation design, good practice verify target reliability actually achievable. combinations test length, model, latent distribution can produce every reliability level. check_feasibility() reports range achievable reliabilities given configuration: output shows two ranges ‚Äî one reliability metric. target falls within rho_tilde (info) range, EQC can calibrate . falls within rho_bar (msem) range, SAC can calibrate . can also visualize reliability varies continuously scaling factor using rho_curve(). plot shows average-information metric (œÅÃÉ\\tilde{\\rho}, blue) MSEM-based metric (w‚Äæ\\bar{w}, red): Reliability curve 20-item Rasch test. average-information metric (blue) always lies MSEM-based metric (red) due Jensen‚Äôs inequality. two curves close together configuration. gap widens shorter tests non-normal latent distributions.","code":"feas <- check_feasibility(   n_items = 20,   model   = \"rasch\",   seed    = 42,   M       = 5000L ) #>  #> ======================================================= #>   Feasibility Check: Achievable Reliability Range #> ======================================================= #>  #>   Number of items  : 20 #>   Model            : RASCH #>   Latent shape     : normal #>   Latent variance  : 1.0099 #>   c range          : [0.10, 10.00] #>   Monte Carlo M    : 5000 #>  #> Achievable Reliability Ranges: #>   rho_tilde (info) : [0.0479, 0.9850] #>   rho_bar   (msem) : [0.0000, 0.8818] #>  #> Note: rho_tilde >= rho_bar always (Jensen's inequality). #>   Use rho_tilde range for EQC targets. #>   Use rho_bar range for SAC targets. curve_data <- rho_curve(   n_items = 20,   model   = \"rasch\",   metric  = \"both\",   M       = 5000L,   seed    = 42,   plot    = TRUE )"},{"path":"https://joonho112.github.io/IRTsimrel/articles/quick-start.html","id":"generate-data","dir":"Articles","previous_headings":"","what":"4. Generate Data","title":"Quick Start: Your First Calibration in 5 Minutes","text":"calibration result, simulate_response_data() generates binary response matrix using calibrated item parameters. function draws fresh latent abilities specified distribution produces responses according 2PL (Rasch) model calibrated discriminations: result list four components: response_matrix: N√ó\\times matrix binary (0/1) responses theta: true latent abilities person beta: item difficulties lambda: scaled item discriminations can verify item parameters match expect: quick diagnostic: plot proportion correct responses per item. Items extreme difficulties high low proportions: Proportion correct per item, ordered difficulty. Items near center difficulty distribution proportions near 0.50, extreme items show floor ceiling effects.","code":"sim <- simulate_response_data(   result    = result,   n_persons = 500,   seed      = 123 ) # Dimensions: 500 persons x 20 items dim(sim$response_matrix) #> [1] 500  20 # First 6 persons, first 8 items sim$response_matrix[1:6, 1:8] #>      item1 item2 item3 item4 item5 item6 item7 item8 #> [1,]     0     1     0     1     0     0     0     0 #> [2,]     0     1     0     1     1     0     1     0 #> [3,]     1     1     1     1     1     1     1     1 #> [4,]     1     0     0     1     0     1     1     1 #> [5,]     1     0     0     0     1     1     0     0 #> [6,]     1     1     1     1     1     1     1     1 # All scaled discriminations should equal c* summary(sim$lambda) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>   1.018   1.018   1.018   1.018   1.018   1.018  # Difficulty distribution summary(sim$beta) #>     Min.  1st Qu.   Median     Mean  3rd Qu.     Max.  #> -2.14978 -0.33975  0.04838  0.00000  0.37403  1.12028 p_correct <- colMeans(sim$response_matrix) item_order <- order(sim$beta)  barplot(   p_correct[item_order],   names.arg = item_order,   col  = \"steelblue\",   xlab = \"Item (ordered by difficulty)\",   ylab = \"Proportion Correct\",   main = \"Proportion Correct per Item\",   ylim = c(0, 1),   las  = 2,   cex.names = 0.7 ) abline(h = 0.5, lty = 2, col = \"gray50\")"},{"path":"https://joonho112.github.io/IRTsimrel/articles/quick-start.html","id":"extract-and-inspect","dir":"Articles","previous_headings":"","what":"5. Extract and Inspect","title":"Quick Start: Your First Calibration in 5 Minutes","text":"IRTsimrel result objects support standard S3 generics, can interact way lm glm objects.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/quick-start.html","id":"summary","dir":"Articles","previous_headings":"5. Extract and Inspect","what":"5.1 Summary","title":"Quick Start: Your First Calibration in 5 Minutes","text":"summary() returns compact overview calibration:","code":"summary(result) #> Summary: Empirical Quadrature Calibration (EQC) #> ================================================ #>   Model            : RASCH #>   Metric           : Average-information (tilde) #>   Number of items  : 20 #>   Quadrature (M)   : 5000 #>   Latent variance  : 1.0099 #>  #> Calibration Results: #>   Target rho*      : 0.8000 #>   Achieved rho     : 0.8000 #>   Absolute error   : 7.94e-07 #>   Scaling factor c*: 1.0183 #>   Root status      : uniroot_success"},{"path":"https://joonho112.github.io/IRTsimrel/articles/quick-start.html","id":"extract-coefficients","dir":"Articles","previous_headings":"5. Extract and Inspect","what":"5.2 Extract Coefficients","title":"Quick Start: Your First Calibration in 5 Minutes","text":"coef() returns tidy data frame calibrated item parameters ‚Äî one row per item: Rasch model, lambda_base always 1 lambda_scaled equals c*c^* every item. 2PL model, lambda_base vary across items lambda_scaled lambda_base * c*.","code":"item_pars <- coef(result) head(item_pars) #>   item_id         beta lambda_base lambda_scaled   c_star #> 1       1  0.217684472           1      1.018304 1.018304 #> 2       2  1.116752062           1      1.018304 1.018304 #> 3       3  0.456497288           1      1.018304 1.018304 #> 4       4  0.006913473           1      1.018304 1.018304 #> 5       5 -0.179849098           1      1.018304 1.018304 #> 6       6  0.027652529           1      1.018304 1.018304"},{"path":"https://joonho112.github.io/IRTsimrel/articles/quick-start.html","id":"predict-reliability-at-new-scaling-factors","dir":"Articles","previous_headings":"5. Extract and Inspect","what":"5.3 Predict Reliability at New Scaling Factors","title":"Quick Start: Your First Calibration in 5 Minutes","text":"predict() evaluates reliability function new scaling factor values. arguments, returns achieved reliability calibrated c*c^*: newdata, computes reliability specified value cc: useful understanding sensitive reliability discrimination level. instance, c=0.5c = 0.5 test substantially less reliable, c=2.0c = 2.0 reliable needed.","code":"# Achieved reliability at c* predict(result) #> [1] 0.8000008 # Reliability at several scaling factors predict(result, newdata = c(0.5, 1.0, 1.5, 2.0)) #>     c=0.5     c=1.0     c=1.5     c=2.0  #> 0.5369213 0.7952739 0.8784820 0.9150086"},{"path":"https://joonho112.github.io/IRTsimrel/articles/quick-start.html","id":"validate-optional","dir":"Articles","previous_headings":"","what":"6. Validate (Optional)","title":"Quick Start: Your First Calibration in 5 Minutes","text":"added confidence calibration, can run SAC (Stochastic Approximation Calibration) independent check. SAC uses completely different algorithm (Robbins-Monro stochastic approximation) solve calibration problem, agreement EQC SAC strong evidence found correct c*c^*. Passing EQC result c_init provides warm start makes SAC converge iterations: Compare two algorithms side side: comparison reports absolute percent difference two c*c^* values. percent difference 5%, two algorithms agreement (typically difference 1%). can also visualize SAC convergence trajectory verify iterations stabilized near EQC warm start: SAC convergence trajectory. top panel shows scaling factor c across iterations, bottom panel shows per-iteration reliability estimates. warm start EQC ensures rapid convergence. top panel shows scaling factor trajectory, stabilize quickly initialized EQC. bottom panel shows noisy per-iteration reliability estimates oscillating around target value (dashed red line). Polyak-Ruppert average (reported c*c^*) smooths iteration--iteration noise.","code":"sac_result <- sac_calibrate(   target_rho = 0.80,   n_items    = 20,   model      = \"rasch\",   c_init     = result,   n_iter     = 100L,   M_per_iter = 500L,   seed       = 42 ) comp <- compare_eqc_sac(result, sac_result) #> Warning in compare_eqc_sac(result, sac_result): Reliability metric differs #> between EQC ('info') and SAC ('msem'). #>  #> ======================================================= #>   EQC vs SAC Comparison #> ======================================================= #>  #>   Target reliability  : 0.8000 #>   EQC c*              : 1.018304 #>   SAC c*              : 1.060003 #>   Absolute difference : 0.041699 #>   Percent difference  : 4.09% #>   Agreement (< 5%)    : YES #> plot(sac_result, type = \"both\")"},{"path":"https://joonho112.github.io/IRTsimrel/articles/quick-start.html","id":"putting-it-all-together","dir":"Articles","previous_headings":"","what":"7. Putting It All Together","title":"Quick Start: Your First Calibration in 5 Minutes","text":"complete workflow single code block, calibration validated data generation:","code":"library(IRTsimrel)  # Step 1: Check feasibility feas <- check_feasibility(n_items = 20, model = \"rasch\", seed = 42)  # Step 2: Calibrate with EQC eqc_res <- eqc_calibrate(   target_rho = 0.80, n_items = 20, model = \"rasch\",   seed = 42, M = 5000L )  # Step 3: Validate with SAC (optional but recommended) sac_res <- sac_calibrate(   target_rho = 0.80, n_items = 20, model = \"rasch\",   c_init = eqc_res, n_iter = 100L, seed = 42 ) compare_eqc_sac(eqc_res, sac_res)  # Step 4: Generate response data sim_data <- simulate_response_data(   result = eqc_res, n_persons = 1000, seed = 123 )  # Step 5: Use the data in your analysis dim(sim_data$response_matrix)  # 1000 x 20"},{"path":"https://joonho112.github.io/IRTsimrel/articles/quick-start.html","id":"whats-next","dir":"Articles","previous_headings":"","what":"8. What‚Äôs Next?","title":"Quick Start: Your First Calibration in 5 Minutes","text":"now completed full calibrate-generate-validate cycle. directions deeper exploration: vignette(\"applied-guide\"): Comprehensive applied tutorial covering 2PL models, non-normal latent distributions, IRW-based item sources, factorial simulation designs multiple reliability levels. vignette(\"latent-distributions\"): Explore 12 latent distribution shapes available sim_latentG() learn use one different research scenarios. vignette(\"item-parameters\"): Parametric, IRW, hierarchical, custom item generation methods, including correlated difficulty-discrimination parameters. vignette(\"theory-reliability\"): Mathematical foundations two reliability metrics (œÅÃÉ\\tilde{\\rho} w‚Äæ\\bar{w}), Jensen‚Äôs inequality, theoretical justification calibration approach. vignette(\"api-reference\"): Full function reference complete signatures, arguments, return values, runnable examples every exported function.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/quick-start.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Quick Start: Your First Calibration in 5 Minutes","text":"Lee, J. (2025). Reliability-targeted simulation item response data: Solving inverse design problem. arXiv preprint, arXiv:2512.16012.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/simulation-design.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Designing IRT Simulation Studies with Reliability Control","text":"Reading time: approximately 25‚Äì30 minutes. vignette shows use IRTsimrel design rigorous, reproducible IRT simulation studies reliability explicit design factor. end vignette able : Articulate marginal reliability must controlled simulation designs. Set complete factorial design crosses reliability factors. Screen cells feasibility committing calibration. Visualize reliability curves across design conditions. Execute batch calibration batch data generation across cells. Verify achieved reliability matches target every cell. Apply recommended practices seed management, reporting, parallelization. Prerequisites: familiarity eqc_calibrate() basics IRT simulation. See vignette(\"introduction\") background.","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/simulation-design.html","id":"the-icc-analogy","dir":"Articles","previous_headings":"Why Reliability Should Be a Design Factor","what":"The ICC analogy","title":"Designing IRT Simulation Studies with Reliability Control","text":"multilevel modeling (MLM), competent simulation study omit intraclass correlation (ICC) factorial design. ICC determines signal--noise ratio cluster level, every methodological conclusion conditioned ratio. Studying new estimator ICC = 0.10 tells us nothing performs ICC = 0.30. Marginal reliability plays exactly role IRT. captures proportion latent variance ‚Äúsignal‚Äù versus ‚Äúnoise,‚Äù governs precision every person-parameter estimate. Yet vast majority published IRT simulation studies, reliability neither controlled even reported. analogy precise:","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/simulation-design.html","id":"what-happens-without-reliability-control","dir":"Articles","previous_headings":"Why Reliability Should Be a Design Factor","what":"What happens without reliability control","title":"Designing IRT Simulation Studies with Reliability Control","text":"reliability controlled, several problems arise: Confounded comparisons: two models may appear differ structural properties operate different reliability levels. ‚Äúwinning‚Äù model may simply handed better data. Limited generalizability: results obtained unknown reliability (implicitly determined item parameter choices) generalize reliability regimes. Irreproducibility: without knowing implied reliability, another researcher replicate exact simulation conditions. Ecological invalidity: real-world assessments span wide range reliabilities (0.50 0.95). simulation explores one unknown reliability point misses range.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/simulation-design.html","id":"a-cautionary-tale","dir":"Articles","previous_headings":"Why Reliability Should Be a Design Factor","what":"A cautionary tale","title":"Designing IRT Simulation Studies with Reliability Control","text":"Consider researcher wants compare Rasch model 2PL model terms item-difficulty recovery. naive design might fix 20 items, normal abilities, 500 persons, generate one Rasch data set one 2PL data set. researcher finds RMSE substantially larger 2PL model concludes Rasch model recovers difficulty better. problem: two data sets may different reliabilities. 2PL data happen lower reliability (discriminations drawn), higher RMSE artifact noisier data, property generating model. conclusion confounded. IRTsimrel, researcher can hold reliability constant across models. remaining difference RMSE attributable model structure, data quality. conditions now operate marginal reliability. downstream difference RMSE reflects structural difference Rasch 2PL, accidental reliability imbalance.","code":"# Calibrate Rasch and 2PL to the SAME reliability eqc_rasch <- eqc_calibrate(   target_rho = 0.80, n_items = 20, model = \"rasch\",   item_source = \"parametric\", M = 5000L, seed = 42 )  eqc_2pl <- eqc_calibrate(   target_rho = 0.80, n_items = 20, model = \"2pl\",   item_source = \"parametric\", M = 5000L, seed = 42 )  cat(sprintf(\"Rasch achieved rho: %.4f  (c* = %.4f)\\n\",             eqc_rasch$achieved_rho, eqc_rasch$c_star)) #> Rasch achieved rho: 0.8000  (c* = 1.0183) cat(sprintf(\"2PL   achieved rho: %.4f  (c* = %.4f)\\n\",             eqc_2pl$achieved_rho, eqc_2pl$c_star)) #> 2PL   achieved rho: 0.8000  (c* = 0.9026)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/simulation-design.html","id":"reliability-as-an-experimental-control","dir":"Articles","previous_headings":"Why Reliability Should Be a Design Factor","what":"Reliability as an experimental control","title":"Designing IRT Simulation Studies with Reliability Control","text":"Controlling reliability IRT simulation analogous controlling temperature chemistry experiment. never compare two reactions different temperatures attribute difference solely reagents. Similarly, comparing two IRT models different reliabilities conflates model structure data quality. IRTsimrel enables control solving inverse design problem: given target reliability œÅ*\\rho^*, find global discrimination scaling factor c*c^* population reliability equals œÅ*\\rho^*. achieved eqc_calibrate() function, uses deterministic root-finding (Brent‚Äôs method) monotone reliability curve.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/simulation-design.html","id":"the-factorial-design-framework","dir":"Articles","previous_headings":"","what":"The Factorial Design Framework","title":"Designing IRT Simulation Studies with Reliability Control","text":"well-designed simulation study crosses multiple factors map operating characteristics method study. natural four-factor design IRT research :","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/simulation-design.html","id":"building-the-design-matrix","dir":"Articles","previous_headings":"The Factorial Design Framework","what":"Building the design matrix","title":"Designing IRT Simulation Studies with Reliability Control","text":"24 design cells. calibrating , verify every cell feasible‚Äîtarget reliability can actually achieved given item latent configuration.","code":"design <- expand.grid(   reliability  = c(0.60, 0.70, 0.80),   n_items      = c(15, 30),   latent_shape = c(\"normal\", \"skew_pos\"),   model        = c(\"rasch\", \"2pl\"),   stringsAsFactors = FALSE )  cat(sprintf(\"Total cells: %d\\n\", nrow(design))) #> Total cells: 24 head(design, 8) #>   reliability n_items latent_shape model #> 1         0.6      15       normal rasch #> 2         0.7      15       normal rasch #> 3         0.8      15       normal rasch #> 4         0.6      30       normal rasch #> 5         0.7      30       normal rasch #> 6         0.8      30       normal rasch #> 7         0.6      15     skew_pos rasch #> 8         0.7      15     skew_pos rasch"},{"path":"https://joonho112.github.io/IRTsimrel/articles/simulation-design.html","id":"choosing-factor-levels","dir":"Articles","previous_headings":"The Factorial Design Framework","what":"Choosing factor levels","title":"Designing IRT Simulation Studies with Reliability Control","text":"selecting factor levels, consider guidelines: Reliability: include least three levels spanning range relevant research context. Educational testing typically ranges 0.60 (formative assessments) 0.90 (high-stakes tests). Test length: include least two lengths bracket typical range application domain. Short forms (10‚Äì15 items) standard forms (25‚Äì40 items) common. Latent distributions: always include \"normal\" baseline. Add one two non-normal shapes test robustness. Good choices include \"skew_pos\" (selective admissions) \"bimodal\" (heterogeneous populations). Model: include \"rasch\" \"2pl\" study involves model comparison robustness analysis.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/simulation-design.html","id":"feasibility-screening","dir":"Articles","previous_headings":"","what":"Feasibility Screening","title":"Designing IRT Simulation Studies with Reliability Control","text":"check_feasibility() function computes achievable reliability range given test design. loop every cell record whether target reliability falls within range ‚Äúinfo‚Äù metric (default recommended metric EQC). Feasibility screening always precede calibration. fast (fraction second per cell) prevents wasted effort infeasible conditions.","code":"# Screen all cells design$feasible <- NA design$rho_max  <- NA design$rho_min  <- NA  for (i in seq_len(nrow(design))) {   feas <- check_feasibility(     n_items      = design$n_items[i],     model        = design$model[i],     latent_shape = design$latent_shape[i],     item_source  = \"parametric\",     c_bounds     = c(0.1, 10),     M            = 5000L,     seed         = 42,     verbose      = FALSE   )   design$rho_min[i]  <- feas$rho_range_info[1]   design$rho_max[i]  <- feas$rho_range_info[2]   design$feasible[i] <- design$reliability[i] >= feas$rho_range_info[1] &                          design$reliability[i] <= feas$rho_range_info[2] }  # Display summary cat(sprintf(\"Feasible cells  : %d / %d\\n\",             sum(design$feasible), nrow(design))) #> Feasible cells  : 24 / 24 cat(sprintf(\"Infeasible cells: %d\\n\", sum(!design$feasible))) #> Infeasible cells: 0  # Show the infeasible cells if any if (any(!design$feasible)) {   cat(\"\\nInfeasible cells:\\n\")   print(design[!design$feasible, ]) } # Create a compact summary by n_items x model feas_summary <- aggregate(   cbind(rho_min, rho_max) ~ n_items + model,   data = design, FUN = function(x) round(mean(x), 3) ) names(feas_summary)[3:4] <- c(\"avg_rho_min\", \"avg_rho_max\") print(feas_summary) #>   n_items model avg_rho_min avg_rho_max #> 1      15   2pl       0.042       0.978 #> 2      30   2pl       0.082       0.990 #> 3      15 rasch       0.036       0.977 #> 4      30 rasch       0.070       0.989"},{"path":"https://joonho112.github.io/IRTsimrel/articles/simulation-design.html","id":"interpreting-feasibility-results","dir":"Articles","previous_headings":"Feasibility Screening","what":"Interpreting feasibility results","title":"Designing IRT Simulation Studies with Reliability Control","text":"output shows range [œÅmin,œÅmax][\\rho_{\\min}, \\rho_{\\max}] achievable cell. Key patterns look : Short tests (e.g., 15 items) lower maximum achievable reliability long tests, fewer items provide less total information. Rasch vs.¬†2PL: 2PL model may slightly different achievable range varying discriminations change effective information. Non-normal latent distributions: skewed heavy-tailed distributions may shift achievable range test information depends ability distribution.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/simulation-design.html","id":"when-cells-are-infeasible","dir":"Articles","previous_headings":"Feasibility Screening","what":"When cells are infeasible","title":"Designing IRT Simulation Studies with Reliability Control","text":"cell infeasible, several options: Increase c_bounds[2] (allow stronger discrimination scaling). Increase n_items cell. Drop reliability level design. Accept achievable maximum note deviation. remaining sections proceed feasible cells .","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/simulation-design.html","id":"reliability-curves-across-conditions","dir":"Articles","previous_headings":"","what":"Reliability Curves Across Conditions","title":"Designing IRT Simulation Studies with Reliability Control","text":"Reliability curves show œÅ(c)\\rho(c) varies scaling factor cc. help understand shape range achievable reliability design condition. rho_curve() function computes reliability grid cc values using Monte Carlo integration quadrature approach used eqc_calibrate(). visualization serves three purposes: Confirms monotonicity: info metric œÅÃÉ(c)\\tilde{\\rho}(c) strictly increasing cc. Shows achievable range: vertical extent curve. Identifies calibration occurs: horizontal position curve crosses target reliability. Reliability curves four design conditions. Dashed red lines mark target reliabilities 0.70 0.80. Differences curve shape reflect test length latent distribution affect reliability-discrimination relationship. Key observations reliability curves: Longer tests reach reliability smaller scaling factor cc. example, 30 items might achieve œÅÃÉ=0.80\\tilde{\\rho} = 0.80 c‚âà1.2c \\approx 1.2, whereas 15 items might require c‚âà2.0c \\approx 2.0. 2PL model reaches high reliability faster varying discriminations contribute additional information per item average. Skewed latent distributions shift curve slightly, test information concentrates items informative. latent distribution places mass regions lower information, reliability curve lower. curves monotonically increasing cc, confirming info metric well-suited root-finding via uniroot().","code":"# Select four representative conditions conditions <- list(   list(n_items = 15, model = \"rasch\",  latent_shape = \"normal\",        label = \"15 items, Rasch, Normal\"),   list(n_items = 30, model = \"rasch\",  latent_shape = \"normal\",        label = \"30 items, Rasch, Normal\"),   list(n_items = 15, model = \"2pl\",    latent_shape = \"normal\",        label = \"15 items, 2PL, Normal\"),   list(n_items = 30, model = \"rasch\",  latent_shape = \"skew_pos\",        label = \"30 items, Rasch, Skew+\") )  c_grid <- seq(0.1, 5, length.out = 40)  oldpar <- par(mfrow = c(2, 2), mar = c(4, 4, 3, 1))  for (cond in conditions) {   curve_data <- rho_curve(     c_values     = c_grid,     n_items      = cond$n_items,     model        = cond$model,     latent_shape = cond$latent_shape,     item_source  = \"parametric\",     metric       = \"info\",     M            = 5000L,     seed         = 42,     plot         = FALSE   )    plot(curve_data$c, curve_data$rho_tilde, type = \"l\", lwd = 2,        col = \"steelblue\", ylim = c(0, 1),        xlab = \"Scaling factor c\", ylab = expression(tilde(rho)),        main = cond$label, cex.main = 0.9)   abline(h = 0.70, col = \"red\", lty = 2)   abline(h = 0.80, col = \"red\", lty = 3) } par(oldpar)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/simulation-design.html","id":"batch-calibration","dir":"Articles","previous_headings":"","what":"Batch Calibration","title":"Designing IRT Simulation Studies with Reliability Control","text":"design validated, calibrate every feasible cell. code stores results list indexed cell number. key principle: calibrate , generate many times. calibrated parameters (item difficulties, scaled discriminations, quadrature sample) fixed given cell. Multiple replications vary person sample. calibration errors typically order 10‚àí510^{-5} 10‚àí410^{-4}, confirming EQC achieves target excellent precision.","code":"# Keep only feasible cells design_feasible <- design[design$feasible, ]  # Storage results_list <- vector(\"list\", nrow(design_feasible))  for (i in seq_len(nrow(design_feasible))) {   d <- design_feasible[i, ]    res <- eqc_calibrate(     target_rho   = d$reliability,     n_items      = d$n_items,     model        = d$model,     latent_shape = d$latent_shape,     item_source  = \"parametric\",     M            = 5000L,     seed         = 42,     verbose      = FALSE   )    results_list[[i]] <- res }  # Attach achieved reliability to the design frame design_feasible$achieved_rho <- vapply(   results_list, function(r) r$achieved_rho, numeric(1) ) design_feasible$c_star <- vapply(   results_list, function(r) r$c_star, numeric(1) ) design_feasible$abs_error <- abs(   design_feasible$achieved_rho - design_feasible$reliability )  cat(sprintf(\"Mean absolute error: %.6f\\n\", mean(design_feasible$abs_error))) #> Mean absolute error: 0.000002 cat(sprintf(\"Max  absolute error: %.6f\\n\", max(design_feasible$abs_error))) #> Max  absolute error: 0.000012"},{"path":"https://joonho112.github.io/IRTsimrel/articles/simulation-design.html","id":"examining-the-calibrated-scaling-factors","dir":"Articles","previous_headings":"Batch Calibration","what":"Examining the calibrated scaling factors","title":"Designing IRT Simulation Studies with Reliability Control","text":"calibrated c*c^* values reveal much discrimination scaling needed reach target reliability: Note c*>1c^* > 1 means baseline discriminations scaled (items made discriminating), c*<1c^* < 1 means scaled . Higher target reliability generally requires larger c*c^*, longer tests require smaller c*c^* target.","code":"# Show c* by condition cstar_table <- design_feasible[, c(\"model\", \"n_items\", \"latent_shape\",                                     \"reliability\", \"c_star\")] cstar_table$c_star <- round(cstar_table$c_star, 4) print(cstar_table) #>    model n_items latent_shape reliability c_star #> 1  rasch      15       normal         0.6 0.6789 #> 2  rasch      15       normal         0.7 0.8793 #> 3  rasch      15       normal         0.8 1.2343 #> 4  rasch      30       normal         0.6 0.4632 #> 5  rasch      30       normal         0.7 0.5900 #> 6  rasch      30       normal         0.8 0.8042 #> 7  rasch      15     skew_pos         0.6 0.7078 #> 8  rasch      15     skew_pos         0.7 0.9342 #> 9  rasch      15     skew_pos         0.8 1.3542 #> 10 rasch      30     skew_pos         0.6 0.4654 #> 11 rasch      30     skew_pos         0.7 0.5933 #> 12 rasch      30     skew_pos         0.8 0.8090 #> 13   2pl      15       normal         0.6 0.5791 #> 14   2pl      15       normal         0.7 0.7555 #> 15   2pl      15       normal         0.8 1.0716 #> 16   2pl      30       normal         0.6 0.4237 #> 17   2pl      30       normal         0.7 0.5417 #> 18   2pl      30       normal         0.8 0.7425 #> 19   2pl      15     skew_pos         0.6 0.7357 #> 20   2pl      15     skew_pos         0.7 0.9678 #> 21   2pl      15     skew_pos         0.8 1.3950 #> 22   2pl      30     skew_pos         0.6 0.4347 #> 23   2pl      30     skew_pos         0.7 0.5550 #> 24   2pl      30     skew_pos         0.8 0.7580"},{"path":"https://joonho112.github.io/IRTsimrel/articles/simulation-design.html","id":"batch-data-generation","dir":"Articles","previous_headings":"","what":"Batch Data Generation","title":"Designing IRT Simulation Studies with Reliability Control","text":"calibration, generate response data cell. real study embed replication loop; generate single data set per cell illustration.","code":"sim_data_list <- vector(\"list\", nrow(design_feasible))  for (i in seq_len(nrow(design_feasible))) {   d <- design_feasible[i, ]    sim_data_list[[i]] <- simulate_response_data(     result       = results_list[[i]],     n_persons    = 300,     latent_shape = d$latent_shape,     seed         = 100 + i   ) }  # Quick check: dimensions of first and last cat(sprintf(\"Cell 1  : %d persons x %d items\\n\",             nrow(sim_data_list[[1]]$response_matrix),             ncol(sim_data_list[[1]]$response_matrix))) #> Cell 1  : 300 persons x 15 items cat(sprintf(\"Cell %d : %d persons x %d items\\n\",             nrow(design_feasible),             nrow(sim_data_list[[nrow(design_feasible)]]$response_matrix),             ncol(sim_data_list[[nrow(design_feasible)]]$response_matrix))) #> Cell 24 : 300 persons x 30 items"},{"path":"https://joonho112.github.io/IRTsimrel/articles/simulation-design.html","id":"replication-loop-pattern","dir":"Articles","previous_headings":"Batch Data Generation","what":"Replication loop pattern","title":"Designing IRT Simulation Studies with Reliability Control","text":"real simulation study, data generation step embedded replication loop. following pattern demonstrates structure:","code":"R <- 500  # Number of replications  for (i in seq_len(nrow(design_feasible))) {   d <- design_feasible[i, ]    for (r in seq_len(R)) {     sim <- simulate_response_data(       result       = results_list[[i]],       n_persons    = 1000,       latent_shape = d$latent_shape,       seed         = 1000 * i + r  # Unique seed per cell x replication     )      # --- Your analysis code here ---     # For example:     # p_items <- colMeans(sim$response_matrix)     # beta_hat <- -log(pmax(p_items, 0.001) / pmax(1 - p_items, 0.001))     # beta_hat <- beta_hat - mean(beta_hat)     # rmse <- sqrt(mean((beta_hat - sim$beta)^2))     # Store rmse in output data frame   } }"},{"path":"https://joonho112.github.io/IRTsimrel/articles/simulation-design.html","id":"verification","dir":"Articles","previous_headings":"","what":"Verification","title":"Designing IRT Simulation Studies with Reliability Control","text":"critical step: verify finite-sample data actually exhibit reliability close target. Without external TAM validation (requires TAM package), use population-level achieved reliability calibration object. achieved reliability EQC population value conditioned quadrature sample.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/simulation-design.html","id":"verification-table","dir":"Articles","previous_headings":"Verification","what":"Verification table","title":"Designing IRT Simulation Studies with Reliability Control","text":"","code":"# Build verification table verify_df <- data.frame(   cell         = seq_len(nrow(design_feasible)),   model        = design_feasible$model,   n_items      = design_feasible$n_items,   latent_shape = design_feasible$latent_shape,   target_rho   = design_feasible$reliability,   achieved_rho = round(design_feasible$achieved_rho, 6),   c_star       = round(design_feasible$c_star, 4),   abs_error    = format(design_feasible$abs_error, scientific = TRUE, digits = 2) )  print(verify_df) #>    cell model n_items latent_shape target_rho achieved_rho c_star abs_error #> 1     1 rasch      15       normal        0.6     0.600000 0.6789   1.5e-07 #> 2     2 rasch      15       normal        0.7     0.700000 0.8793   1.4e-07 #> 3     3 rasch      15       normal        0.8     0.800001 1.2343   1.4e-06 #> 4     4 rasch      30       normal        0.6     0.600012 0.4632   1.2e-05 #> 5     5 rasch      30       normal        0.7     0.700000 0.5900   2.7e-08 #> 6     6 rasch      30       normal        0.8     0.800000 0.8042   1.4e-07 #> 7     7 rasch      15     skew_pos        0.6     0.599999 0.7078   7.4e-07 #> 8     8 rasch      15     skew_pos        0.7     0.700000 0.9342   2.8e-07 #> 9     9 rasch      15     skew_pos        0.8     0.800000 1.3542   1.2e-09 #> 10   10 rasch      30     skew_pos        0.6     0.600012 0.4654   1.2e-05 #> 11   11 rasch      30     skew_pos        0.7     0.700000 0.5933   1.9e-08 #> 12   12 rasch      30     skew_pos        0.8     0.800000 0.8090   2.5e-07 #> 13   13   2pl      15       normal        0.6     0.600004 0.5791   4.2e-06 #> 14   14   2pl      15       normal        0.7     0.699999 0.7555   5.2e-07 #> 15   15   2pl      15       normal        0.8     0.800000 1.0716   4.1e-07 #> 16   16   2pl      30       normal        0.6     0.600002 0.4237   1.6e-06 #> 17   17   2pl      30       normal        0.7     0.699999 0.5417   1.0e-06 #> 18   18   2pl      30       normal        0.8     0.800002 0.7425   1.6e-06 #> 19   19   2pl      15     skew_pos        0.6     0.599998 0.7357   2.1e-06 #> 20   20   2pl      15     skew_pos        0.7     0.700000 0.9678   1.6e-07 #> 21   21   2pl      15     skew_pos        0.8     0.800002 1.3950   1.7e-06 #> 22   22   2pl      30     skew_pos        0.6     0.600003 0.4347   2.6e-06 #> 23   23   2pl      30     skew_pos        0.7     0.700000 0.5550   1.0e-07 #> 24   24   2pl      30     skew_pos        0.8     0.800000 0.7580   1.3e-07"},{"path":"https://joonho112.github.io/IRTsimrel/articles/simulation-design.html","id":"verification-plot","dir":"Articles","previous_headings":"Verification","what":"Verification plot","title":"Designing IRT Simulation Studies with Reliability Control","text":"Verification plot: achieved versus target reliability across feasible cells. Points near diagonal indicate precise calibration. points lie essentially diagonal, confirming calibration precise within Monte Carlo tolerance quadrature sample.","code":"# Color by model cols <- ifelse(design_feasible$model == \"rasch\", \"steelblue\", \"coral\") pchs <- ifelse(design_feasible$n_items == 15, 19, 17)  plot(design_feasible$reliability, design_feasible$achieved_rho,      pch = pchs, col = cols, cex = 1.3,      xlab = \"Target Reliability\", ylab = \"Achieved Reliability\",      main = \"Calibration Verification: Target vs. Achieved\",      xlim = c(0.55, 0.85), ylim = c(0.55, 0.85)) abline(0, 1, col = \"red\", lty = 2, lwd = 2)  # Annotate with max error max_err <- max(design_feasible$abs_error) legend(\"topleft\",        legend = c(sprintf(\"Max |error| = %.2e\", max_err),                   \"Rasch\", \"2PL\", \"15 items\", \"30 items\"),        col = c(NA, \"steelblue\", \"coral\", \"black\", \"black\"),        pch = c(NA, 19, 19, 19, 17),        bty = \"n\", cex = 0.8)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/simulation-design.html","id":"external-validation-with-tam","dir":"Articles","previous_headings":"Verification","what":"External validation with TAM","title":"Designing IRT Simulation Studies with Reliability Control","text":"rigorous validation, can additionally compute reliability using TAM package. requires TAM installed: See vignette(\"validation\") guidance interpreting WLE vs.¬†EAP reliability TAM.","code":"# External validation (requires TAM package) library(TAM)  for (i in seq_len(nrow(design_feasible))) {   tam_rel <- compute_reliability_tam(     resp  = sim_data_list[[i]]$response_matrix,     model = design_feasible$model[i],     verbose = FALSE   )    cat(sprintf(\"Cell %2d: target = %.3f, WLE = %.3f, EAP = %.3f\\n\",               i, design_feasible$reliability[i],               tam_rel$rel_wle, tam_rel$rel_eap)) }"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/simulation-design.html","id":"seed-management-for-reproducibility","dir":"Articles","previous_headings":"Practical Considerations","what":"Seed management for reproducibility","title":"Designing IRT Simulation Studies with Reliability Control","text":"reproducible simulation study requires two levels seed management: Calibration seed: controls quadrature sample item parameters. Use fixed seed (e.g., seed = 42) across cells. mean cells get items; seed interacts cell-specific parameters (model, latent shape, etc.). Replication seeds: replication r=1,‚Ä¶,Rr = 1, \\ldots, R, pass seed = r (another deterministic mapping) simulate_response_data(). ensures replication independently reproducible. recommended pattern encodes cell index replication index seed: Important: IRTsimrel saves restores .Random.seed state inside eqc_calibrate() simulate_response_data() seed specified. means setting seed inside functions affect global RNG state.","code":"# Recommended seed pattern CALIB_SEED <- 42  for (cell in seq_len(n_cells)) {   res <- eqc_calibrate(..., seed = CALIB_SEED)    for (r in seq_len(R)) {     sim <- simulate_response_data(res, n_persons = N,                                    seed = 1000 * cell + r)     # ... analysis ...   } }"},{"path":"https://joonho112.github.io/IRTsimrel/articles/simulation-design.html","id":"result-organization","dir":"Articles","previous_headings":"Practical Considerations","what":"Result organization","title":"Designing IRT Simulation Studies with Reliability Control","text":"Store simulation output structured data frames. Pre-allocating data frame efficient growing rbind() inside loop, clarity show patterns:","code":"# Pre-allocate storage (efficient) n_total <- nrow(design_feasible) * R output <- data.frame(   cell         = integer(n_total),   rep          = integer(n_total),   target_rho   = numeric(n_total),   model        = character(n_total),   n_items      = integer(n_total),   latent_shape = character(n_total),   rmse_beta    = numeric(n_total),   bias_beta    = numeric(n_total),   stringsAsFactors = FALSE )"},{"path":"https://joonho112.github.io/IRTsimrel/articles/simulation-design.html","id":"computational-scaling","dir":"Articles","previous_headings":"Practical Considerations","what":"Computational scaling","title":"Designing IRT Simulation Studies with Reliability Control","text":"Calibration cost dominated M√óIM \\times matrix computation inside eqc_calibrate(). rough guide: Data generation via simulate_response_data() fast (< 0.1 s N = 1,000, = 30). typical study 24 cells, M=10,000M = 10{,}000, R=500R = 500 replications N=1,000N = 1{,}000: Calibration: ~24 seconds total (one-time cost). Data generation: ~24 x 500 x 0.05 = ~600 seconds (~10 minutes). Analysis time depends estimator.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/simulation-design.html","id":"parallelization","dir":"Articles","previous_headings":"Practical Considerations","what":"Parallelization","title":"Designing IRT Simulation Studies with Reliability Control","text":"large designs, cells can calibrated parallel independent. following pattern uses future.apply package: Replication loops can also parallelized. Ensure parallel worker uses unique seed:","code":"library(future.apply) plan(multisession, workers = 4)  results_list <- future_lapply(seq_len(nrow(design_feasible)), function(i) {   d <- design_feasible[i, ]   eqc_calibrate(     target_rho   = d$reliability,     n_items      = d$n_items,     model        = d$model,     latent_shape = d$latent_shape,     item_source  = \"parametric\",     M            = 10000L,     seed         = 42   ) }, future.seed = TRUE) # Parallelize replications within a cell rep_results <- future_lapply(seq_len(R), function(r) {   sim <- simulate_response_data(     result    = calib_result,     n_persons = N,     seed      = 1000 * cell_idx + r   )   # ... analysis ...   # return(list(rmse = rmse, bias = bias)) }, future.seed = TRUE)"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/simulation-design.html","id":"what-to-report-in-a-simulation-methods-section","dir":"Articles","previous_headings":"Reporting Standards","what":"What to report in a simulation Methods section","title":"Designing IRT Simulation Studies with Reliability Control","text":"simulation study using IRTsimrel report, minimum:","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/simulation-design.html","id":"reporting-checklist","dir":"Articles","previous_headings":"Reporting Standards","what":"Reporting checklist","title":"Designing IRT Simulation Studies with Reliability Control","text":"State target reliability levels metric used (info vs.¬†msem). Report calibration algorithm key parameters (M, c_bounds, tol). Document feasibility screening results. Report maximum absolute calibration error across cells. Describe item parameter source generation method. State latent distribution(s) shape parameters. Report number replications persons per replication. Describe seed management reproducibility. Cite Lee (2025) IRTsimrel package.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/simulation-design.html","id":"results-table-template","dir":"Articles","previous_headings":"Reporting Standards","what":"Results table template","title":"Designing IRT Simulation Studies with Reliability Control","text":"following table format recommended presenting results across factorial design reliability factor:","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/simulation-design.html","id":"methods-paragraph-template","dir":"Articles","previous_headings":"Reporting Standards","what":"Methods paragraph template","title":"Designing IRT Simulation Studies with Reliability Control","text":"complete, self-contained methods paragraph can adapted manuscript. Replace bracketed placeholders study‚Äôs values. employed [3] (target reliability: [0.60, 0.70, 0.80]) √ó\\times [2] (test length: [15, 30] items) √ó\\times [2] (latent distribution: [normal, positively skewed]) √ó\\times [2] (model: [Rasch, 2PL]) fully crossed factorial design, yielding [24] conditions. Item response data generated using IRTsimrel R package (Lee, 2025). condition, Empirical Quadrature Calibration (EQC) algorithm used find global discrimination scaling factor c*c^* population average-information reliability matched target. Quadrature integration used M=10,000M = 10{,}000 Monte Carlo samples latent item parameter distributions. conditions screened feasibility prior calibration; [0] conditions infeasible excluded. Item difficulties drawn N(0,1)N(0, 1); 2PL model, baseline discriminations drawn LogNormal(0,0.3)\\text{LogNormal}(0, 0.3) Gaussian copula induce empirically observed negative difficulty-discrimination correlation (œÅS=‚àí0.3\\rho_S = -0.3). [500] replications per condition, N=[1,000]N = [1{,}000] simulees drawn specified latent distribution binary responses generated according IRT model. maximum absolute calibration error across conditions [< 0.001]. seeds recorded reproducibility.","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/simulation-design.html","id":"pitfall-1-ignoring-feasibility","dir":"Articles","previous_headings":"Common Pitfalls and Solutions","what":"Pitfall 1: Ignoring feasibility","title":"Designing IRT Simulation Studies with Reliability Control","text":"Problem: set target_rho = 0.90 10 items Rasch model, EQC returns c_star upper bound warning. Solution: always run check_feasibility() calibration. target infeasible, increase n_items, widen c_bounds, reduce target.","code":"# Quick feasibility check before calibration feas <- check_feasibility(   n_items = 10, model = \"rasch\",   c_bounds = c(0.1, 10), M = 5000L, seed = 42, verbose = FALSE ) cat(sprintf(\"10-item Rasch: achievable rho_tilde range = [%.3f, %.3f]\\n\",             feas$rho_range_info[1], feas$rho_range_info[2])) #> 10-item Rasch: achievable rho_tilde range = [0.025, 0.973] cat(sprintf(\"Can achieve 0.90? %s\\n\",             ifelse(0.90 <= feas$rho_range_info[2], \"Yes\", \"No\"))) #> Can achieve 0.90? Yes"},{"path":"https://joonho112.github.io/IRTsimrel/articles/simulation-design.html","id":"pitfall-2-metric-confusion","dir":"Articles","previous_headings":"Common Pitfalls and Solutions","what":"Pitfall 2: Metric confusion","title":"Designing IRT Simulation Studies with Reliability Control","text":"Problem: calibrate reliability_metric = \"info\" validate MSEM-based metric, finding discrepancy. Solution: Jensen‚Äôs inequality, œÅÃÉ‚â•w‚Äæ\\tilde{\\rho} \\geq \\bar{w}. Always compare like like. recommended workflow uses \"info\" throughout. need report metrics, compute using compute_rho_both():","code":"# Compute both metrics from a single calibration both <- compute_rho_both(   c         = eqc_rasch$c_star,   theta_vec = eqc_rasch$theta_quad,   beta_vec  = eqc_rasch$beta_vec,   lambda_base = eqc_rasch$lambda_base,   theta_var = eqc_rasch$theta_var ) cat(sprintf(\"rho_tilde (info): %.4f\\n\", both$rho_tilde)) #> rho_tilde (info): 0.8000 cat(sprintf(\"rho_bar   (msem): %.4f\\n\", both$rho_bar)) #> rho_bar   (msem): 0.7893 cat(sprintf(\"Gap (Jensen):     %.4f\\n\", both$rho_tilde - both$rho_bar)) #> Gap (Jensen):     0.0107"},{"path":"https://joonho112.github.io/IRTsimrel/articles/simulation-design.html","id":"pitfall-3-insufficient-quadrature-size-m","dir":"Articles","previous_headings":"Common Pitfalls and Solutions","what":"Pitfall 3: Insufficient quadrature size (M)","title":"Designing IRT Simulation Studies with Reliability Control","text":"Problem: Monte Carlo noise causes calibration results vary across runs even seed. Solution: use M‚â•10,000M \\geq 10{,}000 routine work M‚â•50,000M \\geq 50{,}000 high-precision studies. fixed seed, results deterministic given MM.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/simulation-design.html","id":"pitfall-4-c_bounds-too-narrow","dir":"Articles","previous_headings":"Common Pitfalls and Solutions","what":"Pitfall 4: c_bounds too narrow","title":"Designing IRT Simulation Studies with Reliability Control","text":"Problem: root outside default c_bounds = c(0.3, 3), causing EQC return boundary solution. Solution: high targets (> 0.85), try c_bounds = c(0.1, 10). low targets (< 0.50), try c_bounds = c(0.01, 3). can always check achievable range using misc$rho_bounds field calibration result.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/simulation-design.html","id":"pitfall-5-latent-shape-effects-on-reliability","dir":"Articles","previous_headings":"Common Pitfalls and Solutions","what":"Pitfall 5: Latent shape effects on reliability","title":"Designing IRT Simulation Studies with Reliability Control","text":"Problem: calibrating \"normal\" generating data \"bimodal\" gives achieved reliability different target. Solution: calibration data generation must use latent distribution. intentionally mismatch (e.g., study robustness Case Study 2 vignette(\"case-studies\")), document report actual reliability mismatched distribution.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/simulation-design.html","id":"pitfall-6-finite-sample-deviation","dir":"Articles","previous_headings":"Common Pitfalls and Solutions","what":"Pitfall 6: Finite-sample deviation","title":"Designing IRT Simulation Studies with Reliability Control","text":"Problem: N=100N = 100 persons, sample reliability (e.g., TAM) deviates substantially population target. Solution: finite-sample deviation expected follows O(1/N)O(1/\\sqrt{N}) decay. Use N‚â•500N \\geq 500 keep sampling variability manageable. Report population-level target empirical reliability estimate.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/simulation-design.html","id":"publication-ready-methods-text","dir":"Articles","previous_headings":"","what":"Publication-Ready Methods Text","title":"Designing IRT Simulation Studies with Reliability Control","text":"second example methods paragraph, time simpler two-factor design. Adapt template filling study‚Äôs values. Item response data generated using IRTsimrel R package (v0.2.0; Lee, 2025). 3 (target reliability: 0.60, 0.70, 0.80) x 2 (model: Rasch, 2PL) factorial design employed =20I = 20 items standard normal latent distribution. six conditions, Empirical Quadrature Calibration (EQC) algorithm used M=10,000M = 10{,}000 quadrature points find global discrimination scaling factor c*c^* matching target average-information reliability œÅÃÉ*\\tilde{\\rho}^*. Item difficulties drawn N(0,1)N(0, 1); 2PL model, baseline discriminations LogNormal(0,0.3)\\text{LogNormal}(0, 0.3). conditions verified feasible prior calibration. R=500R = 500 replications per condition, N=1,000N = 1{,}000 persons drawn N(0,1)N(0, 1) binary responses generated according IRT model. Maximum calibration error <10‚àí4< 10^{-4}.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/simulation-design.html","id":"summary-and-cross-references","dir":"Articles","previous_headings":"","what":"Summary and Cross-References","title":"Designing IRT Simulation Studies with Reliability Control","text":"vignette presented complete workflow designing IRT simulation studies reliability controlled design factor: Build factorial design expand.grid(). Screen cells feasibility check_feasibility(). Visualize reliability curves rho_curve(). Batch-calibrate eqc_calibrate(). Generate data simulate_response_data(). Verify calibration accuracy. Report following guidelines . key takeaway: reliability just outcome measured fact; design parameter specified, controlled, reported outset. IRTsimrel makes easy precise. related topics, see: vignette(\"introduction\") ‚Äì package overview quick start. vignette(\"algorithm-eqc\") ‚Äì deep dive Algorithm 1 (EQC). vignette(\"algorithm-sac\") ‚Äì Algorithm 2 (SAC) independent validation. vignette(\"item-parameters\") ‚Äì generating realistic item parameters. vignette(\"latent-distributions\") ‚Äì working non-normal latent distributions. vignette(\"validation\") ‚Äì validation procedures TAM integration. vignette(\"case-studies\") ‚Äì publication-ready simulation templates.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/simulation-design.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Designing IRT Simulation Studies with Reliability Control","text":"Lee, J. (2025). Reliability-targeted simulation item response data: Solving inverse design problem. arXiv preprint arXiv:2512.16012. Robbins, H., & Monro, S. (1951). stochastic approximation method. Annals Mathematical Statistics, 22(3), 400‚Äì407.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"vignette provides mathematical foundations reliability-targeted IRT simulation framework implemented IRTsimrel package. develops theory first principles, connecting classical IRT measurement theory inverse calibration problem solved EQC SAC algorithms. Reading time: approximately 45‚Äì60 minutes. Prerequisites: Familiarity basic probability theory (expectation, variance, convergence), linear algebra, logistic function. exposure item response theory helpful strictly required. Notation conventions: Random variables denoted Greek capital Roman letters; vectors boldfaced; hats denote estimators; bars tildes denote specific reliability definitions (defined ). Cross-references: algorithm-specific details, see vignette(\"algorithm-eqc\") vignette(\"algorithm-sac\"). applied examples workflows, see vignette(\"introduction\").","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"the-two-parameter-logistic-irt-model","dir":"Articles","previous_headings":"","what":"The Two-Parameter Logistic IRT Model","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"work within two-parameter logistic (2PL) item response theory model. test consists II items administered examinees drawn latent trait distribution GG. Definition 1 (2PL Model). Let Œ∏‚àºG\\theta \\sim G denote latent ability parameter let (Œ≤i,Œªi)(\\beta_i, \\lambda_i) denote difficulty discrimination parameters item ii. probability correct response given item characteristic curve (ICC): P(Xi=1‚à£Œ∏)=œà(Œªi(Œ∏‚àíŒ≤i)) P(X_i = 1 \\mid \\theta) = \\psi\\bigl(\\lambda_i(\\theta - \\beta_i)\\bigr) \\tag{1} œà(z)=(1+e‚àíz)‚àí1\\psi(z) = (1 + e^{-z})^{-1} standard logistic function. Rasch model special case Œªi=1\\lambda_i = 1 items ii.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"item-and-test-information","dir":"Articles","previous_headings":"The Two-Parameter Logistic IRT Model","what":"Item and Test Information","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"Fisher information provided item ii ability level Œ∏\\theta : Definition 2 (Item Information). 2PL model, ùí•i(Œ∏)=Œªi2pi(Œ∏)(1‚àípi(Œ∏)) \\mathcal{J}_i(\\theta) = \\lambda_i^2\\, p_i(\\theta)\\, \\bigl(1 - p_i(\\theta)\\bigr) \\tag{2} pi(Œ∏)=P(Xi=1‚à£Œ∏)p_i(\\theta) = P(X_i = 1 \\mid \\theta) given Eq. (1). Since p(1‚àíp)p(1-p) achieves maximum 1/41/4 p=1/2p = 1/2 (.e., Œ∏=Œ≤i\\theta = \\beta_i), maximum information item ii Œªi2/4\\lambda_i^2 / 4. Definition 3 (Test Information). test information function sum item information functions: ùí•(Œ∏)=‚àë=1Iùí•i(Œ∏)=‚àë=1IŒªi2pi(Œ∏)(1‚àípi(Œ∏)) \\mathcal{J}(\\theta) = \\sum_{=1}^{} \\mathcal{J}_i(\\theta)   = \\sum_{=1}^{} \\lambda_i^2\\, p_i(\\theta)\\,\\bigl(1 - p_i(\\theta)\\bigr) \\tag{3} Test information measures precision ability estimation given Œ∏\\theta. Higher information means smaller standard errors precise measurement.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"the-conditional-standard-error","dir":"Articles","previous_headings":"The Two-Parameter Logistic IRT Model","what":"The Conditional Standard Error","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"asymptotic standard error maximum likelihood estimator Œ∏ÃÇ\\hat{\\theta} Œ∏\\theta : SE(Œ∏ÃÇ‚à£Œ∏)=1ùí•(Œ∏) \\text{SE}(\\hat{\\theta} \\mid \\theta) = \\frac{1}{\\sqrt{\\mathcal{J}(\\theta)}} \\tag{4} conditional error varies across ability continuum, motivating need marginal (population-averaged) reliability measures.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"two-definitions-of-marginal-reliability","dir":"Articles","previous_headings":"","what":"Two Definitions of Marginal Reliability","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"Classical test theory defines reliability ratio true-score variance observed-score variance. IRT, multiple marginalizations possible, leading distinct reliability definitions. Let œÉŒ∏2=VarG(Œ∏)\\sigma^2_\\theta = \\text{Var}_G(\\theta) denote latent trait variance population distribution GG.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"average-information-reliability-tilderho","dir":"Articles","previous_headings":"Two Definitions of Marginal Reliability","what":"Average-Information Reliability (œÅÃÉ\\tilde{\\rho})","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"Definition 4 (Average-Information Reliability). average-information marginal reliability defined : œÅÃÉ(c)=œÉŒ∏2ùí•‚Äæ(c)œÉŒ∏2ùí•‚Äæ(c)+1 \\tilde{\\rho}(c) = \\frac{\\sigma^2_\\theta\\, \\bar{\\mathcal{J}}(c)}   {\\sigma^2_\\theta\\, \\bar{\\mathcal{J}}(c) + 1} \\tag{5} ùí•‚Äæ(c)=ùîºG[ùí•(Œ∏;c)]\\bar{\\mathcal{J}}(c) = \\mathbb{E}_G[\\mathcal{J}(\\theta; c)] average test information GG. definition first averages test information, converts reliability-like coefficient. can interpreted reliability one obtain average measurement precision applied uniformly across examinees. package, metric selected reliability_metric = \"info\" (synonym \"tilde\").","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"msem-based-reliability-barw","dir":"Articles","previous_headings":"Two Definitions of Marginal Reliability","what":"MSEM-Based Reliability (w‚Äæ\\bar{w})","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"Definition 5 (MSEM-Based Reliability). marginal-standard-error-- measurement (MSEM) based reliability defined : w‚Äæ(c)=œÉŒ∏2œÉŒ∏2+ùîºG[1/ùí•(Œ∏;c)] \\bar{w}(c) = \\frac{\\sigma^2_\\theta}   {\\sigma^2_\\theta + \\mathbb{E}_G\\bigl[1/\\mathcal{J}(\\theta; c)\\bigr]} \\tag{6} definition first takes reciprocal test information Œ∏\\theta (obtaining conditional error variance), averages error variances, forms reliability ratio. theoretically exact marginal reliability IRT model. package, metric selected reliability_metric = \"msem\" (synonym \"bar\").","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"jensens-inequality-tilderho-geq-barw","dir":"Articles","previous_headings":"Two Definitions of Marginal Reliability","what":"Jensen‚Äôs Inequality: œÅÃÉ‚â•w‚Äæ\\tilde{\\rho} \\geq \\bar{w}","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"relationship two metrics governed Jensen‚Äôs inequality. Theorem 1 (Jensen‚Äôs Inequality Reliability Metrics). scaling factor c>0c > 0 latent distribution GG œÉŒ∏2>0\\sigma^2_\\theta > 0, œÅÃÉ(c)‚â•w‚Äæ(c) \\tilde{\\rho}(c) \\geq \\bar{w}(c) \\tag{7} equality ùí•(Œ∏;c)\\mathcal{J}(\\theta; c) constant GG-almost surely. Proof. function f(x)=1/xf(x) = 1/x strictly convex (0,‚àû)(0, \\infty). Jensen‚Äôs inequality applied random variable ùí•(Œ∏;c)>0\\mathcal{J}(\\theta; c) > 0: ùîºG[1ùí•(Œ∏;c)]‚â•1ùîºG[ùí•(Œ∏;c)]=1ùí•‚Äæ(c) \\mathbb{E}_G\\!\\left[\\frac{1}{\\mathcal{J}(\\theta; c)}\\right] \\geq \\frac{1}{\\mathbb{E}_G\\bigl[\\mathcal{J}(\\theta; c)\\bigr]} = \\frac{1}{\\bar{\\mathcal{J}}(c)} \\tag{8} Now compare denominators œÅÃÉ\\tilde{\\rho} w‚Äæ\\bar{w}. denominator œÅÃÉ\\tilde{\\rho} Eq. (5) can rewritten : œÉŒ∏2ùí•‚Äæ(c)+1=œÉŒ∏2ùí•‚Äæ(c)+1 \\sigma^2_\\theta\\, \\bar{\\mathcal{J}}(c) + 1 = \\sigma^2_\\theta\\, \\bar{\\mathcal{J}}(c) + 1 denominator w‚Äæ\\bar{w} Eq. (6) : œÉŒ∏2+ùîºG[1ùí•(Œ∏;c)] \\sigma^2_\\theta + \\mathbb{E}_G\\!\\left[\\frac{1}{\\mathcal{J}(\\theta; c)}\\right] Eq. (8): w‚Äæ(c)=œÉŒ∏2œÉŒ∏2+ùîº[1/ùí•(Œ∏;c)]‚â§œÉŒ∏2œÉŒ∏2+1/ùí•‚Äæ(c)=œÉŒ∏2ùí•‚Äæ(c)œÉŒ∏2ùí•‚Äæ(c)+1=œÅÃÉ(c) \\begin{aligned} \\bar{w}(c) &= \\frac{\\sigma^2_\\theta}   {\\sigma^2_\\theta + \\mathbb{E}[1/\\mathcal{J}(\\theta; c)]} \\leq \\frac{\\sigma^2_\\theta}   {\\sigma^2_\\theta + 1/\\bar{\\mathcal{J}}(c)} \\\\[6pt] &= \\frac{\\sigma^2_\\theta\\, \\bar{\\mathcal{J}}(c)}   {\\sigma^2_\\theta\\, \\bar{\\mathcal{J}}(c) + 1} = \\tilde{\\rho}(c) \\end{aligned} inequality follows ùîº[1/ùí•]‚â•1/ùí•‚Äæ\\mathbb{E}[1/\\mathcal{J}] \\geq 1/\\bar{\\mathcal{J}} (Jensen) monotone decreasing nature x‚Ü¶œÉŒ∏2/(œÉŒ∏2+x)x \\mapsto \\sigma^2_\\theta / (\\sigma^2_\\theta + x). Equality holds iff ùí•(Œ∏;c)\\mathcal{J}(\\theta; c) .s. constant, .e., information vary across Œ∏\\theta. ‚ñ´\\square","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"numerical-verification-of-jensens-inequality","dir":"Articles","previous_headings":"Two Definitions of Marginal Reliability","what":"Numerical Verification of Jensen‚Äôs Inequality","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"can verify inequality computationally using package‚Äôs low-level reliability functions. Figure 1: Jensen‚Äôs gap two reliability metrics across scaling factors. Figure 1: Jensen‚Äôs gap two reliability metrics across scaling factors. gap largest intermediate cc values information varies across ability continuum, shrinks toward zero small cc (metrics approach zero) large cc (information becomes uniformly high).","code":"# Generate a latent trait sample and item parameters theta <- sim_latentG(5000, shape = \"normal\")$theta items <- sim_item_params(25, model = \"rasch\", source = \"parametric\") beta  <- items$data$beta lambda_base <- rep(1, 25)  # Compute both metrics across a range of c values c_grid <- seq(0.3, 3.0, by = 0.1) results <- data.frame(   c = c_grid,   rho_tilde = numeric(length(c_grid)),   rho_bar   = numeric(length(c_grid)),   gap       = numeric(length(c_grid)) )  for (j in seq_along(c_grid)) {   both <- compute_rho_both(c_grid[j], theta, beta, lambda_base)   results$rho_tilde[j] <- both$rho_tilde   results$rho_bar[j]   <- both$rho_bar   results$gap[j]       <- both$rho_tilde - both$rho_bar }  # Verify: gap is always non-negative cat(sprintf(\"Jensen's gap range: [%.6f, %.6f]\\n\",             min(results$gap), max(results$gap))) #> Jensen's gap range: [0.000209, 0.042706] cat(sprintf(\"All gaps >= 0: %s\\n\", all(results$gap >= -1e-12))) #> All gaps >= 0: TRUE oldpar <- par(mfrow = c(1, 2), mar = c(4.5, 4.5, 3, 1)) on.exit(par(oldpar))  # Panel 1: Both metrics plot(results$c, results$rho_tilde, type = \"l\", col = \"steelblue\", lwd = 2,      xlab = \"Scaling factor c\", ylab = \"Reliability\",      main = \"Two Reliability Metrics\", ylim = c(0, 1)) lines(results$c, results$rho_bar, col = \"coral\", lwd = 2, lty = 2) legend(\"bottomright\",        legend = c(expression(tilde(rho) ~ \"(info)\"),                   expression(bar(w) ~ \"(msem)\")),        col = c(\"steelblue\", \"coral\"), lty = c(1, 2), lwd = 2, cex = 0.9) # Panel 2: The gap plot(results$c, results$gap, type = \"l\", col = \"darkred\", lwd = 2,      xlab = \"Scaling factor c\", ylab = expression(tilde(rho) - bar(w)),      main = \"Jensen's Gap\") abline(h = 0, lty = 3, col = \"gray50\")"},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"scale-ordering-corollary","dir":"Articles","previous_headings":"Two Definitions of Marginal Reliability","what":"Scale Ordering Corollary","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"Corollary 1 (Scale Ordering). Let cœÅÃÉ*c^*_{\\tilde{\\rho}} cw‚Äæ*c^*_{\\bar{w}} denote calibrated scaling factors target œÅ*\\rho^* average-information MSEM metrics, respectively. : cw‚Äæ*‚â•cœÅÃÉ* c^*_{\\bar{w}} \\geq c^*_{\\tilde{\\rho}} \\tag{9} Proof sketch. Since œÅÃÉ(c)‚â•w‚Äæ(c)\\tilde{\\rho}(c) \\geq \\bar{w}(c) cc, MSEM metric reaches given target level larger scaling factor information metric . Formally, œÅÃÉ(cœÅÃÉ*)=œÅ*\\tilde{\\rho}(c^*_{\\tilde{\\rho}}) = \\rho^*, w‚Äæ(cœÅÃÉ*)‚â§œÅÃÉ(cœÅÃÉ*)=œÅ*\\bar{w}(c^*_{\\tilde{\\rho}}) \\leq \\tilde{\\rho}(c^*_{\\tilde{\\rho}}) = \\rho^*, w‚Äæ\\bar{w} must increase (requiring larger cc) reach œÅ*\\rho^*. ‚ñ´\\square ordering demonstrated numerically .","code":"# Calibrate with both metrics eqc_info <- eqc_calibrate(   target_rho = 0.80, n_items = 25, model = \"rasch\",   item_source = \"parametric\", reliability_metric = \"info\",   M = 5000L, seed = 42 )  eqc_msem <- eqc_calibrate(   target_rho = 0.80, n_items = 25, model = \"rasch\",   item_source = \"parametric\", reliability_metric = \"msem\",   M = 5000L, seed = 42 ) #> Warning in eqc_calibrate(target_rho = 0.8, n_items = 25, model = \"rasch\", : #> MSEM-based reliability (w-bar) may have a non-monotone objective for EQC (see #> Lee, 2025, Section 4.3). Consider using 'info' (rho-tilde) for EQC, or use #> sac_calibrate() which handles w-bar targeting correctly.  cat(sprintf(\"Target rho* = 0.80\\n\")) #> Target rho* = 0.80 cat(sprintf(\"  c* (info metric): %.4f\\n\", eqc_info$c_star)) #>   c* (info metric): 0.8995 cat(sprintf(\"  c* (msem metric): %.4f\\n\", eqc_msem$c_star)) #>   c* (msem metric): 0.9232 cat(sprintf(\"  c*_msem >= c*_info: %s\\n\",             eqc_msem$c_star >= eqc_info$c_star - 1e-6)) #>   c*_msem >= c*_info: TRUE"},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"global-discrimination-scaling","dir":"Articles","previous_headings":"","what":"Global Discrimination Scaling","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"central design variable IRTsimrel global discrimination scaling factor c>0c > 0.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"the-scaling-model","dir":"Articles","previous_headings":"Global Discrimination Scaling","what":"The Scaling Model","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"Definition 6 (Global Discrimination Scaling). Given baseline item discriminations ùõå(0)=(Œª1(0),‚Ä¶,ŒªI(0))\\boldsymbol{\\lambda}^{(0)} = (\\lambda_1^{(0)}, \\ldots, \\lambda_I^{(0)}) generated item parameter distribution HH, scaled discriminations : Œªi(c)=c‚ãÖŒªi(0),=1,‚Ä¶,\\lambda_i(c) = c \\cdot \\lambda_i^{(0)}, \\quad = 1, \\ldots, \\tag{10} scaling several desirable properties: Separation structure informativeness: Changing cc modifies test information without altering relative difficulty discrimination structure among items. Dimensionality reduction: multi-dimensional item parameter space collapsed single scalar control variable cc. Smooth dependence: œÅÃÉ(c)\\tilde{\\rho}(c) w‚Äæ(c)\\bar{w}(c) smooth (infinitely differentiable) functions cc c>0c > 0.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"monotonicity-of-tilderhoc","dir":"Articles","previous_headings":"Global Discrimination Scaling","what":"Monotonicity of œÅÃÉ(c)\\tilde{\\rho}(c)","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"Proposition 1 (Monotonicity; cf.¬†Proposition .1, Lee 2025). average-information reliability œÅÃÉ(c)\\tilde{\\rho}(c) strictly monotonically increasing cc c>0c > 0. Proof sketch. show ‚àÇœÅÃÉ/‚àÇc>0\\partial \\tilde{\\rho} / \\partial c > 0. Eq. (5), chain rule fact h(x)=x/(x+1)h(x) = x/(x+1) strictly increasing x>0x > 0, suffices show ùí•‚Äæ(c)=ùîºG[ùí•(Œ∏;c)]\\bar{\\mathcal{J}}(c) = \\mathbb{E}_G[\\mathcal{J}(\\theta; c)] strictly increasing cc. Differentiating test information: ‚àÇùí•i(Œ∏;c)‚àÇc=2c(Œªi(0))2pi(1‚àípi)+c2(Œªi(0))2pi(1‚àípi)(1‚àí2pi)‚ãÖŒªi(0)(Œ∏‚àíŒ≤i) \\frac{\\partial \\mathcal{J}_i(\\theta; c)}{\\partial c} = 2c\\, (\\lambda_i^{(0)})^2\\, p_i(1-p_i)   + c^2\\, (\\lambda_i^{(0)})^2\\, p_i(1-p_i)(1-2p_i) \\cdot \\lambda_i^{(0)}(\\theta - \\beta_i) taking expectation GG summing items, dominant first-order term 2c(Œªi(0))2ùîº[pi(1‚àípi)]2c\\,(\\lambda_i^{(0)})^2\\,\\mathbb{E}[p_i(1-p_i)] strictly positive item ii (since pi(1‚àípi)>0p_i(1-p_i) > 0 positive probability), ensuring ‚àÇùí•‚Äæ(c)/‚àÇc>0\\partial\\bar{\\mathcal{J}}(c)/\\partial c > 0. rigorous argument uses representation ùí•‚Äæ(c)=c2‚àë(Œªi(0))2ùîº[pi(Œ∏;c)(1‚àípi(Œ∏;c))]\\bar{\\mathcal{J}}(c) = c^2 \\sum_i (\\lambda_i^{(0)})^2 \\mathbb{E}[p_i(\\theta;c)(1-p_i(\\theta;c))] fact ùîº[pi(1‚àípi)]\\mathbb{E}[p_i(1-p_i)] bounded away zero regularity conditions. ‚ñ´\\square","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"existence-and-uniqueness","dir":"Articles","previous_headings":"Global Discrimination Scaling","what":"Existence and Uniqueness","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"Corollary 2 (Existence Uniqueness; cf.¬†Corollary 2.1, Lee 2025). mild regularity conditions, target œÅ*‚àà(œÅmin,œÅmax)\\rho^* \\(\\rho_{\\min}, \\rho_{\\max}) œÅmin=limc‚Üí0+œÅÃÉ(c)=0andœÅmax=limc‚Üí‚àûœÅÃÉ(c)=1, \\rho_{\\min} = \\lim_{c \\0^+} \\tilde{\\rho}(c) = 0 \\quad\\text{}\\quad \\rho_{\\max} = \\lim_{c \\\\infty} \\tilde{\\rho}(c) = 1, exists unique c*>0c^* > 0 satisfying œÅÃÉ(c*)=œÅ*\\tilde{\\rho}(c^*) = \\rho^*. Proof. Since œÅÃÉ\\tilde{\\rho} continuous (composition continuous functions), strictly increasing (Proposition 1), maps (0,‚àû)(0,\\infty) onto (0,1)(0,1), existence uniqueness follow intermediate value theorem strict monotonicity. ‚ñ´\\square","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"non-monotonicity-of-barwc","dir":"Articles","previous_headings":"Global Discrimination Scaling","what":"Non-Monotonicity of w‚Äæ(c)\\bar{w}(c)","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"Proposition 2 (Non-Monotonicity MSEM; cf.¬†Proposition .5, Lee 2025). MSEM-based reliability w‚Äæ(c)\\bar{w}(c) necessarily monotone cc entire positive real line. particular, sufficiently large cc, w‚Äæ(c)\\bar{w}(c) can decrease. Intuition. c‚Üí‚àûc \\\\infty, Œ∏\\theta values far Œ≤i\\beta_i, item response probabilities pi(Œ∏)p_i(\\theta) approach 0 1, causing item information ùí•i(Œ∏)=Œªi2pi(1‚àípi)‚Üí0\\mathcal{J}_i(\\theta) = \\lambda_i^2 p_i(1-p_i) \\0. Œ∏\\theta values close Œ≤i\\beta_i retain high information. harmonic mean (used w‚Äæ\\bar{w}) dominated low-information regions, causing ùîº[1/ùí•]\\mathbb{E}[1/\\mathcal{J}] grow w‚Äæ\\bar{w} decrease. arithmetic mean (used œÅÃÉ\\tilde{\\rho}) sensitive low- information tails, œÅÃÉ\\tilde{\\rho} remains monotone. c_bounds parameter matters practice, especially using \"msem\" metric. Figure 2: Non-monotonicity MSEM metric extreme scaling factors (heavy-tailed latent distribution, df = 3).","code":"# Demonstrate non-monotonicity with a heavy-tailed distribution. # Non-monotonicity is most prominent with heavy tails because extreme # theta values far from any beta_i have near-zero information, and # the harmonic mean (used in rho_bar) is dominated by these regions. theta_nm <- sim_latentG(5000, shape = \"heavy_tail\", shape_params = list(df = 3))$theta  # Use 10 items with concentrated difficulties for a more visible effect items_nm <- sim_item_params(10, model = \"rasch\", source = \"parametric\") beta_nm  <- items_nm$data$beta lambda_nm <- rep(1, 10)  c_wide <- seq(0.1, 15, length.out = 100) rho_t <- rho_b <- numeric(length(c_wide))  for (j in seq_along(c_wide)) {   both <- compute_rho_both(c_wide[j], theta_nm, beta_nm, lambda_nm)   rho_t[j] <- both$rho_tilde   rho_b[j] <- both$rho_bar }  oldpar <- par(mar = c(4.5, 4.5, 3, 1)) on.exit(par(oldpar))  plot(c_wide, rho_t, type = \"l\", col = \"steelblue\", lwd = 2,      xlab = \"Scaling factor c\", ylab = \"Reliability\",      main = \"Monotonicity Comparison (Heavy-Tailed Latent, df = 3)\",      ylim = c(0, 1)) lines(c_wide, rho_b, col = \"coral\", lwd = 2, lty = 2)  # Mark the maximum of rho_bar idx_max <- which.max(rho_b) points(c_wide[idx_max], rho_b[idx_max], pch = 19, col = \"coral\", cex = 1.5)  legend(\"right\",        legend = c(expression(tilde(rho) ~ \"(always monotone)\"),                   expression(bar(w) ~ \"(non-monotone at extreme c)\")),        col = c(\"steelblue\", \"coral\"), lty = c(1, 2), lwd = 2, cex = 0.85) cat(sprintf(\"rho_bar maximum at c = %.2f with value %.4f\\n\",             c_wide[idx_max], rho_b[idx_max])) #> rho_bar maximum at c = 0.25 with value 0.1285 cat(sprintf(\"rho_bar at c = %.1f: %.4f (decreasing)\\n\",             max(c_wide), rho_b[length(c_wide)])) #> rho_bar at c = 15.0: 0.0000 (decreasing)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"achievable-reliability-bounds","dir":"Articles","previous_headings":"","what":"Achievable Reliability Bounds","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"every target reliability achievable given test configuration. feasible range depends number items, item parameter distribution, latent trait distribution.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"upper-bound-from-the-logistic-kernel","dir":"Articles","previous_headings":"Achievable Reliability Bounds","what":"Upper Bound from the Logistic Kernel","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"Proposition 3 (Information Upper Bound). 2PL model, maximum item information : supŒ∏ùí•i(Œ∏)=Œªi24 \\sup_{\\theta}\\, \\mathcal{J}_i(\\theta) = \\frac{\\lambda_i^2}{4} \\tag{11} achieved Œ∏=Œ≤i\\theta = \\beta_i (.e., pi=1/2p_i = 1/2). Therefore, maximum test information : supŒ∏ùí•(Œ∏;c)=c24‚àë=1I(Œªi(0))2 \\sup_{\\theta}\\, \\mathcal{J}(\\theta; c) = \\frac{c^2}{4} \\sum_{=1}^{} (\\lambda_i^{(0)})^2 \\tag{12} Rasch model Œªi(0)=1\\lambda_i^{(0)} = 1, simplifies c2I/4c^2 / 4. Proof. function p(1‚àíp)p(1-p) [0,1][0,1] unique maximum 1/41/4 p=1/2p = 1/2. 2PL model, pi(Œ∏)=1/2p_i(\\theta) = 1/2 Œ∏=Œ≤i\\theta = \\beta_i. ‚ñ´\\square","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"feasibility-conditions","dir":"Articles","previous_headings":"Achievable Reliability Bounds","what":"Feasibility Conditions","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"average test information bounded maximum: ùí•‚Äæ(c)=ùîºG[‚àë=1IŒªi(c)2pi(1‚àípi)]‚â§c24‚àë=1I(Œªi(0))2 \\bar{\\mathcal{J}}(c) = \\mathbb{E}_G\\!\\left[\\sum_{=1}^{} \\lambda_i(c)^2\\, p_i(1-p_i)\\right] \\leq \\frac{c^2}{4} \\sum_{=1}^{} (\\lambda_i^{(0)})^2 Therefore maximum achievable average-information reliability given cc : œÅÃÉmax(c)=œÉŒ∏2‚ãÖ(c2/4)‚àë(Œªi(0))2œÉŒ∏2‚ãÖ(c2/4)‚àë(Œªi(0))2+1 \\tilde{\\rho}_{\\max}(c) = \\frac{\\sigma^2_\\theta \\cdot (c^2/4) \\sum_i (\\lambda_i^{(0)})^2}   {\\sigma^2_\\theta \\cdot (c^2/4) \\sum_i (\\lambda_i^{(0)})^2 + 1} c‚Üí‚àûc \\\\infty, approaches 1, practice work within c‚àà[cmin,cmax]c \\[c_{\\min}, c_{\\max}] achievable range finite.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"connection-to-check_feasibility","dir":"Articles","previous_headings":"Achievable Reliability Bounds","what":"Connection to check_feasibility()","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"check_feasibility() function computes achievable reliability range via Monte Carlo evaluation boundary scaling factors.","code":"# Check feasibility for a 25-item Rasch test feas <- check_feasibility(   n_items = 25, model = \"rasch\",   latent_shape = \"normal\",   item_source = \"parametric\",   c_bounds = c(0.1, 10),   M = 5000L, seed = 42 ) #>  #> ======================================================= #>   Feasibility Check: Achievable Reliability Range #> ======================================================= #>  #>   Number of items  : 25 #>   Model            : RASCH #>   Latent shape     : normal #>   Latent variance  : 1.0099 #>   c range          : [0.10, 10.00] #>   Monte Carlo M    : 5000 #>  #> Achievable Reliability Ranges: #>   rho_tilde (info) : [0.0591, 0.9872] #>   rho_bar   (msem) : [0.0002, 0.9146] #>  #> Note: rho_tilde >= rho_bar always (Jensen's inequality). #>   Use rho_tilde range for EQC targets. #>   Use rho_bar range for SAC targets. # Test which targets are feasible targets <- c(0.50, 0.70, 0.80, 0.90, 0.95) for (rho in targets) {   feasible_info <- rho >= feas$rho_range_info[1] & rho <= feas$rho_range_info[2]   feasible_msem <- rho >= feas$rho_range_msem[1] & rho <= feas$rho_range_msem[2]   cat(sprintf(\"  rho* = %.2f: info %s, msem %s\\n\",               rho,               ifelse(feasible_info, \"YES\", \"NO \"),               ifelse(feasible_msem, \"YES\", \"NO \"))) } #>   rho* = 0.50: info YES, msem YES #>   rho* = 0.70: info YES, msem YES #>   rho* = 0.80: info YES, msem YES #>   rho* = 0.90: info YES, msem YES #>   rho* = 0.95: info YES, msem NO"},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"reliability-curves","dir":"Articles","previous_headings":"Achievable Reliability Bounds","what":"Reliability Curves","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"rho_curve() function visualizes reliability changes scaling factor. Figure 3: Reliability curve 25-item Rasch test normal latent distribution.","code":"curve_data <- rho_curve(   c_values = seq(0.1, 5, length.out = 60),   n_items = 25, model = \"rasch\",   latent_shape = \"normal\",   item_source = \"parametric\",   metric = \"both\",   M = 5000L, seed = 42,   plot = TRUE )"},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"eqc-theory-deterministic-root-finding","dir":"Articles","previous_headings":"","what":"EQC Theory: Deterministic Root-Finding","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"Empirical Quadrature Calibration (EQC) algorithm solves inverse reliability problem using deterministic root-finding empirical reliability function. Full algorithmic details vignette(\"algorithm-eqc\"); state main theoretical results.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"algorithm-sketch","dir":"Articles","previous_headings":"EQC Theory: Deterministic Root-Finding","what":"Algorithm Sketch","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"EQC proceeds three steps: Quadrature sampling: Draw {Œ∏m}m=1M‚àºG\\{\\theta_m\\}_{m=1}^M \\sim G item parameters {(Œ≤i,Œªi(0))}=1I‚àºH\\{(\\beta_i, \\lambda_i^{(0)})\\}_{=1}^\\sim H . Empirical reliability function: c>0c > 0, define: œÅÃÇM(c)=œÅ(c;{Œ∏m},ùõÉ,ùõå(c)) \\hat{\\rho}_M(c) = \\rho\\bigl(c;\\, \\{\\theta_m\\},\\, \\boldsymbol{\\beta},\\, \\boldsymbol{\\lambda}(c)\\bigr) \\tag{13} Root-finding: Solve gM(c)=œÅÃÇM(c)‚àíœÅ*=0g_M(c) = \\hat{\\rho}_M(c) - \\rho^* = 0 using Brent‚Äôs method [cmin,cmax][c_{\\min}, c_{\\max}].","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"consistency","dir":"Articles","previous_headings":"EQC Theory: Deterministic Root-Finding","what":"Consistency","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"Theorem 2 (Consistency EQC; cf.¬†Theorem .1, Lee 2025). Let c*c^* true population solution cÃÇM*\\hat{c}^*_M EQC solution quadrature size MM. : cÃÇM*‚Üí.s.c*M‚Üí‚àû \\hat{c}^*_M \\xrightarrow{\\text{.s.}} c^* \\quad \\text{} M \\\\infty \\tag{14} Proof sketch. empirical reliability œÅÃÇM(c)\\hat{\\rho}_M(c) converges uniformly œÅ(c)\\rho(c) compact interval [cmin,cmax][c_{\\min}, c_{\\max}] Uniform Law Large Numbers (ULLN). Since œÅ(c)\\rho(c) continuous strictly monotone, root limit function unique (Corollary 2), uniform convergence objective implies convergence root (continuous mapping theorem M-estimators). ‚ñ´\\square","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"asymptotic-normality","dir":"Articles","previous_headings":"EQC Theory: Deterministic Root-Finding","what":"Asymptotic Normality","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"Theorem 3 (Asymptotic Normality EQC; cf.¬†Theorem .2, Lee 2025). regularity conditions, EQC estimator satisfies: M(cÃÇM*‚àíc*)‚ÜídN(0,œÉg2g‚Ä≤(c*)2) \\sqrt{M}\\,\\bigl(\\hat{c}^*_M - c^*\\bigr) \\xrightarrow{d} N\\!\\left(0,\\, \\frac{\\sigma^2_g}{g'(c^*)^2}\\right) \\tag{15} g(c)=œÅ(c)‚àíœÅ*g(c) = \\rho(c) - \\rho^*, g‚Ä≤(c*)g'(c^*) derivative reliability function solution, œÉg2\\sigma^2_g asymptotic variance empirical gradient. Proof sketch. Apply delta method implicit function cÃÇM*=gM‚àí1(œÅ*)\\hat{c}^*_M = g^{-1}_M(\\rho^*). Central Limit Theorem gives M(œÅÃÇM(c)‚àíœÅ(c))‚ÜídN(0,œÉg2)\\sqrt{M}(\\hat{\\rho}_M(c) - \\rho(c)) \\to_d N(0, \\sigma^2_g), implicit function theorem (applicable since g‚Ä≤(c*)‚â†0g'(c^*) \\neq 0 strict monotonicity) yields result. ‚ñ´\\square","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"monte-carlo-error-bounds","dir":"Articles","previous_headings":"EQC Theory: Deterministic Root-Finding","what":"Monte Carlo Error Bounds","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"practical implication Theorem 3 : |cÃÇM*‚àíc*|=Op(1M) |\\hat{c}^*_M - c^*| = O_p\\!\\left(\\frac{1}{\\sqrt{M}}\\right) \\tag{16} reliability estimate error: |œÅÃÇM(c)‚àíœÅ(c)|=Op(1M) |\\hat{\\rho}_M(c) - \\rho(c)| = O_p\\!\\left(\\frac{1}{\\sqrt{M}}\\right)","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"sac-theory-stochastic-approximation","dir":"Articles","previous_headings":"","what":"SAC Theory: Stochastic Approximation","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"Stochastic Approximation Calibration (SAC) algorithm provides independent solution path using Robbins-Monro framework. Full algorithmic details vignette(\"algorithm-sac\").","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"the-stochastic-root-finding-problem","dir":"Articles","previous_headings":"SAC Theory: Stochastic Approximation","what":"The Stochastic Root-Finding Problem","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"SAC targets equation: g(c)=ùîº[œÅÃÇ(c)]‚àíœÅ*=0 g(c) = \\mathbb{E}\\!\\left[\\hat{\\rho}(c)\\right] - \\rho^* = 0 \\tag{17} iteration nn, noisy observation œÅÃÇn(cn)=œÅ*+g(cn)+Œµn\\hat{\\rho}_n(c_n) = \\rho^* + g(c_n) + \\varepsilon_n available, Œµn\\varepsilon_n zero-mean Monte Carlo noise.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"robbins-monro-update","dir":"Articles","previous_headings":"SAC Theory: Stochastic Approximation","what":"Robbins-Monro Update","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"iterative update rule : cn+1=Œ†[cL,cU][cn‚àí(œÅÃÇn(cn)‚àíœÅ*)] c_{n+1} = \\Pi_{[c_L, c_U]}\\!\\left[c_n - a_n\\,\\bigl(\\hat{\\rho}_n(c_n) - \\rho^*\\bigr)\\right] \\tag{18} Œ†[cL,cU]\\Pi_{[c_L, c_U]} denotes projection onto constraint set step size sequence satisfies Robbins-Monro conditions: =(n+)Œ≥,‚àën=1‚àû=‚àû,‚àën=1‚àûan2<‚àû a_n = \\frac{}{(n + )^\\gamma}, \\quad \\sum_{n=1}^{\\infty} a_n = \\infty, \\quad \\sum_{n=1}^{\\infty} a_n^2 < \\infty \\tag{19} conditions satisfied Œ≥‚àà(1/2,1]\\gamma \\(1/2, 1].","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"polyak-ruppert-averaging","dir":"Articles","previous_headings":"SAC Theory: Stochastic Approximation","what":"Polyak-Ruppert Averaging","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"Rather using final iterate cNc_N, SAC computes Polyak-Ruppert average post-burn-iterates: c‚ÄæN=1N‚àíB‚àën=B+1Ncn \\bar{c}_N = \\frac{1}{N - B} \\sum_{n=B+1}^{N} c_n \\tag{20} BB burn-period. averaging achieves optimal convergence rate.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"convergence","dir":"Articles","previous_headings":"SAC Theory: Stochastic Approximation","what":"Convergence","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"Theorem 4 (SAC Convergence; cf.¬†Theorem .3, Lee 2025). Robbins-Monro conditions (Eq. 19) standard regularity assumptions (boundedness gg, Lipschitz continuity, noise variance bounded), SAC iterates converge almost surely: cn‚Üí.s.c*n‚Üí‚àû c_n \\xrightarrow{\\text{.s.}} c^* \\quad \\text{} n \\\\infty \\tag{21} Furthermore, Polyak-Ruppert average satisfies: N‚àíB(c‚ÄæN‚àíc*)‚ÜídN(0,œÉŒµ2g‚Ä≤(c*)2) \\sqrt{N - B}\\,(\\bar{c}_N - c^*) \\xrightarrow{d} N\\!\\left(0,\\, \\frac{\\sigma^2_\\varepsilon}{g'(c^*)^2}\\right) \\tag{22} achieving optimal O(n‚àí1/2)O(n^{-1/2}) rate, compared O(n‚àíŒ≥)O(n^{-\\gamma}) final iterate. Proof sketch. Almost sure convergence follows classical Robbins-Monro theorem (Robbins Monro, 1951), extended projected case Kushner Yin (2003). key conditions : () g(c*)=0g(c^*) = 0, (ii) g‚Ä≤(c*)>0g'(c^*) > 0 (strict monotonicity Proposition 1), (iii) step size conditions Eq. (19), (iv) bounded conditional variance Var(Œµn‚à£cn)‚â§œÉŒµ2\\text{Var}(\\varepsilon_n \\mid c_n) \\leq \\sigma^2_\\varepsilon. Asymptotic normality Polyak-Ruppert average follows Polyak Juditsky (1992). ‚ñ´\\square","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"verifying-theoretical-predictions","dir":"Articles","previous_headings":"Numerical Demonstrations","what":"Verifying Theoretical Predictions","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"use low-level reliability functions verify key theoretical properties.","code":"# Common setup for demonstrations M_demo <- 5000L theta_demo <- sim_latentG(M_demo, shape = \"normal\")$theta items_demo <- sim_item_params(30, model = \"rasch\", source = \"parametric\") beta_demo  <- items_demo$data$beta lambda_demo <- rep(1, 30) theta_var_demo <- var(theta_demo)"},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"verification-1-reliability-increases-with-c-info-metric","dir":"Articles","previous_headings":"Numerical Demonstrations > Verifying Theoretical Predictions","what":"Verification 1: Reliability increases with c (info metric)","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"","code":"c_test <- c(0.5, 1.0, 1.5, 2.0, 2.5, 3.0) rho_info <- sapply(c_test, function(cc) {   compute_rho_tilde(cc, theta_demo, beta_demo, lambda_demo,                     theta_var = theta_var_demo) })  cat(\"Monotonicity check (info metric):\\n\") #> Monotonicity check (info metric): for (j in seq_along(c_test)) {   cat(sprintf(\"  c = %.1f: rho_tilde = %.4f\", c_test[j], rho_info[j]))   if (j > 1) {     cat(sprintf(\"  (diff = %+.4f)\", rho_info[j] - rho_info[j-1]))   }   cat(\"\\n\") } #>   c = 0.5: rho_tilde = 0.6286 #>   c = 1.0: rho_tilde = 0.8456  (diff = +0.2171) #>   c = 1.5: rho_tilde = 0.9082  (diff = +0.0626) #>   c = 2.0: rho_tilde = 0.9351  (diff = +0.0269) #>   c = 2.5: rho_tilde = 0.9498  (diff = +0.0147) #>   c = 3.0: rho_tilde = 0.9590  (diff = +0.0092) cat(sprintf(\"All differences positive: %s\\n\", all(diff(rho_info) > 0))) #> All differences positive: TRUE"},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"verification-2-jensens-gap-depends-on-information-heterogeneity","dir":"Articles","previous_headings":"Numerical Demonstrations > Verifying Theoretical Predictions","what":"Verification 2: Jensen‚Äôs gap depends on information heterogeneity","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"Non-standard latent distributions produce larger Jensen‚Äôs gaps information varies across ability continuum.","code":"shapes <- c(\"normal\", \"bimodal\", \"heavy_tail\", \"skew_pos\") shape_pars <- list(   normal     = list(),   bimodal    = list(delta = 0.9),   heavy_tail = list(df = 5),   skew_pos   = list(k = 4) )  c_val <- 1.5 cat(sprintf(\"Jensen's gap at c = %.1f for different latent shapes:\\n\", c_val)) #> Jensen's gap at c = 1.5 for different latent shapes:  for (sh in shapes) {   theta_sh <- sim_latentG(M_demo, shape = sh, shape_params = shape_pars[[sh]])$theta   both_sh <- compute_rho_both(c_val, theta_sh, beta_demo, lambda_demo)   gap <- both_sh$rho_tilde - both_sh$rho_bar   cat(sprintf(\"  %-12s: rho_tilde = %.4f, rho_bar = %.4f, gap = %.4f\\n\",               sh, both_sh$rho_tilde, both_sh$rho_bar, gap)) } #>   normal      : rho_tilde = 0.9113, rho_bar = 0.9011, gap = 0.0102 #>   bimodal     : rho_tilde = 0.9070, rho_bar = 0.9040, gap = 0.0031 #>   heavy_tail  : rho_tilde = 0.9117, rho_bar = 0.8293, gap = 0.0824 #>   skew_pos    : rho_tilde = 0.9122, rho_bar = 0.8862, gap = 0.0260"},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"verification-3-apc-initialization-quality","dir":"Articles","previous_headings":"Numerical Demonstrations > Verifying Theoretical Predictions","what":"Verification 3: APC initialization quality","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"Analytic Pre-Calibration (APC) formula provides closed-form starting point. compare EQC solution.","code":"targets <- c(0.60, 0.70, 0.80, 0.85, 0.90) cat(\"APC initialization vs EQC solution (Rasch, 25 items, normal):\\n\") #> APC initialization vs EQC solution (Rasch, 25 items, normal): cat(sprintf(\"  %-10s %-10s %-10s %-10s\\n\", \"Target\", \"c_APC\", \"c_EQC\", \"Ratio\")) #>   Target     c_APC      c_EQC      Ratio  for (rho_t in targets) {   c_apc <- compute_apc_init(target_rho = rho_t, n_items = 25)   eqc_t <- eqc_calibrate(     target_rho = rho_t, n_items = 25, model = \"rasch\",     item_source = \"parametric\", M = 5000L, seed = 42, verbose = FALSE   )   cat(sprintf(\"  %-10.2f %-10.4f %-10.4f %-10.2f\\n\",               rho_t, c_apc, eqc_t$c_star, c_apc / eqc_t$c_star)) } #>   0.60       0.8129     0.5118     1.59       #>   0.70       1.0138     0.6548     1.55       #>   0.80       1.3274     0.8995     1.48       #>   0.85       1.5799     1.1199     1.41       #>   0.90       1.9911     1.5328     1.30"},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"verification-4-effect-of-test-length-on-achievable-reliability","dir":"Articles","previous_headings":"Numerical Demonstrations > Verifying Theoretical Predictions","what":"Verification 4: Effect of test length on achievable reliability","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"","code":"n_items_grid <- c(10, 15, 20, 25, 30, 40, 50) c_fixed <- 1.0  cat(sprintf(\"Reliability at c = %.1f for different test lengths:\\n\", c_fixed)) #> Reliability at c = 1.0 for different test lengths: for (ni in n_items_grid) {   items_ni <- sim_item_params(ni, model = \"rasch\", source = \"parametric\")   beta_ni  <- items_ni$data$beta   lambda_ni <- rep(1, ni)    both_ni <- compute_rho_both(c_fixed, theta_demo, beta_ni, lambda_ni,                                theta_var = theta_var_demo)   cat(sprintf(\"  I = %2d: rho_tilde = %.4f, rho_bar = %.4f\\n\",               ni, both_ni$rho_tilde, both_ni$rho_bar)) } #>   I = 10: rho_tilde = 0.6514, rho_bar = 0.6406 #>   I = 15: rho_tilde = 0.7213, rho_bar = 0.7158 #>   I = 20: rho_tilde = 0.7797, rho_bar = 0.7738 #>   I = 25: rho_tilde = 0.8165, rho_bar = 0.8112 #>   I = 30: rho_tilde = 0.8510, rho_bar = 0.8442 #>   I = 40: rho_tilde = 0.8768, rho_bar = 0.8730 #>   I = 50: rho_tilde = 0.8995, rho_bar = 0.8961"},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"eqc-vs-sac-agreement","dir":"Articles","previous_headings":"Numerical Demonstrations","what":"EQC vs SAC Agreement","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"","code":"eqc_demo <- eqc_calibrate(   target_rho = 0.80, n_items = 25, model = \"rasch\",   item_source = \"parametric\", reliability_metric = \"info\",   M = 5000L, seed = 42, verbose = FALSE )  sac_demo <- sac_calibrate(   target_rho = 0.80, n_items = 25, model = \"rasch\",   item_source = \"parametric\", reliability_metric = \"info\",   c_init = eqc_demo, n_iter = 300L, M_per_iter = 1000L,   seed = 42, verbose = FALSE )  cat(\"EQC vs SAC comparison (target = 0.80, info metric):\\n\") #> EQC vs SAC comparison (target = 0.80, info metric): cat(sprintf(\"  EQC c*:        %.4f\\n\", eqc_demo$c_star)) #>   EQC c*:        0.8995 cat(sprintf(\"  SAC c*:        %.4f\\n\", sac_demo$c_star)) #>   SAC c*:        0.9122 cat(sprintf(\"  Abs diff:      %.4f\\n\", abs(eqc_demo$c_star - sac_demo$c_star))) #>   Abs diff:      0.0127 cat(sprintf(\"  Pct diff:      %.2f%%\\n\",             100 * abs(eqc_demo$c_star - sac_demo$c_star) / eqc_demo$c_star)) #>   Pct diff:      1.41%"},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"verification-5-reliability-function-under-the-2pl-model","dir":"Articles","previous_headings":"Numerical Demonstrations","what":"Verification 5: Reliability function under the 2PL model","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"2PL model introduces additional variability heterogeneous baseline discriminations. Heterogeneous discriminations typically produce larger Jensen‚Äôs gap test information varies across ability continuum.","code":"items_2pl <- sim_item_params(25, model = \"2pl\", source = \"parametric\") beta_2pl  <- items_2pl$data$beta lambda_2pl <- if (\"lambda_unscaled\" %in% names(items_2pl$data)) {   items_2pl$data$lambda_unscaled } else {   items_2pl$data$lambda }  cat(\"2PL baseline discriminations:\\n\") #> 2PL baseline discriminations: cat(sprintf(\"  Range: [%.3f, %.3f]\\n\", min(lambda_2pl), max(lambda_2pl))) #>   Range: [0.411, 2.144] cat(sprintf(\"  Mean:  %.3f\\n\", mean(lambda_2pl))) #>   Mean:  1.165 cat(sprintf(\"  SD:    %.3f\\n\", sd(lambda_2pl))) #>   SD:    0.383  # Compare Rasch and 2PL reliability at same c c_compare <- 1.0 both_rasch <- compute_rho_both(c_compare, theta_demo,                                 beta_demo[1:25], rep(1, 25),                                 theta_var = theta_var_demo) both_2pl <- compute_rho_both(c_compare, theta_demo,                               beta_2pl, lambda_2pl,                               theta_var = theta_var_demo)  cat(sprintf(\"\\nReliability comparison at c = %.1f:\\n\", c_compare)) #>  #> Reliability comparison at c = 1.0: cat(sprintf(\"  Rasch: rho_tilde = %.4f, rho_bar = %.4f, gap = %.4f\\n\",             both_rasch$rho_tilde, both_rasch$rho_bar,             both_rasch$rho_tilde - both_rasch$rho_bar)) #>   Rasch: rho_tilde = 0.8213, rho_bar = 0.8152, gap = 0.0062 cat(sprintf(\"  2PL:   rho_tilde = %.4f, rho_bar = %.4f, gap = %.4f\\n\",             both_2pl$rho_tilde, both_2pl$rho_bar,             both_2pl$rho_tilde - both_2pl$rho_bar)) #>   2PL:   rho_tilde = 0.8556, rho_bar = 0.8444, gap = 0.0112"},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"the-inverse-design-problem","dir":"Articles","previous_headings":"","what":"The Inverse Design Problem","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"theoretical framework describes forward problem: given scaling factor cc, compute reliability œÅ(c)\\rho(c). central contribution IRTsimrel package solving inverse problem.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"problem-statement","dir":"Articles","previous_headings":"The Inverse Design Problem","what":"Problem Statement","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"Definition 7 (Inverse Reliability Problem). Given target marginal reliability œÅ*‚àà(0,1)\\rho^* \\(0, 1), find global discrimination scaling factor c*>0c^* > 0 : œÅ(c*)=œÅ* \\rho(c^*) = \\rho^* \\tag{23} œÅ\\rho denotes either œÅÃÉ\\tilde{\\rho} (average-information) w‚Äæ\\bar{w} (MSEM-based), depending chosen metric.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"why-the-inverse-problem-is-difficult","dir":"Articles","previous_headings":"The Inverse Design Problem","what":"Why the Inverse Problem is Difficult","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"Several factors make inverse problem non-trivial: closed-form solution: reliability function involves logistic nonlinearity inside expectation GG. Even simplest Rasch case normal GG, analytic inversion possible. Distribution dependence: mapping c‚Ü¶œÅ(c)c \\mapsto \\rho(c) depends full distributions GG (latent traits) HH (item parameters), just moments. Metric ambiguity: two reliability definitions yield different c*c^* values target (Corollary 1). Practical constraints: scaling factor must lie within bounds produce realistic item parameters.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"the-apc-approximation","dir":"Articles","previous_headings":"The Inverse Design Problem","what":"The APC Approximation","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"Analytic Pre-Calibration (APC) formula provides rough initial estimate Gaussian Rasch assumptions. Œ∏‚àºN(0,1)\\theta \\sim N(0,1) Œ≤‚àºN(0,œÉŒ≤2)\\beta \\sim N(0, \\sigma^2_\\beta), expected item information involves logistic-normal convolution constant: Œ∫(œÉ2)=‚à´‚àí‚àû‚àûez(1+ez)2œï(z;0,œÉ2)dz‚âà0.251+œÉ2œÄ2/3 \\kappa(\\sigma^2) = \\int_{-\\infty}^{\\infty} \\frac{e^z}{(1+e^z)^2}\\, \\phi(z; 0, \\sigma^2)\\, dz \\approx \\frac{0.25}{\\sqrt{1 + \\sigma^2 \\pi^2 / 3}} \\tag{24} œÉ2=1+œÉŒ≤2\\sigma^2 = 1 + \\sigma^2_\\beta. APC initial value : cAPC=œÅ*‚ãÖŒ∫‚ãÖ(1‚àíœÅ*) c_{\\text{APC}} = \\sqrt{\\frac{\\rho^*}{\\cdot \\kappa \\cdot (1 - \\rho^*)}} \\tag{25} approximation typically within factor 2 true c*c^* serves starting point stochastic approximation algorithm (SAC).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"complete-notation-table","dir":"Articles","previous_headings":"","what":"Complete Notation Table","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"following table summarizes mathematical notation used package documentation.","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/theory-reliability.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Mathematical Foundations: Reliability Theory and the Inverse Design Problem","text":"Lee, J. (2025). Reliability-targeted simulation item response data: Solving inverse design problem. arXiv preprint arXiv:2512.16012. Robbins, H., & Monro, S. (1951). stochastic approximation method. Annals Mathematical Statistics, 22(3), 400‚Äì407. Polyak, B. T., & Juditsky, . B. (1992). Acceleration stochastic approximation averaging. SIAM Journal Control Optimization, 30(4), 838‚Äì855. Kushner, H. J., & Yin, G. G. (2003). Stochastic Approximation Recursive Algorithms Applications (2nd ed.). Springer. Brent, R. P. (1973). Algorithms Minimization Without Derivatives. Prentice-Hall. Lord, F. M. (1980). Applications Item Response Theory Practical Testing Problems. Erlbaum. van der Linden, W. J. (Ed.). (2016). Handbook Item Response Theory (Vols. 1‚Äì3). CRC Press. Birnbaum, . (1968). latent trait models use inferring examinee‚Äôs ability. F. M. Lord & M. R. Novick (Eds.), Statistical Theories Mental Test Scores (pp.¬†395‚Äì479). Addison-Wesley.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Validating Calibration Results","text":"Validation process confirming calibrated test design actually achieves intended reliability data generated . IRTsimrel framework, validation operates three levels: Reading time: approximately 20 minutes. Prerequisites: Basic familiarity eqc_calibrate() sac_calibrate(). mathematical foundations, see vignette(\"theory-reliability\"). algorithm details, see vignette(\"algorithm-eqc\") vignette(\"algorithm-sac\").","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"level-1-internal-validation","dir":"Articles","previous_headings":"","what":"Level 1: Internal Validation","title":"Validating Calibration Results","text":"Internal validation checks whether calibration output self-consistent, without fitting external model simulated data.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"the-predict-method","dir":"Articles","previous_headings":"Level 1: Internal Validation","what":"The predict() Method","title":"Validating Calibration Results","text":"running eqc_calibrate(), predict() method evaluates reliability function arbitrary scaling factors using stored quadrature samples. achieved reliability match target within EQC tolerance (default: 10‚àí410^{-4}).","code":"# Calibrate eqc_result <- eqc_calibrate(   target_rho = 0.80, n_items = 25, model = \"rasch\",   item_source = \"parametric\", reliability_metric = \"info\",   M = 5000L, seed = 42, verbose = FALSE )  # Internal consistency check cat(sprintf(\"Target reliability:  %.4f\\n\", eqc_result$target_rho)) #> Target reliability:  0.8000 cat(sprintf(\"Achieved reliability: %.4f\\n\", eqc_result$achieved_rho)) #> Achieved reliability: 0.8000 cat(sprintf(\"Absolute error:      %.6f\\n\",             abs(eqc_result$achieved_rho - eqc_result$target_rho))) #> Absolute error:      0.000000"},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"jensens-gap-via-compute_rho_both","dir":"Articles","previous_headings":"Level 1: Internal Validation","what":"Jensen‚Äôs Gap via compute_rho_both()","title":"Validating Calibration Results","text":"critical internal diagnostic measuring gap two reliability metrics calibrated c*c^*. reveals much choice metric matters specific test configuration. Interpretation guidelines:","code":"# Compute both metrics at c* theta_val <- sim_latentG(5000, shape = \"normal\")$theta items_val <- sim_item_params(25, model = \"rasch\", source = \"parametric\") beta_val  <- items_val$data$beta lambda_val <- rep(1, 25)  both <- compute_rho_both(eqc_result$c_star, theta_val, beta_val, lambda_val)  cat(sprintf(\"At calibrated c* = %.4f:\\n\", eqc_result$c_star)) #> At calibrated c* = 0.8995: cat(sprintf(\"  rho_tilde (info): %.4f\\n\", both$rho_tilde)) #>   rho_tilde (info): 0.8000 cat(sprintf(\"  rho_bar   (msem): %.4f\\n\", both$rho_bar)) #>   rho_bar   (msem): 0.7937 cat(sprintf(\"  Jensen's gap:     %.4f\\n\", both$rho_tilde - both$rho_bar)) #>   Jensen's gap:     0.0063"},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"jensens-gap-across-latent-distributions","dir":"Articles","previous_headings":"Level 1: Internal Validation","what":"Jensen‚Äôs Gap Across Latent Distributions","title":"Validating Calibration Results","text":"gap depends much test information varies across ability continuum. Non-standard latent distributions typically produce larger gaps.","code":"shapes <- c(\"normal\", \"bimodal\", \"heavy_tail\", \"skew_pos\") shape_pars <- list(   normal     = list(),   bimodal    = list(delta = 0.9),   heavy_tail = list(df = 5),   skew_pos   = list(k = 4) )  cat(\"Jensen's gap by latent shape (c* from info metric, target = 0.80):\\n\") #> Jensen's gap by latent shape (c* from info metric, target = 0.80): cat(sprintf(\"  %-12s %-8s %-10s %-10s %-8s\\n\",             \"Shape\", \"c*\", \"rho_tilde\", \"rho_bar\", \"Gap\")) #>   Shape        c*       rho_tilde  rho_bar    Gap  for (sh in shapes) {   eqc_sh <- eqc_calibrate(     target_rho = 0.80, n_items = 25, model = \"rasch\",     item_source = \"parametric\", reliability_metric = \"info\",     latent_shape = sh, latent_params = shape_pars[[sh]],     M = 5000L, seed = 42, verbose = FALSE   )    theta_sh <- sim_latentG(5000, shape = sh, shape_params = shape_pars[[sh]])$theta   both_sh <- compute_rho_both(eqc_sh$c_star, theta_sh, beta_val, lambda_val)    cat(sprintf(\"  %-12s %-8.4f %-10.4f %-10.4f %-8.4f\\n\",               sh, eqc_sh$c_star, both_sh$rho_tilde, both_sh$rho_bar,               both_sh$rho_tilde - both_sh$rho_bar)) } #>   normal       0.8995   0.8006     0.7944     0.0062 #> Auto-wrapping shape parameter(s) {delta} into latent_params$shape_params. #>   bimodal      0.9605   0.8133     0.8106     0.0027 #> Auto-wrapping shape parameter(s) {df} into latent_params$shape_params. #>   heavy_tail   0.9365   0.8138     0.7952     0.0186 #> Auto-wrapping shape parameter(s) {k} into latent_params$shape_params. #>   skew_pos     0.9132   0.8008     0.7885     0.0123"},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"level-2-cross-algorithm-validation","dir":"Articles","previous_headings":"","what":"Level 2: Cross-Algorithm Validation","title":"Validating Calibration Results","text":"Cross-algorithm validation uses two independent calibration algorithms solve problem. Agreement provides strong evidence calibration correct.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"the-compare_eqc_sac-function","dir":"Articles","previous_headings":"Level 2: Cross-Algorithm Validation","what":"The compare_eqc_sac() Function","title":"Validating Calibration Results","text":"","code":"# Run EQC eqc_cross <- eqc_calibrate(   target_rho = 0.80, n_items = 25, model = \"rasch\",   item_source = \"parametric\", reliability_metric = \"info\",   M = 5000L, seed = 42, verbose = FALSE )  # Run SAC with EQC warm start sac_cross <- sac_calibrate(   target_rho = 0.80, n_items = 25, model = \"rasch\",   item_source = \"parametric\", reliability_metric = \"info\",   c_init = eqc_cross, n_iter = 300L, M_per_iter = 1000L,   seed = 42, verbose = FALSE )  # Formal comparison comparison <- compare_eqc_sac(eqc_cross, sac_cross) #>  #> ======================================================= #>   EQC vs SAC Comparison #> ======================================================= #>  #>   Target reliability  : 0.8000 #>   EQC c*              : 0.899499 #>   SAC c*              : 0.912155 #>   Absolute difference : 0.012656 #>   Percent difference  : 1.41% #>   Agreement (< 5%)    : YES #>"},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"interpreting-the-comparison","dir":"Articles","previous_headings":"Level 2: Cross-Algorithm Validation","what":"Interpreting the Comparison","title":"Validating Calibration Results","text":"","code":"cat(\"\\nComparison summary:\\n\") #>  #> Comparison summary: cat(sprintf(\"  EQC c*:          %.4f\\n\", comparison$c_eqc)) #>   EQC c*:          0.8995 cat(sprintf(\"  SAC c*:          %.4f\\n\", comparison$c_sac)) #>   SAC c*:          0.9122 cat(sprintf(\"  Absolute diff:   %.4f\\n\", comparison$diff_abs)) #>   Absolute diff:   0.0127 cat(sprintf(\"  Percent diff:    %.2f%%\\n\", comparison$diff_pct)) #>   Percent diff:    1.41% cat(sprintf(\"  Agreement (<5%%): %s\\n\", comparison$agreement)) #>   Agreement (<5%): TRUE"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"warm-start-benefits","dir":"Articles","previous_headings":"Level 2: Cross-Algorithm Validation","what":"Warm Start Benefits","title":"Validating Calibration Results","text":"Using EQC initialize SAC dramatically improves convergence agreement.","code":"# SAC without warm start (APC initialization) sac_cold <- sac_calibrate(   target_rho = 0.80, n_items = 25, model = \"rasch\",   item_source = \"parametric\", reliability_metric = \"info\",   c_init = NULL,  # APC start   n_iter = 300L, M_per_iter = 1000L,   seed = 42, verbose = FALSE )  # SAC with EQC warm start sac_warm <- sac_calibrate(   target_rho = 0.80, n_items = 25, model = \"rasch\",   item_source = \"parametric\", reliability_metric = \"info\",   c_init = eqc_cross,  # EQC warm start   n_iter = 300L, M_per_iter = 1000L,   seed = 42, verbose = FALSE )  cat(\"Effect of warm start on SAC-EQC agreement:\\n\") #> Effect of warm start on SAC-EQC agreement: cat(sprintf(\"  SAC (APC start): c* = %.4f, diff from EQC = %.4f\\n\",             sac_cold$c_star, abs(sac_cold$c_star - eqc_cross$c_star))) #>   SAC (APC start): c* = 0.9793, diff from EQC = 0.0798 cat(sprintf(\"  SAC (EQC start): c* = %.4f, diff from EQC = %.4f\\n\",             sac_warm$c_star, abs(sac_warm$c_star - eqc_cross$c_star))) #>   SAC (EQC start): c* = 0.9122, diff from EQC = 0.0127"},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"level-3-external-validation-with-tam","dir":"Articles","previous_headings":"","what":"Level 3: External Validation with TAM","title":"Validating Calibration Results","text":"External validation fits IRT model simulated response data using independent software package (TAM) compares recovered reliability design target.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"requirements","dir":"Articles","previous_headings":"Level 3: External Validation with TAM","what":"Requirements","title":"Validating Calibration Results","text":"","code":"# Install TAM if needed install.packages(\"TAM\")"},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"generating-response-data","dir":"Articles","previous_headings":"Level 3: External Validation with TAM","what":"Generating Response Data","title":"Validating Calibration Results","text":"simulate_response_data() function generates item response matrices calibrated parameters.","code":"sim_data <- simulate_response_data(   result = eqc_cross,   n_persons = 1000,   latent_shape = \"normal\",   seed = 123 )  cat(sprintf(\"Response matrix: %d persons x %d items\\n\",             nrow(sim_data$response_matrix),             ncol(sim_data$response_matrix))) #> Response matrix: 1000 persons x 25 items cat(sprintf(\"Theta: mean = %.3f, SD = %.3f\\n\",             mean(sim_data$theta), sd(sim_data$theta))) #> Theta: mean = 0.016, SD = 0.992 cat(sprintf(\"Item difficulty range: [%.2f, %.2f]\\n\",             min(sim_data$beta), max(sim_data$beta))) #> Item difficulty range: [-2.17, 1.45]"},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"computing-tam-reliability","dir":"Articles","previous_headings":"Level 3: External Validation with TAM","what":"Computing TAM Reliability","title":"Validating Calibration Results","text":"","code":"# Compute WLE and EAP reliability tam_rel <- compute_reliability_tam(   resp = sim_data$response_matrix,   model = \"rasch\",   verbose = FALSE )  cat(sprintf(\"External validation (TAM):\\n\")) cat(sprintf(\"  Target reliability:  %.4f\\n\", eqc_cross$target_rho)) cat(sprintf(\"  EQC achieved rho:    %.4f\\n\", eqc_cross$achieved_rho)) cat(sprintf(\"  TAM WLE reliability: %.4f\\n\", tam_rel$rel_wle)) cat(sprintf(\"  TAM EAP reliability: %.4f\\n\", tam_rel$rel_eap))"},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"understanding-wle-vs-eap-reliability","dir":"Articles","previous_headings":"","what":"Understanding WLE vs EAP Reliability","title":"Validating Calibration Results","text":"critical aspect external validation understanding TAM reports two different reliability coefficients bracket target.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"mathematical-definitions","dir":"Articles","previous_headings":"Understanding WLE vs EAP Reliability","what":"Mathematical Definitions","title":"Validating Calibration Results","text":"WLE Reliability (design-effect based): œÅWLE=1‚àís‚Äæ2VWLE \\rho_{\\text{WLE}} = 1 - \\frac{\\bar{s}^2}{V_{\\text{WLE}}} \\tag{1} s‚Äæ2=N‚àí1‚àëk=1NSE2(Œ∏ÃÇkWLE)\\bar{s}^2 = N^{-1} \\sum_{k=1}^N \\text{SE}^2(\\hat{\\theta}_k^{\\text{WLE}}) average squared standard error VWLEV_{\\text{WLE}} sample variance WLE estimates {Œ∏ÃÇkWLE}k=1N\\{\\hat{\\theta}_k^{\\text{WLE}}\\}_{k=1}^N. EAP Reliability (posterior variance based): œÅEAP=VEAPVEAP+œÉ‚Äæ2 \\rho_{\\text{EAP}} = \\frac{V_{\\text{EAP}}}{V_{\\text{EAP}} + \\bar{\\sigma}^2} \\tag{2} VEAPV_{\\text{EAP}} sample variance EAP estimates œÉ‚Äæ2=N‚àí1‚àëk=1NœÉk2\\bar{\\sigma}^2 = N^{-1} \\sum_{k=1}^N \\sigma^2_k average posterior variance.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"why-eap-geq-wle-always","dir":"Articles","previous_headings":"Understanding WLE vs EAP Reliability","what":"Why EAP ‚â•\\geq WLE Always","title":"Validating Calibration Results","text":"inequality œÅEAP‚â•œÅWLE\\rho_{\\text{EAP}} \\geq \\rho_{\\text{WLE}} consequence posterior shrinkage affects variance estimation. EAP shrinkage: EAP estimates shrunk toward prior mean, : Reduces variance estimates: VEAP<VWLEV_{\\text{EAP}} < V_{\\text{WLE}} Reduces average error variance: œÉ‚Äæ2<s‚Äæ2\\bar{\\sigma}^2 < \\bar{s}^2 error reduction proportionally larger variance reduction, resulting higher reliability ratio. Connection Jensen‚Äôs inequality: EAP reliability relates MSEM-based population reliability w‚Äæ\\bar{w}, WLE reliability relates closely average-information reliability œÅÃÉ\\tilde{\\rho}. ordering œÅEAP‚â•œÅWLE\\rho_{\\text{EAP}} \\geq \\rho_{\\text{WLE}} parallels theoretical œÅÃÉ‚â•w‚Äæ\\tilde{\\rho} \\geq \\bar{w} inequality, though finite-sample estimators introduce additional variability.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"practical-interpretation","dir":"Articles","previous_headings":"Understanding WLE vs EAP Reliability","what":"Practical Interpretation","title":"Validating Calibration Results","text":"Expected patterns (œÅ*=0.80\\rho^* = 0.80): WLE reliability: approximately 0.77‚Äì0.82 EAP reliability: approximately 0.82‚Äì0.86 within ¬±0.03\\pm 0.03 target excellent WLE within ¬±0.05\\pm 0.05 target acceptable","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"monte-carlo-validation-workflow","dir":"Articles","previous_headings":"","what":"Monte Carlo Validation Workflow","title":"Validating Calibration Results","text":"rigorous validation, use multiple replications account sampling variability data generation model fitting.","code":"# ==== Configuration ==== target_rho <- 0.80 n_items <- 25 n_persons <- 1000 n_reps <- 50  # ==== Step 1: Calibrate ==== eqc_result <- eqc_calibrate(   target_rho = target_rho,   n_items = n_items,   model = \"rasch\",   latent_shape = \"normal\",   item_source = \"parametric\",   M = 20000L,   seed = 42,   verbose = TRUE )  cat(sprintf(\"Calibrated c* = %.4f\\n\\n\", eqc_result$c_star))  # ==== Step 2: Monte Carlo Validation ==== wle_rels <- eap_rels <- numeric(n_reps)  for (r in 1:n_reps) {   sim_data <- simulate_response_data(     result = eqc_result,     n_persons = n_persons,     latent_shape = \"normal\",     seed = r   )    tam_rel <- compute_reliability_tam(     resp = sim_data$response_matrix,     model = \"rasch\",     verbose = FALSE   )    wle_rels[r] <- tam_rel$rel_wle   eap_rels[r] <- tam_rel$rel_eap    if (r %% 10 == 0) cat(sprintf(\"  Completed %d/%d\\n\", r, n_reps)) }  # ==== Step 3: Summarize ==== cat(\"\\nMonte Carlo Validation Results\\n\") cat(\"==============================\\n\") cat(sprintf(\"Target: %.3f\\n\\n\", target_rho)) cat(sprintf(\"WLE: Mean = %.4f, SD = %.4f, MAE = %.4f\\n\",             mean(wle_rels), sd(wle_rels),             mean(abs(wle_rels - target_rho)))) cat(sprintf(\"EAP: Mean = %.4f, SD = %.4f, MAE = %.4f\\n\",             mean(eap_rels), sd(eap_rels),             mean(abs(eap_rels - target_rho))))"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"the-960-condition-validation-study","dir":"Articles","previous_headings":"","what":"The 960-Condition Validation Study","title":"Validating Calibration Results","text":"paper (Lee, 2025) reports comprehensive validation study provides empirical evidence package‚Äôs accuracy across wide range conditions.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"study-design","dir":"Articles","previous_headings":"The 960-Condition Validation Study","what":"Study Design","title":"Validating Calibration Results","text":"validation study crossed following factors: Total: 3√ó4√ó4√ó4√ó5=9603 \\times 4 \\times 4 \\times 4 \\times 5 = 960 conditions. condition, study: Ran EQC calibration (M=20,000M = 20{,}000). Generated response data (N=1,000N = 1{,}000). Fitted model TAM. Computed WLE EAP reliability.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"key-findings","dir":"Articles","previous_headings":"The 960-Condition Validation Study","what":"Key Findings","title":"Validating Calibration Results","text":"validation study established following: Overall MAE: mean absolute error (MAE) EQC target TAM WLE reliability approximately 0.02 across 960 conditions, confirming package achieves design targets. Metric ordering: EAP reliability consistently higher WLE reliability, predicted theoretical analysis vignette(\"theory-reliability\"). EQC-SAC agreement: algorithms run condition, percent differences typically 5%, confirming theoretical consistency results. Latent shape sensitivity: Non-normal latent distributions (bimodal, heavy-tailed) showed slightly larger MAE values (approximately 0.03) compared normal distributions (approximately 0.015), reflecting increased Jensen‚Äôs gap. Test length effect: Longer tests (=50I = 50) produced stable reliability estimates (smaller SD across replications) compared shorter tests (=10I = 10). results provide confidence calibration algorithms accurate across wide range realistic simulation scenarios.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"validation-under-misspecification","dir":"Articles","previous_headings":"","what":"Validation Under Misspecification","title":"Validating Calibration Results","text":"important practical question : happens latent distribution used data generation match one used calibration?","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"demonstration-calibration-simulation-mismatch","dir":"Articles","previous_headings":"Validation Under Misspecification","what":"Demonstration: Calibration-Simulation Mismatch","title":"Validating Calibration Results","text":"","code":"# Calibrate under normal assumption eqc_normal <- eqc_calibrate(   target_rho = 0.80, n_items = 25, model = \"rasch\",   item_source = \"parametric\",   latent_shape = \"normal\",   M = 5000L, seed = 42, verbose = FALSE )  # Evaluate reliability under different simulation distributions sim_shapes <- c(\"normal\", \"bimodal\", \"heavy_tail\", \"skew_pos\") sim_pars <- list(   normal     = list(),   bimodal    = list(delta = 0.9),   heavy_tail = list(df = 5),   skew_pos   = list(k = 4) )  cat(\"Misspecification analysis:\\n\") #> Misspecification analysis: cat(\"  Calibration: normal, target = 0.80\\n\\n\") #>   Calibration: normal, target = 0.80 cat(sprintf(\"  %-14s %-10s %-10s %-10s\\n\",             \"Sim shape\", \"rho_tilde\", \"rho_bar\", \"Deviation\")) #>   Sim shape      rho_tilde  rho_bar    Deviation  for (sh in sim_shapes) {   theta_mis <- sim_latentG(5000, shape = sh, shape_params = sim_pars[[sh]])$theta   both_mis <- compute_rho_both(     eqc_normal$c_star, theta_mis,     eqc_normal$beta_vec, eqc_normal$lambda_base   )   dev <- both_mis$rho_tilde - eqc_normal$target_rho   cat(sprintf(\"  %-14s %-10.4f %-10.4f %+10.4f\\n\",               sh, both_mis$rho_tilde, both_mis$rho_bar, dev)) } #>   normal         0.7987     0.7923        -0.0013 #>   bimodal        0.7950     0.7928        -0.0050 #>   heavy_tail     0.7949     0.7761        -0.0051 #>   skew_pos       0.8006     0.7897        +0.0006"},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"implications","dir":"Articles","previous_headings":"Validation Under Misspecification","what":"Implications","title":"Validating Calibration Results","text":"simulation distribution differs calibration distribution: distribution: Achieved reliability matches target closely. Different distribution: Reliability deviates target, sometimes substantially. Recommendation: Always use latent distribution calibration data generation. need study misspecification effects, deliberately document mismatch.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"sensitivity-to-difficulty-ability-alignment","dir":"Articles","previous_headings":"Validation Under Misspecification","what":"Sensitivity to Difficulty-Ability Alignment","title":"Validating Calibration Results","text":"","code":"# Calibrate with default difficulty distribution (centered at 0) eqc_aligned <- eqc_calibrate(   target_rho = 0.80, n_items = 25, model = \"rasch\",   item_source = \"parametric\",   M = 5000L, seed = 42, verbose = FALSE )  # What if abilities are shifted? theta_shifted <- sim_latentG(5000, shape = \"normal\")$theta + 1.5  # shifted right  both_aligned <- compute_rho_both(   eqc_aligned$c_star,   sim_latentG(5000, shape = \"normal\")$theta,   eqc_aligned$beta_vec, eqc_aligned$lambda_base )  both_shifted <- compute_rho_both(   eqc_aligned$c_star,   theta_shifted,   eqc_aligned$beta_vec, eqc_aligned$lambda_base )  cat(\"Effect of ability-difficulty misalignment:\\n\") #> Effect of ability-difficulty misalignment: cat(sprintf(\"  Aligned (theta ~ N(0,1)):   rho_tilde = %.4f\\n\",             both_aligned$rho_tilde)) #>   Aligned (theta ~ N(0,1)):   rho_tilde = 0.8002 cat(sprintf(\"  Shifted (theta ~ N(1.5,1)): rho_tilde = %.4f\\n\",             both_shifted$rho_tilde)) #>   Shifted (theta ~ N(1.5,1)): rho_tilde = 0.7651 cat(sprintf(\"  Reliability change:         %+.4f\\n\",             both_shifted$rho_tilde - both_aligned$rho_tilde)) #>   Reliability change:         -0.0351"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"issue-1-large-discrepancy-between-target-and-achieved-reliability","dir":"Articles","previous_headings":"Troubleshooting Guide","what":"Issue 1: Large Discrepancy Between Target and Achieved Reliability","title":"Validating Calibration Results","text":"Symptoms: |achieved_rho - target_rho| > 0.01","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"issue-2-wle-reliability-much-lower-than-target","dir":"Articles","previous_headings":"Troubleshooting Guide","what":"Issue 2: WLE Reliability Much Lower Than Target","title":"Validating Calibration Results","text":"Symptoms: œÅWLE<œÅ*‚àí0.05\\rho_{\\text{WLE}} < \\rho^* - 0.05 consistently often expected behavior rather calibration failure. WLE reliability conservative measure (see Section 5 ). Diagnostic: Check EAP reliability closer target. midpoint (œÅWLE+œÅEAP)/2(\\rho_{\\text{WLE}} + \\rho_{\\text{EAP}}) / 2 near œÅ*\\rho^*, calibration working correctly.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"issue-3-high-variability-across-replications","dir":"Articles","previous_headings":"Troubleshooting Guide","what":"Issue 3: High Variability Across Replications","title":"Validating Calibration Results","text":"Symptoms: SD TAM reliability estimates >0.03> 0.03","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"issue-4-eqc-and-sac-disagree-by-10","dir":"Articles","previous_headings":"Troubleshooting Guide","what":"Issue 4: EQC and SAC Disagree by >10%> 10\\%","title":"Validating Calibration Results","text":"Symptoms: compare_eqc_sac() shows large difference Step--step diagnosis: Verify use reliability_metric. Check SAC convergence: sac_result$convergence$converged. Increase SAC iterations: n_iter = 500. Check SAC hit bounds: sac_result$convergence$hit_lower_bound. Run SAC EQC warm start already .","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"issue-5-target-reliability-not-achievable","dir":"Articles","previous_headings":"Troubleshooting Guide","what":"Issue 5: Target Reliability Not Achievable","title":"Validating Calibration Results","text":"Symptoms: EQC returns boundary c*c^* warning. Solutions: Use reliability_metric = \"info\" (yields higher values \"msem\"). Extend c_bounds (e.g., c(0.01, 20)). Increase n_items. Accept maximum achievable reliability check_feasibility().","code":"# Use check_feasibility() to diagnose feas <- check_feasibility(   n_items = 15, model = \"rasch\",   item_source = \"parametric\",   c_bounds = c(0.1, 10),   M = 5000L, seed = 42 ) #>  #> ======================================================= #>   Feasibility Check: Achievable Reliability Range #> ======================================================= #>  #>   Number of items  : 15 #>   Model            : RASCH #>   Latent shape     : normal #>   Latent variance  : 1.0099 #>   c range          : [0.10, 10.00] #>   Monte Carlo M    : 5000 #>  #> Achievable Reliability Ranges: #>   rho_tilde (info) : [0.0363, 0.9797] #>   rho_bar   (msem) : [0.0000, 0.8513] #>  #> Note: rho_tilde >= rho_bar always (Jensen's inequality). #>   Use rho_tilde range for EQC targets. #>   Use rho_bar range for SAC targets."},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"issue-6-reproducibility-failures","dir":"Articles","previous_headings":"Troubleshooting Guide","what":"Issue 6: Reproducibility Failures","title":"Validating Calibration Results","text":"Symptoms: Different results seed.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"complete-validation-template","dir":"Articles","previous_headings":"","what":"Complete Validation Template","title":"Validating Calibration Results","text":"self-contained template can copied adapted simulation study.","code":"# ============================================================== # IRTsimrel Validation Template # ==============================================================  library(IRTsimrel)  # ---- Configuration ---- TARGET_RHO     <- 0.80 N_ITEMS        <- 25 N_PERSONS      <- 1000 N_REPS         <- 50 MODEL          <- \"rasch\" LATENT_SHAPE   <- \"normal\" LATENT_PARAMS  <- list() ITEM_SOURCE    <- \"parametric\" ITEM_PARAMS    <- list() SEED_CALIB     <- 42  # ---- Step 1: Feasibility Check ---- cat(\"Step 1: Feasibility check...\\n\") feas <- check_feasibility(   n_items = N_ITEMS, model = MODEL,   latent_shape = LATENT_SHAPE,   item_source = ITEM_SOURCE,   c_bounds = c(0.1, 10),   M = 10000L, seed = SEED_CALIB,   latent_params = LATENT_PARAMS,   item_params = ITEM_PARAMS )  stopifnot(TARGET_RHO >= feas$rho_range_info[1],           TARGET_RHO <= feas$rho_range_info[2])  # ---- Step 2: EQC Calibration ---- cat(\"\\nStep 2: EQC calibration...\\n\") eqc_result <- eqc_calibrate(   target_rho = TARGET_RHO,   n_items = N_ITEMS,   model = MODEL,   latent_shape = LATENT_SHAPE,   item_source = ITEM_SOURCE,   latent_params = LATENT_PARAMS,   item_params = ITEM_PARAMS,   reliability_metric = \"info\",   M = 20000L,   seed = SEED_CALIB,   verbose = TRUE )  # ---- Step 3: SAC Cross-Validation ---- cat(\"\\nStep 3: SAC cross-validation...\\n\") sac_result <- sac_calibrate(   target_rho = TARGET_RHO,   n_items = N_ITEMS,   model = MODEL,   latent_shape = LATENT_SHAPE,   item_source = ITEM_SOURCE,   latent_params = LATENT_PARAMS,   item_params = ITEM_PARAMS,   reliability_metric = \"info\",   c_init = eqc_result,   n_iter = 300L,   M_per_iter = 1000L,   seed = SEED_CALIB,   verbose = TRUE )  comparison <- compare_eqc_sac(eqc_result, sac_result) stopifnot(comparison$agreement)  # ---- Step 4: Jensen's Gap Check ---- cat(\"\\nStep 4: Jensen's gap check...\\n\") theta_check <- sim_latentG(10000, shape = LATENT_SHAPE,                             params = LATENT_PARAMS)$theta both_check <- compute_rho_both(   eqc_result$c_star, theta_check,   eqc_result$beta_vec, eqc_result$lambda_base ) cat(sprintf(\"  Jensen's gap: %.4f\\n\",             both_check$rho_tilde - both_check$rho_bar))  # ---- Step 5: Monte Carlo TAM Validation ---- cat(\"\\nStep 5: Monte Carlo TAM validation...\\n\")  library(TAM)  wle_rels <- eap_rels <- numeric(N_REPS)  for (r in 1:N_REPS) {   sim_data <- simulate_response_data(     result = eqc_result,     n_persons = N_PERSONS,     latent_shape = LATENT_SHAPE,     latent_params = LATENT_PARAMS,     seed = r   )    tam_rel <- compute_reliability_tam(     resp = sim_data$response_matrix,     model = MODEL,     verbose = FALSE   )    wle_rels[r] <- tam_rel$rel_wle   eap_rels[r] <- tam_rel$rel_eap    if (r %% 10 == 0) cat(sprintf(\"  %d/%d complete\\n\", r, N_REPS)) }  # ---- Step 6: Summary Report ---- cat(\"\\n\") cat(\"=======================================================\\n\") cat(\"  VALIDATION SUMMARY\\n\") cat(\"=======================================================\\n\\n\")  cat(sprintf(\"Configuration:\\n\")) cat(sprintf(\"  Target: %.3f | Items: %d | Model: %s\\n\",             TARGET_RHO, N_ITEMS, MODEL)) cat(sprintf(\"  Shape: %s | N: %d | Reps: %d\\n\\n\",             LATENT_SHAPE, N_PERSONS, N_REPS))  cat(sprintf(\"Calibration:\\n\")) cat(sprintf(\"  EQC c*: %.4f (achieved = %.4f)\\n\",             eqc_result$c_star, eqc_result$achieved_rho)) cat(sprintf(\"  SAC c*: %.4f (agreement: %s)\\n\\n\",             sac_result$c_star,             ifelse(comparison$agreement, \"YES\", \"NO\")))  cat(sprintf(\"TAM Validation:\\n\")) cat(sprintf(\"  WLE: Mean=%.4f SD=%.4f MAE=%.4f\\n\",             mean(wle_rels), sd(wle_rels),             mean(abs(wle_rels - TARGET_RHO)))) cat(sprintf(\"  EAP: Mean=%.4f SD=%.4f MAE=%.4f\\n\",             mean(eap_rels), sd(eap_rels),             mean(abs(eap_rels - TARGET_RHO))))  verdict <- ifelse(mean(abs(wle_rels - TARGET_RHO)) < 0.03,                   \"PASSED\", \"INVESTIGATE\") cat(sprintf(\"\\nVerdict: %s\\n\", verdict))"},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Validating Calibration Results","text":"Effective validation reliability-targeted simulation requires multiple complementary approaches: Best practices: Always check Jensen‚Äôs gap compute_rho_both() understand impact metric choice. Use EQC warm start SAC cross-validation. Report WLE EAP reliability TAM validation. Use Npersons‚â•1,000N_{\\text{persons}} \\geq 1{,}000 stable TAM estimates. Match latent distribution calibration simulation. Document seed package version reproducibility.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/articles/validation.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Validating Calibration Results","text":"Lee, J. (2025). Reliability-targeted simulation item response data: Solving inverse design problem. arXiv preprint arXiv:2512.16012. Warm, T. . (1989). Weighted likelihood estimation ability item response theory. Psychometrika, 54(3), 427‚Äì450. Robitzsch, ., Kiefer, T., & Wu, M. (2022). TAM: Test Analysis Modules. R package version 4.1-4. Bock, R. D., & Mislevy, R. J. (1982). Adaptive EAP estimation ability microcomputer environment. Applied Psychological Measurement, 6(4), 431‚Äì444.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"JoonHo Lee. Author, maintainer.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Lee J (2026). IRTsimrel: Reliability-Targeted Simulation Item Response Data. R package version 0.2.0, https://github.com/joonho112/IRTsimrel.","code":"@Manual{,   title = {IRTsimrel: Reliability-Targeted Simulation for Item Response Data},   author = {JoonHo Lee},   year = {2026},   note = {R package version 0.2.0},   url = {https://github.com/joonho112/IRTsimrel}, }"},{"path":"https://joonho112.github.io/IRTsimrel/index.html","id":"irtsimrel-","dir":"","previous_headings":"","what":"IRTsimrel","title":"IRTsimrel","text":"IRTsimrel R package reliability-targeted simulation Item Response Theory (IRT) data. Rather treating reliability afterthought, IRTsimrel lets specify target marginal reliability explicit input‚Äîcalibrates data-generating process achieve exactly. Marginal reliability IRT serves role ICC multilevel modeling.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/index.html","id":"why-this-matters","dir":"","previous_headings":"","what":"Why This Matters","title":"IRTsimrel","text":"Monte Carlo IRT studies, researchers routinely vary sample size, test length, item parameters‚Äîmarginal reliability almost never directly controlled. leads three problems: Just multilevel modelers always specify ICC, IRT simulators always specify target reliability. IRTsimrel makes easy.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"IRTsimrel","text":"","code":"# install.packages(\"remotes\") remotes::install_github(\"joonho112/IRTsimrel\")"},{"path":"https://joonho112.github.io/IRTsimrel/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick Start","title":"IRTsimrel","text":"Calibrate 25-item Rasch simulation achieve œÅ=0.80\\rho = 0.80: Generate response matrix ‚Äôre ready analysis: See vignette(\"quick-start\") 5-minute walkthrough, vignette(\"applied-guide\") full 6-step workflow.","code":"library(IRTsimrel)  result <- eqc_calibrate(   target_rho  = 0.80,   n_items     = 25,   model       = \"rasch\",   item_source = \"parametric\",   M           = 10000,   seed        = 42 )  result #>  #> ======================================================= #>   Empirical Quadrature Calibration (EQC) Results #> ======================================================= #>  #> Calibration Summary: #>   Model                        : RASCH #>   Target reliability (rho*)    : 0.8000 #>   Achieved reliability         : 0.8000 #>   Absolute error               : 1.42e-07 #>   Scaling factor (c*)          : 0.9059 #>  #> Design Parameters: #>   Number of items (I)          : 25 #>   Quadrature points (M)        : 10000 #>   Reliability metric           : Average-information (tilde) #>   Latent variance              : 1.0123 #>  #> Convergence: #>   Root status                  : uniroot_success #>   Search bracket               : [0.300, 3.000] #>   Bracket reliabilities        : [0.3540, 0.9532] #>  #> Parameter Summaries: #>   theta:        mean = -0.011, sd = 1.006 #>   beta:         mean = -0.000, sd = 0.909, range = [-1.60, 1.73] #>   lambda_base:  mean = 1.000, sd = 0.000 #>   lambda_scaled: mean = 0.906, sd = 0.000 sim_data <- simulate_response_data(result, n_persons = 1000, seed = 123) dim(sim_data$response_matrix) #> [1] 1000   25"},{"path":"https://joonho112.github.io/IRTsimrel/index.html","id":"how-it-works","dir":"","previous_headings":"","what":"How It Works","title":"IRTsimrel","text":"IRTsimrel separates structure scale: Structure ‚Äî Realistic item difficulties, discriminations, latent distributions drawn empirically-grounded generators. Scale ‚Äî single global scaling factor c*c^* calibrated Œªi*=c*‚ãÖŒªi,0\\lambda_i^* = c^* \\cdot \\lambda_{,0} yields target reliability. means can vary reliability independently design features‚Äîjust like varying ICC multilevel simulation.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/index.html","id":"two-calibration-algorithms","dir":"","previous_headings":"How It Works","what":"Two Calibration Algorithms","title":"IRTsimrel","text":"algorithms converge c*c^*, calibration highly trustworthy.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/index.html","id":"id_12-pre-standardized-latent-distributions","dir":"","previous_headings":"How It Works","what":"12 Pre-Standardized Latent Distributions","title":"IRTsimrel","text":"12 built-shapes (normal, bimodal, trimodal, skewed, heavy-tailed, uniform, floor/ceiling effects) pre-standardized mean 0 variance 1. ensures distributional shape cleanly separated scale‚Äîenabling rigorous factorial manipulation.","code":"compare_shapes(   n = 3000,   shapes = c(\"normal\", \"bimodal\", \"skew_pos\", \"heavy_tail\"),   seed = 42 )"},{"path":"https://joonho112.github.io/IRTsimrel/index.html","id":"empirically-realistic-item-parameters","dir":"","previous_headings":"How It Works","what":"Empirically Realistic Item Parameters","title":"IRTsimrel","text":"Generate item parameters four sources (parametric, IRW, hierarchical, custom) empirically-observed difficulty‚Äìdiscrimination correlation (œÅ‚âà‚àí0.3\\rho \\approx -0.3) preserved via copula methods.","code":"items <- sim_item_params(   n_items = 30, model = \"2pl\",   source = \"irw\", method = \"copula\",   discrimination_params = list(rho = -0.3) )"},{"path":"https://joonho112.github.io/IRTsimrel/index.html","id":"feasibility-screening","dir":"","previous_headings":"How It Works","what":"Feasibility Screening","title":"IRTsimrel","text":"calibrating, verify target reliability achievable visualize reliability‚Äìscaling curve:","code":"check_feasibility(n_items = 25, model = \"rasch\", seed = 42) rho_curve(n_items = 25, model = \"rasch\", seed = 42, plot = TRUE)"},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"IRTsimrel","text":"IRTsimrel includes 12 vignettes organized two tracks: Getting Started ‚Äî vignette(\"introduction\") | vignette(\"quick-start\") Applied Researchers Track ‚Äî running simulation studies: vignette(\"applied-guide\") ‚Äî 6-step workflow feasibility check data export vignette(\"latent-distributions\") ‚Äî 12 shapes examples vignette(\"item-parameters\") ‚Äî Parametric, IRW, hierarchical, custom item generation vignette(\"simulation-design\") ‚Äî Designing factorial Monte Carlo studies reliability factor vignette(\"case-studies\") ‚Äî Three complete publication-ready simulation templates Methodological Researchers Track ‚Äî understanding theory: vignette(\"theory-reliability\") ‚Äî Formal reliability definitions, Jensen‚Äôs inequality, inverse design problem vignette(\"algorithm-eqc\") ‚Äî EQC convergence theory diagnostics vignette(\"algorithm-sac\") ‚Äî SAC step-size analysis Polyak‚ÄìRuppert averaging vignette(\"validation\") ‚Äî Three-level validation framework vignette(\"api-reference\") ‚Äî Complete function reference examples","code":""},{"path":"https://joonho112.github.io/IRTsimrel/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"IRTsimrel","text":"","code":"Lee, J.-H. (2025). Reliability-targeted simulation for item response data. arXiv preprint arXiv:2512.16012. https://arxiv.org/abs/2512.16012"},{"path":"https://joonho112.github.io/IRTsimrel/index.html","id":"related-work","dir":"","previous_headings":"","what":"Related Work","title":"IRTsimrel","text":"TAM ‚Äî Test Analysis Modules IRT mirt ‚Äî Multidimensional Item Response Theory irw ‚Äî Item Response Warehouse","code":""},{"path":"https://joonho112.github.io/IRTsimrel/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"IRTsimrel","text":"MIT","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/IRTsimrel-package.html","id":null,"dir":"Reference","previous_headings":"","what":"IRTsimrel: Reliability-Targeted Simulation for Item Response Data ‚Äî IRTsimrel-package","title":"IRTsimrel: Reliability-Targeted Simulation for Item Response Data ‚Äî IRTsimrel-package","text":"framework reliability-targeted simulation studies Item Response Theory (IRT). Researchers specify target reliability level, package calibrates item discriminations achieve target.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/IRTsimrel-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"IRTsimrel: Reliability-Targeted Simulation for Item Response Data ‚Äî IRTsimrel-package","text":"Main functions: eqc_calibrate: Empirical Quadrature Calibration (recommended) sac_calibrate: Stochastic Approximation Calibration sim_latentG: Generate latent ability distributions sim_item_params: Generate item parameters simulate_response_data: Generate response data","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/reference/IRTsimrel-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"IRTsimrel: Reliability-Targeted Simulation for Item Response Data ‚Äî IRTsimrel-package","text":"JoonHo Lee","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/as.data.frame.item_params.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract item parameters as data frame ‚Äî as.data.frame.item_params","title":"Extract item parameters as data frame ‚Äî as.data.frame.item_params","text":"Extract item parameters data frame","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/as.data.frame.item_params.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract item parameters as data frame ‚Äî as.data.frame.item_params","text":"","code":"# S3 method for class 'item_params' as.data.frame(x, row.names = NULL, optional = FALSE, ...)"},{"path":"https://joonho112.github.io/IRTsimrel/reference/as.data.frame.item_params.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract item parameters as data frame ‚Äî as.data.frame.item_params","text":"x item_params object. row.names NULL character vector giving row names. optional Logical. TRUE, setting row names optional. ... Additional arguments (ignored).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/as.data.frame.item_params.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract item parameters as data frame ‚Äî as.data.frame.item_params","text":"data frame item parameters.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/as.numeric.latent_G.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract theta values from latent_G object ‚Äî as.numeric.latent_G","title":"Extract theta values from latent_G object ‚Äî as.numeric.latent_G","text":"Convenience function extract theta vector use functions.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/as.numeric.latent_G.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract theta values from latent_G object ‚Äî as.numeric.latent_G","text":"","code":"# S3 method for class 'latent_G' as.numeric(x, ...)"},{"path":"https://joonho112.github.io/IRTsimrel/reference/as.numeric.latent_G.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract theta values from latent_G object ‚Äî as.numeric.latent_G","text":"x latent_G object. ... Additional arguments (ignored).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/as.numeric.latent_G.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract theta values from latent_G object ‚Äî as.numeric.latent_G","text":"Numeric vector latent abilities.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/check_feasibility.html","id":null,"dir":"Reference","previous_headings":"","what":"Check Feasibility of Target Reliability ‚Äî check_feasibility","title":"Check Feasibility of Target Reliability ‚Äî check_feasibility","text":"Screens whether given target reliability achievable particular test design (number items, model, latent distribution, item source) computing range achievable reliabilities across range scaling factors. function useful determining whether planned simulation study feasible running (potentially expensive) calibration algorithms.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/check_feasibility.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check Feasibility of Target Reliability ‚Äî check_feasibility","text":"","code":"check_feasibility(   n_items,   model = c(\"rasch\", \"2pl\"),   latent_shape = \"normal\",   item_source = \"parametric\",   c_bounds = c(0.1, 10),   M = 10000L,   seed = NULL,   latent_params = list(),   item_params = list(),   verbose = TRUE )  # S3 method for class 'feasibility_check' print(x, digits = 4, ...)"},{"path":"https://joonho112.github.io/IRTsimrel/reference/check_feasibility.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check Feasibility of Target Reliability ‚Äî check_feasibility","text":"n_items Integer. Number items test form. model Character. Measurement model: \"rasch\" \"2pl\". latent_shape Character. Shape argument passed sim_latentG(). item_source Character. Source argument passed sim_item_params(). c_bounds Numeric length-2 vector. Range scaling factors evaluate. Default: c(0.1, 10). M Integer. Monte Carlo sample size theta. Default: 10000. seed Optional integer reproducibility. latent_params List. Additional arguments passed sim_latentG(). item_params List. Additional arguments passed sim_item_params(). verbose Logical. TRUE, print results. x object class \"feasibility_check\". digits Integer. Number decimal places printing. ... Additional arguments (ignored).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/check_feasibility.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check Feasibility of Target Reliability ‚Äî check_feasibility","text":"object class \"feasibility_check\" (list) : rho_range_info Numeric length-2 vector: achievable range average-information reliability (\\(\\tilde{\\rho}\\)). rho_range_msem Numeric length-2 vector: achievable range MSEM-based reliability (\\(\\bar{w}\\)). n_items Number items. model Model used. latent_shape Latent distribution shape. c_bounds Scaling factor bounds evaluated. M Monte Carlo sample size. theta_var Estimated latent variance. input object, invisibly.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/check_feasibility.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check Feasibility of Target Reliability ‚Äî check_feasibility","text":"average-information metric (\\(\\tilde{\\rho}\\)), reliability monotone \\(c\\), range simply \\([\\tilde{\\rho}(c_{min}), \\tilde{\\rho}(c_{max})]\\). MSEM-based metric (\\(\\bar{w}\\)), reliability can non-monotone extreme scaling factors. function uses optimize find maximum within bounds, range \\([\\min(\\bar{w}(c_{min}), \\bar{w}(c_{max})), \\bar{w}_{max}]\\).","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/reference/check_feasibility.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check Feasibility of Target Reliability ‚Äî check_feasibility","text":"","code":"# Check feasibility for 25-item Rasch test feas <- check_feasibility(n_items = 25, model = \"rasch\", seed = 42, M = 5000) #>  #> ======================================================= #>   Feasibility Check: Achievable Reliability Range #> ======================================================= #>  #>   Number of items  : 25 #>   Model            : RASCH #>   Latent shape     : normal #>   Latent variance  : 1.0099 #>   c range          : [0.10, 10.00] #>   Monte Carlo M    : 5000 #>  #> Achievable Reliability Ranges: #>   rho_tilde (info) : [0.0591, 0.9872] #>   rho_bar   (msem) : [0.0002, 0.9146] #>  #> Note: rho_tilde >= rho_bar always (Jensen's inequality). #>   Use rho_tilde range for EQC targets. #>   Use rho_bar range for SAC targets. #>  print(feas) #>  #> ======================================================= #>   Feasibility Check: Achievable Reliability Range #> ======================================================= #>  #>   Number of items  : 25 #>   Model            : RASCH #>   Latent shape     : normal #>   Latent variance  : 1.0099 #>   c range          : [0.10, 10.00] #>   Monte Carlo M    : 5000 #>  #> Achievable Reliability Ranges: #>   rho_tilde (info) : [0.0591, 0.9872] #>   rho_bar   (msem) : [0.0002, 0.9146] #>  #> Note: rho_tilde >= rho_bar always (Jensen's inequality). #>   Use rho_tilde range for EQC targets. #>   Use rho_bar range for SAC targets. #>   # Can we achieve rho = 0.90? 0.90 >= feas$rho_range_info[1] && 0.90 <= feas$rho_range_info[2] #> [1] TRUE"},{"path":"https://joonho112.github.io/IRTsimrel/reference/coef.eqc_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Calibrated Item Parameters from EQC Results ‚Äî coef.eqc_result","title":"Extract Calibrated Item Parameters from EQC Results ‚Äî coef.eqc_result","text":"Returns calibrated item parameters data frame.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/coef.eqc_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Calibrated Item Parameters from EQC Results ‚Äî coef.eqc_result","text":"","code":"# S3 method for class 'eqc_result' coef(object, ...)"},{"path":"https://joonho112.github.io/IRTsimrel/reference/coef.eqc_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Calibrated Item Parameters from EQC Results ‚Äî coef.eqc_result","text":"object object class \"eqc_result\". ... Additional arguments (ignored).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/coef.eqc_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Calibrated Item Parameters from EQC Results ‚Äî coef.eqc_result","text":"data frame columns: item_id Item identifier (1 ). beta Item difficulty. lambda_base Baseline (unscaled) discrimination. lambda_scaled Scaled discrimination (lambda_base * c*). c_star Calibrated scaling factor (items).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/coef.eqc_result.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Calibrated Item Parameters from EQC Results ‚Äî coef.eqc_result","text":"","code":"# \\donttest{ eqc_res <- eqc_calibrate(target_rho = 0.80, n_items = 25,                           model = \"rasch\", seed = 42, M = 5000) coef(eqc_res) #>    item_id         beta lambda_base lambda_scaled    c_star #> 1        1  0.197732269           1     0.8994993 0.8994993 #> 2        2  1.096799859           1     0.8994993 0.8994993 #> 3        3  0.436545084           1     0.8994993 0.8994993 #> 4        4 -0.013038730           1     0.8994993 0.8994993 #> 5        5 -0.199801302           1     0.8994993 0.8994993 #> 6        6  0.007700326           1     0.8994993 0.8994993 #> 7        7  1.020068726           1     0.8994993 0.8994993 #> 8        8  0.337624343           1     0.8994993 0.8994993 #> 9        9 -0.362269961           1     0.8994993 0.8994993 #> 10      10 -0.093862093           1     0.8994993 0.8994993 #> 11      11 -2.169735948           1     0.8994993 0.8994993 #> 12      12  0.403422109           1     0.8994993 0.8994993 #> 13      13  1.100326100           1     0.8994993 0.8994993 #> 14      14 -1.010084428           1     0.8994993 0.8994993 #> 15      15  0.222591967           1     0.8994993 0.8994993 #> 16      16 -0.358839904           1     0.8994993 0.8994993 #> 17      17 -0.661889194           1     0.8994993 0.8994993 #> 18      18  0.214349687           1     0.8994993 0.8994993 #> 19      19 -0.615836104           1     0.8994993 0.8994993 #> 20      20  0.049153126           1     0.8994993 0.8994993 #> 21      21  1.449782647           1     0.8994993 0.8994993 #> 22      22 -1.574952086           1     0.8994993 0.8994993 #> 23      23 -0.546968292           1     0.8994993 0.8994993 #> 24      24 -0.303196880           1     0.8994993 0.8994993 #> 25      25  1.374378677           1     0.8994993 0.8994993 # }"},{"path":"https://joonho112.github.io/IRTsimrel/reference/coef.sac_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Calibrated Item Parameters from SAC Results ‚Äî coef.sac_result","title":"Extract Calibrated Item Parameters from SAC Results ‚Äî coef.sac_result","text":"Returns calibrated item parameters data frame.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/coef.sac_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Calibrated Item Parameters from SAC Results ‚Äî coef.sac_result","text":"","code":"# S3 method for class 'sac_result' coef(object, ...)"},{"path":"https://joonho112.github.io/IRTsimrel/reference/coef.sac_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Calibrated Item Parameters from SAC Results ‚Äî coef.sac_result","text":"object object class \"sac_result\". ... Additional arguments (ignored).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/coef.sac_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Calibrated Item Parameters from SAC Results ‚Äî coef.sac_result","text":"data frame columns: item_id Item identifier (1 ). beta Item difficulty. lambda_base Baseline (unscaled) discrimination. lambda_scaled Scaled discrimination (lambda_base * c*). c_star Calibrated scaling factor (items).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/coef.sac_result.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Calibrated Item Parameters from SAC Results ‚Äî coef.sac_result","text":"","code":"if (FALSE) { # \\dontrun{ sac_res <- sac_calibrate(target_rho = 0.75, n_items = 20,                           model = \"rasch\", n_iter = 200, seed = 42) coef(sac_res) } # }"},{"path":"https://joonho112.github.io/IRTsimrel/reference/compare_eqc_sac.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare EQC and SAC Calibration Results ‚Äî compare_eqc_sac","title":"Compare EQC and SAC Calibration Results ‚Äî compare_eqc_sac","text":"Compares calibration results EQC SAC algorithms.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/compare_eqc_sac.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare EQC and SAC Calibration Results ‚Äî compare_eqc_sac","text":"","code":"compare_eqc_sac(eqc_result, sac_result, verbose = TRUE)  compare_eqc_spc(...)"},{"path":"https://joonho112.github.io/IRTsimrel/reference/compare_eqc_sac.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare EQC and SAC Calibration Results ‚Äî compare_eqc_sac","text":"eqc_result object class \"eqc_result\". sac_result object class \"sac_result\" (\"spc_result\" backward compatibility). verbose Logical. TRUE, print comparison summary. ... Arguments passed compare_eqc_sac().","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/compare_eqc_sac.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare EQC and SAC Calibration Results ‚Äî compare_eqc_sac","text":"list comparison statistics (invisibly): c_eqc Calibrated c* EQC. c_sac Calibrated c* SAC. diff_abs Absolute difference c* values. diff_pct Percent difference relative EQC. agreement Logical. TRUE difference < 5%. target_rho Target reliability.","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/reference/compare_eqc_sac.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare EQC and SAC Calibration Results ‚Äî compare_eqc_sac","text":"","code":"if (FALSE) { # \\dontrun{ # Run both algorithms eqc_result <- eqc_calibrate(target_rho = 0.80, n_items = 25, seed = 42) sac_result <- sac_calibrate(target_rho = 0.80, n_items = 25,                             c_init = eqc_result, seed = 42)  # Compare results compare_eqc_sac(eqc_result, sac_result) } # }"},{"path":"https://joonho112.github.io/IRTsimrel/reference/compare_shapes.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare Multiple Distribution Shapes ‚Äî compare_shapes","title":"Compare Multiple Distribution Shapes ‚Äî compare_shapes","text":"Generates compares multiple latent ability distributions side--side.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/compare_shapes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare Multiple Distribution Shapes ‚Äî compare_shapes","text":"","code":"compare_shapes(   n = 2000,   shapes = c(\"normal\", \"bimodal\", \"trimodal\", \"skew_pos\", \"skew_neg\", \"heavy_tail\",     \"uniform\"),   sigma = 1,   seed = NULL )"},{"path":"https://joonho112.github.io/IRTsimrel/reference/compare_shapes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare Multiple Distribution Shapes ‚Äî compare_shapes","text":"n Integer. Sample size distribution. shapes Character vector. Shapes compare. sigma Numeric. Common scale parameter. seed Integer. Random seed.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/compare_shapes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare Multiple Distribution Shapes ‚Äî compare_shapes","text":"ggplot2 object faceted density plots.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/compare_shapes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare Multiple Distribution Shapes ‚Äî compare_shapes","text":"","code":"if (FALSE) { # \\dontrun{ compare_shapes(n = 3000) } # }"},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_apc_init.html","id":null,"dir":"Reference","previous_headings":"","what":"Analytic Pre-Calibration (APC) Initialization ‚Äî compute_apc_init","title":"Analytic Pre-Calibration (APC) Initialization ‚Äî compute_apc_init","text":"Computes initial value scaling factor using closed-form approximation Gaussian Rasch assumptions.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_apc_init.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Analytic Pre-Calibration (APC) Initialization ‚Äî compute_apc_init","text":"","code":"compute_apc_init(target_rho, n_items, sigma_beta = 1)"},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_apc_init.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Analytic Pre-Calibration (APC) Initialization ‚Äî compute_apc_init","text":"target_rho Numeric. Target reliability. n_items Integer. Number items. sigma_beta Numeric. SD item difficulties (default: 1.0).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_apc_init.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Analytic Pre-Calibration (APC) Initialization ‚Äî compute_apc_init","text":"Numeric. Initial scaling factor c_init.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_apc_init.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Analytic Pre-Calibration (APC) Initialization ‚Äî compute_apc_init","text":"Gaussian Rasch setting \\(\\theta \\sim N(0,1)\\) \\(\\beta \\sim N(0, \\sigma_\\beta^2)\\), expected item information involves logistic-normal convolution: $$\\kappa(\\sigma^2) = \\int \\frac{e^z}{(1+e^z)^2} \\phi(z; 0, \\sigma^2) dz$$ Approximating \\(\\kappa \\approx 0.25 / \\sqrt{1 + \\sigma^2 \\pi^2/3}\\), closed-form pre-calibration : $$c_{init} = \\sqrt{\\frac{\\rho^*}{\\cdot \\kappa \\cdot (1 - \\rho^*)}}$$","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_apc_init.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Analytic Pre-Calibration (APC) Initialization ‚Äî compute_apc_init","text":"","code":"# Compute initial c for target reliability of 0.80 with 25 items compute_apc_init(target_rho = 0.80, n_items = 25) #> [1] 1.327405  # With different difficulty spread compute_apc_init(target_rho = 0.75, n_items = 20, sigma_beta = 1.5) #> [1] 1.432348"},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_reliability_tam.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute WLE and EAP Reliability Using TAM ‚Äî compute_reliability_tam","title":"Compute WLE and EAP Reliability Using TAM ‚Äî compute_reliability_tam","text":"Fits Rasch 2PL model using TAM computes WLE EAP reliability using official WLErel() EAPrel() functions.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_reliability_tam.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute WLE and EAP Reliability Using TAM ‚Äî compute_reliability_tam","text":"","code":"compute_reliability_tam(resp, model = c(\"rasch\", \"2pl\"), verbose = FALSE, ...)"},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_reliability_tam.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute WLE and EAP Reliability Using TAM ‚Äî compute_reliability_tam","text":"resp Matrix data.frame item responses (0/1). model Character. \"rasch\" \"2pl\". verbose Logical. TRUE, print fitting messages. ... Additional arguments passed TAM fitting functions.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_reliability_tam.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute WLE and EAP Reliability Using TAM ‚Äî compute_reliability_tam","text":"list components: rel_wle WLE reliability. rel_eap EAP reliability. mod Fitted TAM model object. wle Output TAM::tam.wle().","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_reliability_tam.html","id":"wle-vs-eap-reliability","dir":"Reference","previous_headings":"","what":"WLE vs EAP Reliability","title":"Compute WLE and EAP Reliability Using TAM ‚Äî compute_reliability_tam","text":"TAM defines reliability coefficients differently: WLE reliability: \\(1 - \\bar{s}^2 / V_{WLE}\\), based design effect EAP reliability: \\(V_{EAP} / (V_{EAP} + \\bar{\\sigma}^2)\\), based posterior variance Mathematically, \\(\\rho_{EAP} \\geq \\rho_{WLE}\\) always holds TAM's definitions. EAP reliability closely corresponds MSEM-based population reliability. conservative inference, treat WLE lower bound.","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_reliability_tam.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute WLE and EAP Reliability Using TAM ‚Äî compute_reliability_tam","text":"","code":"if (FALSE) { # \\dontrun{ # Simulate response data from calibration results sim_data <- simulate_response_data(result = eqc_result, n_persons = 500)  # Compute TAM reliability tam_rel <- compute_reliability_tam(sim_data$response_matrix, model = \"rasch\") cat(sprintf(\"WLE reliability: %.4f\\n\", tam_rel$rel_wle)) cat(sprintf(\"EAP reliability: %.4f\\n\", tam_rel$rel_eap)) } # }"},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_rho_bar.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Marginal Reliability from Simulated Test Information ‚Äî compute_rho_bar","title":"Compute Marginal Reliability from Simulated Test Information ‚Äî compute_rho_bar","text":"Low-level utilities mapping discrimination scale \\(c\\) simulated person/item parameters marginal reliability. functions implement reliability definitions used inside eqc_calibrate() sac_calibrate(): compute_rho_bar(): MSEM-based marginal reliability \\(\\bar{w}(c) = \\sigma_\\theta^2 / (\\sigma_\\theta^2 + E[1/\\mathcal{J}(\\theta;c)])\\) compute_rho_tilde(): Average-information reliability \\(\\tilde{\\rho}(c) = \\sigma_\\theta^2 \\bar{\\mathcal{J}}(c) /       (\\sigma_\\theta^2 \\bar{\\mathcal{J}}(c) + 1)\\)","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_rho_bar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Marginal Reliability from Simulated Test Information ‚Äî compute_rho_bar","text":"","code":"compute_rho_bar(c, theta_vec, beta_vec, lambda_base, theta_var = NULL)  compute_rho_tilde(c, theta_vec, beta_vec, lambda_base, theta_var = NULL)"},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_rho_bar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Marginal Reliability from Simulated Test Information ‚Äî compute_rho_bar","text":"c Numeric scalar. Global discrimination scaling factor. theta_vec Numeric vector abilities \\(\\theta_m\\). beta_vec Numeric vector item difficulties \\(\\beta_i\\). lambda_base Numeric vector baseline discriminations \\(\\lambda_{,0}\\) (scaling c). theta_var Optional numeric. Pre-calculated variance theta. NULL, computed theta_vec.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_rho_bar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Marginal Reliability from Simulated Test Information ‚Äî compute_rho_bar","text":"Numeric scalar reliability value.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_rho_bar.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Marginal Reliability from Simulated Test Information ‚Äî compute_rho_bar","text":"computation proceeds : Form scaled discriminations \\(\\lambda_i(c) = c \\cdot \\lambda_{,0}\\). Compute item response probabilities \\(p_{mi} = \\text{logit}^{-1}\\{\\lambda_i(c)(\\theta_m - \\beta_i)\\}\\). Item information: \\(\\mathcal{J}_{mi} = \\lambda_i(c)^2 p_{mi}(1-p_{mi})\\). Test information \\(\\theta_m\\): \\(\\mathcal{J}_m = \\sum_i \\mathcal{J}_{mi}\\). Reliability: compute_rho_bar(): harmonic-mean-based MSEM \\(\\text{MSEM} = E[1/\\mathcal{J}_m]\\), \\(\\bar{w}(c) = \\sigma_\\theta^2 / (\\sigma_\\theta^2 + \\text{MSEM})\\). compute_rho_tilde(): arithmetic-mean-based information \\(\\bar{\\mathcal{J}} = E[\\mathcal{J}_m]\\), \\(\\tilde{\\rho}(c) = \\sigma_\\theta^2 \\bar{\\mathcal{J}} /           (\\sigma_\\theta^2 \\bar{\\mathcal{J}} + 1)\\). small floor (1e-10) applied test information avoid numerical problems taking reciprocals.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_rho_bar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Marginal Reliability from Simulated Test Information ‚Äî compute_rho_bar","text":"","code":"# Simple toy example set.seed(1) theta <- rnorm(1000) beta  <- rnorm(20) lambda0 <- rep(1, 20)  compute_rho_bar(1, theta, beta, lambda0) #> [1] 0.7795393 compute_rho_tilde(1, theta, beta, lambda0) #> [1] 0.7870079  # With pre-calculated theta variance (recommended for SAC) theta_var_fixed <- var(rnorm(10000))  # Pre-calculate from large sample compute_rho_bar(1, theta, beta, lambda0, theta_var = theta_var_fixed) #> [1] 0.7684109"},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_rho_both.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Both Reliability Metrics in a Single Pass ‚Äî compute_rho_both","title":"Compute Both Reliability Metrics in a Single Pass ‚Äî compute_rho_both","text":"Computes average-information reliability (\\(\\tilde{\\rho}\\)) MSEM-based marginal reliability (\\(\\bar{w}\\)) single set test information values, avoiding redundant matrix computation. performance optimization calling compute_rho_tilde() compute_rho_bar() separately, since share \\(M \\times \\) matrix computations.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_rho_both.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Both Reliability Metrics in a Single Pass ‚Äî compute_rho_both","text":"","code":"compute_rho_both(c, theta_vec, beta_vec, lambda_base, theta_var = NULL)"},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_rho_both.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Both Reliability Metrics in a Single Pass ‚Äî compute_rho_both","text":"c Numeric scalar. Global discrimination scaling factor. theta_vec Numeric vector abilities \\(\\theta_m\\). beta_vec Numeric vector item difficulties \\(\\beta_i\\). lambda_base Numeric vector baseline discriminations \\(\\lambda_{,0}\\) (scaling c). theta_var Optional numeric. Pre-calculated variance theta. NULL, computed theta_vec.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_rho_both.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Both Reliability Metrics in a Single Pass ‚Äî compute_rho_both","text":"named list components: rho_tilde Average-information reliability. rho_bar MSEM-based marginal reliability.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_rho_both.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Both Reliability Metrics in a Single Pass ‚Äî compute_rho_both","text":"Jensen's inequality, \\(\\tilde{\\rho} \\geq \\bar{w}\\) always holds. See compute_rho_bar details metric.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/compute_rho_both.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Both Reliability Metrics in a Single Pass ‚Äî compute_rho_both","text":"","code":"set.seed(1) theta <- rnorm(1000) beta  <- rnorm(20) lambda0 <- rep(1, 20)  both <- compute_rho_both(1, theta, beta, lambda0) both$rho_tilde #> [1] 0.7870079 both$rho_bar #> [1] 0.7795393  # Verify: rho_tilde >= rho_bar (Jensen's inequality) both$rho_tilde >= both$rho_bar #> [1] TRUE"},{"path":"https://joonho112.github.io/IRTsimrel/reference/eqc_calibrate.html","id":null,"dir":"Reference","previous_headings":"","what":"Empirical Quadrature Calibration (Algorithm 1: EQC/SQC) ‚Äî eqc_calibrate","title":"Empirical Quadrature Calibration (Algorithm 1: EQC/SQC) ‚Äî eqc_calibrate","text":"eqc_calibrate() implements Algorithm 1 (Empirical / Stochastic Quadrature Calibration, EQC/SQC) reliability-targeted IRT simulation. Given target marginal reliability \\(\\rho^*\\), latent distribution generator sim_latentG() (\\(G\\)) item parameter generator sim_item_params() (\\(H\\)), function searches global discrimination scale \\(c^* > 0\\) population reliability \\(\\rho(c)\\) Rasch/2PL model approximately equal \\(\\rho^*\\). key idea : Draw large fixed \"quadrature\" sample \\(\\{\\theta_m\\}_{m=1}^M \\sim G\\) item parameters \\(\\{(\\beta_i, \\lambda_{,0})\\}_{=1}^\\sim H\\) . scale \\(c\\), form \\(\\lambda_i(c) = c \\cdot \\lambda_{,0}\\) compute empirical approximation population reliability \\(\\hat\\rho_M(c)\\) test information function. Solve scalar equation \\(\\hat\\rho_M(c^*) = \\rho^*\\) using deterministic root-finding (Brent's method via uniroot()).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/eqc_calibrate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Empirical Quadrature Calibration (Algorithm 1: EQC/SQC) ‚Äî eqc_calibrate","text":"","code":"eqc_calibrate(   target_rho,   n_items,   model = c(\"rasch\", \"2pl\"),   latent_shape = \"normal\",   item_source = \"parametric\",   latent_params = list(),   item_params = list(),   reliability_metric = c(\"info\", \"tilde\", \"msem\", \"bar\"),   M = 10000L,   c_bounds = c(0.3, 3),   tol = 1e-04,   seed = NULL,   verbose = FALSE )  # S3 method for class 'eqc_result' print(x, digits = 4, ...)  # S3 method for class 'eqc_result' summary(object, ...)"},{"path":"https://joonho112.github.io/IRTsimrel/reference/eqc_calibrate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Empirical Quadrature Calibration (Algorithm 1: EQC/SQC) ‚Äî eqc_calibrate","text":"target_rho Numeric (0, 1). Target marginal reliability \\(\\rho^*\\). n_items Integer. Number items test form. model Character. Measurement model: \"rasch\" \"2pl\". \"rasch\", baseline discriminations set 1 scaling. latent_shape Character. Shape argument passed sim_latentG() (e.g. \"normal\", \"bimodal\", \"heavy_tail\", ...). item_source Character. Source argument passed sim_item_params() (e.g. \"parametric\", \"irw\", \"hierarchical\", \"custom\"). Defaults \"parametric\" since irw package optional dependency (listed Suggests). Use \"irw\" empirically-grounded difficulties irw package installed. latent_params List. Additional arguments passed sim_latentG(). item_params List. Additional arguments passed sim_item_params(). reliability_metric Character. Reliability definition used inside EQC: \"info\" Average-information reliability (default, recommended EQC). Targets \\(\\tilde{\\rho}\\), guaranteed monotone \\(c\\). \"msem\" MSEM-based marginal reliability (theoretically exact, may non-monotone objective EQC; see Details). Synonyms: \"tilde\" \"info\", \"bar\" \"msem\". M Integer. Size empirical quadrature sample (default: 10000). c_bounds Numeric length-2 vector. Search bounds \\(c\\). Default: c(0.3, 3). tol Numeric. Tolerance uniroot(). Default: 1e-4. seed Optional integer reproducibility. verbose Logical. TRUE, print progress messages. x object class \"eqc_result\". digits Integer. Number decimal places printing. ... Additional arguments passed methods. object object class \"eqc_result\".","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/eqc_calibrate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Empirical Quadrature Calibration (Algorithm 1: EQC/SQC) ‚Äî eqc_calibrate","text":"object class \"eqc_result\" (list) elements: c_star Calibrated discrimination scale \\(c^*\\). target_rho Target reliability \\(\\rho^*\\). achieved_rho Empirical quadrature estimate \\(\\hat\\rho_M(c^*)\\). metric Reliability metric used. theta_quad Length-M vector quadrature abilities. theta_var Sample variance theta_quad. items_base item_params object scale = 1 (baseline). items_calib item_params object discriminations scaled c_star. input object, invisibly. object class \"summary.eqc_result\" containing key calibration results.","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/reference/eqc_calibrate.html","id":"reliability-metrics","dir":"Reference","previous_headings":"","what":"Reliability Metrics","title":"Empirical Quadrature Calibration (Algorithm 1: EQC/SQC) ‚Äî eqc_calibrate","text":"function supports two reliability definitions: Average-information (\"info\"/\"tilde\", default): Uses arithmetic mean, \\(\\tilde{\\rho}(c) = \\sigma^2_\\theta \\bar{\\mathcal{J}}(c) / (\\sigma^2_\\theta \\bar{\\mathcal{J}}(c) + 1)\\). Jensen's inequality, \\(\\tilde{\\rho} \\geq \\bar{w}\\), metric typically yields higher reliability values. recommended default EQC objective function \\(\\tilde{\\rho}(c) - \\rho^*\\) guaranteed monotone \\(c\\), ensuring uniroot() find unique root. MSEM-based (\"msem\"/\"bar\"): Uses harmonic mean test information, \\(\\bar{w}(c) = \\sigma^2_\\theta / (\\sigma^2_\\theta + E[1/\\mathcal{J}(\\theta;c)])\\). theoretically exact objective \\(\\bar{w}(c) - \\rho^*\\) may non-monotone (see Lee, 2025, Section 4.3), can cause uniroot() fail find incorrect root. Use sac_calibrate need target \\(\\bar{w}\\) directly.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/eqc_calibrate.html","id":"wle-vs-eap-reliability-interpretation","dir":"Reference","previous_headings":"","what":"WLE vs EAP Reliability Interpretation","title":"Empirical Quadrature Calibration (Algorithm 1: EQC/SQC) ‚Äî eqc_calibrate","text":"validating TAM, note EAP reliability systematically higher WLE reliability. bug mathematical property TAM's definitions. EAP reliability directly corresponds MSEM-based population reliability targeted EQC. conservative inference, treat WLE lower bound EAP upper bound true measurement precision.","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/reference/eqc_calibrate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Empirical Quadrature Calibration (Algorithm 1: EQC/SQC) ‚Äî eqc_calibrate","text":"","code":"# Basic EQC calibration with parametric items (fast) # \\donttest{ eqc_result <- eqc_calibrate(   target_rho = 0.80,   n_items = 25,   model = \"rasch\",   latent_shape = \"normal\",   item_source = \"parametric\",   M = 5000L,   seed = 42 ) print(eqc_result) #>  #> ======================================================= #>   Empirical Quadrature Calibration (EQC) Results #> ======================================================= #>  #> Calibration Summary: #>   Model                        : RASCH #>   Target reliability (rho*)    : 0.8000 #>   Achieved reliability         : 0.8000 #>   Absolute error               : 1.19e-07 #>   Scaling factor (c*)          : 0.8995 #>  #> Design Parameters: #>   Number of items (I)          : 25 #>   Quadrature points (M)        : 5000 #>   Reliability metric           : Average-information (tilde) #>   Latent variance              : 1.0099 #>  #> Convergence: #>   Root status                  : uniroot_success #>   Search bracket               : [0.300, 3.000] #>   Bracket reliabilities        : [0.3539, 0.9550] #>  #> Parameter Summaries: #>   theta:        mean = -0.014, sd = 1.005 #>   beta:         mean = 0.000, sd = 0.861, range = [-2.17, 1.45] #>   lambda_base:  mean = 1.000, sd = 0.000 #>   lambda_scaled: mean = 0.899, sd = 0.000 #>  # }  if (FALSE) { # \\dontrun{ # EQC with IRW difficulties (requires irw package) eqc_result2 <- eqc_calibrate(   target_rho = 0.80,   n_items = 25,   model = \"rasch\",   item_source = \"irw\",   seed = 42,   verbose = TRUE ) } # }"},{"path":"https://joonho112.github.io/IRTsimrel/reference/plot.item_params.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for item_params objects ‚Äî plot.item_params","title":"Plot method for item_params objects ‚Äî plot.item_params","text":"Plot method item_params objects","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/plot.item_params.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for item_params objects ‚Äî plot.item_params","text":"","code":"# S3 method for class 'item_params' plot(x, type = c(\"scatter\", \"density\", \"both\"), ...)"},{"path":"https://joonho112.github.io/IRTsimrel/reference/plot.item_params.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for item_params objects ‚Äî plot.item_params","text":"x item_params object sim_item_params(). type Character. Type plot: \"scatter\", \"density\", \"\". ... Additional arguments (currently ignored).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/plot.item_params.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot method for item_params objects ‚Äî plot.item_params","text":"ggplot object ggplot2 available, NULL invisibly using base R graphics fallback.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/plot.latent_G.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Method for latent_G Objects ‚Äî plot.latent_G","title":"Plot Method for latent_G Objects ‚Äî plot.latent_G","text":"Plot Method latent_G Objects","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/plot.latent_G.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Method for latent_G Objects ‚Äî plot.latent_G","text":"","code":"# S3 method for class 'latent_G' plot(   x,   type = c(\"both\", \"histogram\", \"density\"),   show_normal = TRUE,   bins = 50,   ... )"},{"path":"https://joonho112.github.io/IRTsimrel/reference/plot.latent_G.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Method for latent_G Objects ‚Äî plot.latent_G","text":"x latent_G object sim_latentG(). type Character. Type plot: \"histogram\", \"density\", \"\". show_normal Logical. Overlay normal reference density? bins Integer. Number histogram bins. ... Additional arguments passed plotting functions.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/plot.latent_G.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Method for latent_G Objects ‚Äî plot.latent_G","text":"ggplot object ggplot2 available, NULL invisibly using base R graphics fallback.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/plot.sac_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot SAC Convergence Trajectory ‚Äî plot.sac_result","title":"Plot SAC Convergence Trajectory ‚Äî plot.sac_result","text":"Visualizes Robbins-Monro iteration trajectory.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/plot.sac_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot SAC Convergence Trajectory ‚Äî plot.sac_result","text":"","code":"# S3 method for class 'sac_result' plot(x, type = c(\"both\", \"trajectory\", \"c\", \"rho\"), ...)"},{"path":"https://joonho112.github.io/IRTsimrel/reference/plot.sac_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot SAC Convergence Trajectory ‚Äî plot.sac_result","text":"x sac_result object sac_calibrate. type Character. Plot type: \"trajectory\", \"rho\", \"c\", \"\". ... Additional arguments (currently unused).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/plot.sac_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot SAC Convergence Trajectory ‚Äî plot.sac_result","text":"ggplot object ggplot2 available, NULL invisibly using base R graphics fallback.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/predict.eqc_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict Reliability at New Scaling Factor Values (EQC) ‚Äî predict.eqc_result","title":"Predict Reliability at New Scaling Factor Values (EQC) ‚Äî predict.eqc_result","text":"newdata NULL, returns achieved reliability calibration. newdata numeric vector scaling factor values, computes reliability value using stored quadrature sample item parameters.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/predict.eqc_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict Reliability at New Scaling Factor Values (EQC) ‚Äî predict.eqc_result","text":"","code":"# S3 method for class 'eqc_result' predict(object, newdata = NULL, ...)"},{"path":"https://joonho112.github.io/IRTsimrel/reference/predict.eqc_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict Reliability at New Scaling Factor Values (EQC) ‚Äî predict.eqc_result","text":"object object class \"eqc_result\". newdata Optional numeric vector scaling factor values. NULL, returns object$achieved_rho. ... Additional arguments (ignored).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/predict.eqc_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict Reliability at New Scaling Factor Values (EQC) ‚Äî predict.eqc_result","text":"newdata NULL, single numeric value (achieved reliability). newdata numeric vector, named numeric vector reliability values scaling factor.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/predict.eqc_result.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict Reliability at New Scaling Factor Values (EQC) ‚Äî predict.eqc_result","text":"","code":"# \\donttest{ eqc_res <- eqc_calibrate(target_rho = 0.80, n_items = 25,                           model = \"rasch\", seed = 42, M = 5000) predict(eqc_res) #> [1] 0.8000001 predict(eqc_res, newdata = c(0.5, 1.0, 1.5, 2.0)) #>     c=0.5     c=1.0     c=1.5     c=2.0  #> 0.5896711 0.8259511 0.8972175 0.9280310  # }"},{"path":"https://joonho112.github.io/IRTsimrel/reference/predict.sac_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict Reliability at New Scaling Factor Values (SAC) ‚Äî predict.sac_result","title":"Predict Reliability at New Scaling Factor Values (SAC) ‚Äî predict.sac_result","text":"newdata NULL, returns achieved reliability calibration. newdata numeric vector scaling factor values, computes reliability value using stored theta sample item parameters.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/predict.sac_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict Reliability at New Scaling Factor Values (SAC) ‚Äî predict.sac_result","text":"","code":"# S3 method for class 'sac_result' predict(object, newdata = NULL, theta_vec = NULL, ...)"},{"path":"https://joonho112.github.io/IRTsimrel/reference/predict.sac_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict Reliability at New Scaling Factor Values (SAC) ‚Äî predict.sac_result","text":"object object class \"sac_result\". newdata Optional numeric vector scaling factor values. NULL, returns object$achieved_rho. theta_vec Optional numeric vector abilities. provided, stored theta_quad SAC result used. ... Additional arguments (ignored).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/predict.sac_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict Reliability at New Scaling Factor Values (SAC) ‚Äî predict.sac_result","text":"newdata NULL, single numeric value (achieved reliability). newdata numeric vector, named numeric vector reliability values scaling factor.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/predict.sac_result.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict Reliability at New Scaling Factor Values (SAC) ‚Äî predict.sac_result","text":"","code":"if (FALSE) { # \\dontrun{ sac_res <- sac_calibrate(target_rho = 0.75, n_items = 20,                           model = \"rasch\", n_iter = 200, seed = 42) predict(sac_res) predict(sac_res, newdata = c(0.5, 1.0, 1.5, 2.0)) } # }"},{"path":"https://joonho112.github.io/IRTsimrel/reference/print.latent_G.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for latent_G Objects ‚Äî print.latent_G","title":"Print Method for latent_G Objects ‚Äî print.latent_G","text":"Print Method latent_G Objects","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/print.latent_G.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for latent_G Objects ‚Äî print.latent_G","text":"","code":"# S3 method for class 'latent_G' print(x, ...)"},{"path":"https://joonho112.github.io/IRTsimrel/reference/print.latent_G.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for latent_G Objects ‚Äî print.latent_G","text":"x latent_G object sim_latentG(). ... Additional arguments (ignored).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/print.latent_G.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print Method for latent_G Objects ‚Äî print.latent_G","text":"input object, invisibly.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/print.summary.eqc_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for summary.eqc_result Objects ‚Äî print.summary.eqc_result","title":"Print Method for summary.eqc_result Objects ‚Äî print.summary.eqc_result","text":"Print Method summary.eqc_result Objects","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/print.summary.eqc_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for summary.eqc_result Objects ‚Äî print.summary.eqc_result","text":"","code":"# S3 method for class 'summary.eqc_result' print(x, digits = 4, ...)"},{"path":"https://joonho112.github.io/IRTsimrel/reference/print.summary.eqc_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for summary.eqc_result Objects ‚Äî print.summary.eqc_result","text":"x summary.eqc_result object summary.eqc_result(). digits Integer. Number decimal places printing. ... Additional arguments (ignored).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/print.summary.eqc_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print Method for summary.eqc_result Objects ‚Äî print.summary.eqc_result","text":"input object, invisibly.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/print.summary.item_params.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for summary.item_params Objects ‚Äî print.summary.item_params","title":"Print Method for summary.item_params Objects ‚Äî print.summary.item_params","text":"Print Method summary.item_params Objects","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/print.summary.item_params.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for summary.item_params Objects ‚Äî print.summary.item_params","text":"","code":"# S3 method for class 'summary.item_params' print(x, digits = 4, ...)"},{"path":"https://joonho112.github.io/IRTsimrel/reference/print.summary.item_params.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for summary.item_params Objects ‚Äî print.summary.item_params","text":"x summary.item_params object summary.item_params(). digits Integer. Number decimal places printing. ... Additional arguments (ignored).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/print.summary.item_params.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print Method for summary.item_params Objects ‚Äî print.summary.item_params","text":"input object, invisibly.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/print.summary.latent_G.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for summary.latent_G Objects ‚Äî print.summary.latent_G","title":"Print Method for summary.latent_G Objects ‚Äî print.summary.latent_G","text":"Print Method summary.latent_G Objects","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/print.summary.latent_G.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for summary.latent_G Objects ‚Äî print.summary.latent_G","text":"","code":"# S3 method for class 'summary.latent_G' print(x, digits = 4, ...)"},{"path":"https://joonho112.github.io/IRTsimrel/reference/print.summary.latent_G.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for summary.latent_G Objects ‚Äî print.summary.latent_G","text":"x summary.latent_G object summary.latent_G(). digits Integer. Number decimal places printing. ... Additional arguments (ignored).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/print.summary.latent_G.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print Method for summary.latent_G Objects ‚Äî print.summary.latent_G","text":"input object, invisibly.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/print.summary.sac_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for summary.sac_result Objects ‚Äî print.summary.sac_result","title":"Print Method for summary.sac_result Objects ‚Äî print.summary.sac_result","text":"Print Method summary.sac_result Objects","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/print.summary.sac_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for summary.sac_result Objects ‚Äî print.summary.sac_result","text":"","code":"# S3 method for class 'summary.sac_result' print(x, digits = 4, ...)"},{"path":"https://joonho112.github.io/IRTsimrel/reference/print.summary.sac_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for summary.sac_result Objects ‚Äî print.summary.sac_result","text":"x summary.sac_result object summary.sac_result(). digits Integer. Number decimal places printing. ... Additional arguments (ignored).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/print.summary.sac_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print Method for summary.sac_result Objects ‚Äî print.summary.sac_result","text":"input object, invisibly.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/rho_curve.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Reliability as a Function of Scaling Factor ‚Äî rho_curve","title":"Compute Reliability as a Function of Scaling Factor ‚Äî rho_curve","text":"Computes optionally plots reliability curve \\(\\rho(c)\\) across grid scaling factor values. visualization helps understand reliability varies discrimination scaling factor aids selecting appropriate target reliability values.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/rho_curve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Reliability as a Function of Scaling Factor ‚Äî rho_curve","text":"","code":"rho_curve(   c_values = seq(0.1, 5, length.out = 50),   n_items,   model = c(\"rasch\", \"2pl\"),   latent_shape = \"normal\",   item_source = \"parametric\",   metric = c(\"both\", \"info\", \"msem\"),   M = 5000L,   seed = NULL,   latent_params = list(),   item_params = list(),   plot = TRUE )  # S3 method for class 'rho_curve' print(x, ...)"},{"path":"https://joonho112.github.io/IRTsimrel/reference/rho_curve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Reliability as a Function of Scaling Factor ‚Äî rho_curve","text":"c_values Numeric vector. Grid scaling factor values evaluate. Default: seq(0.1, 5, length.= 50). n_items Integer. Number items test form. model Character. Measurement model: \"rasch\" \"2pl\". latent_shape Character. Shape argument passed sim_latentG(). item_source Character. Source argument passed sim_item_params(). metric Character. reliability metric(s) compute: \"\", \"info\", \"msem\". M Integer. Monte Carlo sample size. Default: 5000. seed Optional integer reproducibility. latent_params List. Additional arguments passed sim_latentG(). item_params List. Additional arguments passed sim_item_params(). plot Logical. TRUE (default), create plot curve. x object class \"rho_curve\". ... Additional arguments (ignored).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/rho_curve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Reliability as a Function of Scaling Factor ‚Äî rho_curve","text":"data frame class \"rho_curve\" columns: c Scaling factor values. rho_tilde Average-information reliability (metric includes \"info\"). rho_bar MSEM-based reliability (metric includes \"msem\"). input object, invisibly.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/rho_curve.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Reliability as a Function of Scaling Factor ‚Äî rho_curve","text":"function generates single set theta item parameters, evaluates reliability value c_values. metric = \"\", uses compute_rho_both efficiency.","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/reference/rho_curve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Reliability as a Function of Scaling Factor ‚Äî rho_curve","text":"","code":"# Basic usage: plot reliability curve for 25-item Rasch test curve_data <- rho_curve(n_items = 25, model = \"rasch\", seed = 42,                         M = 3000, plot = FALSE) head(curve_data) #> Reliability Curve #> ================= #>   Items: 25 | Model: RASCH | Metric: both #>   c range: [0.10, 0.60] (6 points) #>   rho_tilde range: [0.0592, 0.6645] #>   rho_bar range  : [0.0592, 0.6622] #>  #>     c  rho_tilde    rho_bar #> 1 0.1 0.05922061 0.05921989 #> 2 0.2 0.19896249 0.19893104 #> 3 0.3 0.35354114 0.35333047 #> 4 0.4 0.48588780 0.48523096 #> 5 0.5 0.58813434 0.58675218 #> 6 0.6 0.66450137 0.66217929"},{"path":"https://joonho112.github.io/IRTsimrel/reference/sac_calibrate.html","id":null,"dir":"Reference","previous_headings":"","what":"Stochastic Approximation Calibration (Algorithm 2: SAC) ‚Äî sac_calibrate","title":"Stochastic Approximation Calibration (Algorithm 2: SAC) ‚Äî sac_calibrate","text":"sac_calibrate() implements Algorithm 2 (Stochastic Approximation Calibration, SAC) reliability-targeted IRT simulation using Robbins-Monro stochastic approximation algorithm. Given target marginal reliability \\(\\rho^*\\), latent distribution generator sim_latentG() (\\(G\\)) item parameter generator sim_item_params() (\\(H\\)), function iteratively searches global discrimination scale \\(c^* > 0\\) population reliability \\(\\rho(c)\\) Rasch/2PL model approximately equal \\(\\rho^*\\). SAC complements EQC (Algorithm 1) : Providing independent validation EQC calibration results. Enabling calibration exact marginal reliability \\(\\bar{w}\\) (just average-information approximation \\(\\tilde{\\rho}\\)). Handling complex data-generating processes analytic information functions may unavailable. algorithm uses Robbins-Monro update rule: $$c_{n+1} = c_n - a_n \\cdot (\\hat{\\rho}_n - \\rho^*)$$ \\(a_n = / (n + )^\\gamma\\) decreasing step size sequence satisfying \\(\\sum a_n = \\infty\\) \\(\\sum a_n^2 < \\infty\\).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/sac_calibrate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Stochastic Approximation Calibration (Algorithm 2: SAC) ‚Äî sac_calibrate","text":"","code":"sac_calibrate(   target_rho,   n_items,   model = c(\"rasch\", \"2pl\"),   latent_shape = \"normal\",   item_source = \"parametric\",   latent_params = list(),   item_params = list(),   reliability_metric = c(\"msem\", \"info\", \"bar\", \"tilde\"),   c_init = NULL,   M_per_iter = 500L,   M_pre = 10000L,   n_iter = 300L,   burn_in = NULL,   step_params = list(),   c_bounds = c(0.01, 20),   resample_items = TRUE,   seed = NULL,   verbose = FALSE )  spc_calibrate(...)  # S3 method for class 'sac_result' print(x, digits = 4, ...)  # S3 method for class 'sac_result' summary(object, ...)"},{"path":"https://joonho112.github.io/IRTsimrel/reference/sac_calibrate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Stochastic Approximation Calibration (Algorithm 2: SAC) ‚Äî sac_calibrate","text":"target_rho Numeric (0, 1). Target marginal reliability \\(\\rho^*\\). n_items Integer. Number items test form. model Character. Measurement model: \"rasch\" \"2pl\". \"rasch\", baseline discriminations set 1 scaling. latent_shape Character. Shape argument passed sim_latentG() (e.g. \"normal\", \"bimodal\", \"heavy_tail\", ...). item_source Character. Source argument passed sim_item_params() (e.g. \"parametric\", \"irw\", \"hierarchical\", \"custom\"). Defaults \"parametric\" since irw package optional dependency (listed Suggests). Use \"irw\" empirically-grounded difficulties irw package installed. latent_params List. Additional arguments passed sim_latentG(). item_params List. Additional arguments passed sim_item_params(). reliability_metric Character. Reliability definition used inside SAC: \"msem\" MSEM-based marginal reliability (theoretically exact, targets \\(\\bar{w}\\)). \"info\" Average-information reliability (faster, targets \\(\\tilde{\\rho}\\)). Synonyms: \"bar\" \"msem\", \"tilde\" \"info\". c_init Numeric, eqc_result object, NULL. Initial value scaling factor \\(c_0\\). eqc_result object provided, c_star used (warm start). numeric value provided, used directly. NULL, initialized using Analytic Pre-Calibration (APC). Providing warm start EQC greatly accelerates convergence. M_per_iter Integer. Number Monte Carlo samples per iteration estimating reliability. Default: 500. Larger values reduce variance increase computation time. M_pre Integer. Number Monte Carlo samples pre-calculating latent variance \\(\\sigma^2_\\theta\\). Default: 10000. variance fixed throughout iterations stability. CRITICAL parameter numerical stability. n_iter Integer. Total number Robbins-Monro iterations. Default: 300. burn_in Integer. Number initial iterations discard Polyak-Ruppert averaging. Default: floor(n_iter / 2). step_params List. Parameters controlling step size sequence: Base step size (default: 1.0) Stabilization constant (default: 50) gamma Decay exponent (default: 0.67, .e., 2/3) c_bounds Numeric length-2 vector. Projection bounds \\(c\\). Iterates clipped interval update. Default: c(0.01, 20). resample_items Logical. TRUE (default), resample item parameters iteration. FALSE, fix item parameters across iterations (reduces variance may introduce bias). seed Optional integer reproducibility. verbose Logical integer. TRUE >= 1, print progress messages. >= 2, print detailed iteration-level output. ... Arguments passed sac_calibrate(). x object class \"sac_result\". digits Integer. Number decimal places printing. object object class \"sac_result\".","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/sac_calibrate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Stochastic Approximation Calibration (Algorithm 2: SAC) ‚Äî sac_calibrate","text":"object class \"sac_result\" (list) elements: c_star Calibrated discrimination scale (Polyak-Ruppert average). c_final Final iterate \\(c_{n_{iter}}\\). target_rho Target reliability \\(\\rho^*\\). achieved_rho Estimated reliability \\(c^*\\) (post-calibration). theta_var Pre-calculated latent variance used throughout. trajectory Numeric vector iterates. rho_trajectory Numeric vector reliability estimates. init_method Character indicating initialization method. metric Reliability metric used. convergence List convergence diagnostics. beta_vec Item difficulties final post-calibration draw. lambda_base Baseline (unscaled) item discriminations. lambda_scaled Scaled item discriminations (lambda_base * c_star). items_base Baseline item_params object (scale = 1). items_calib Calibrated item_params object (discriminations scaled c_star). theta_quad Theta sample used post-calibration reliability estimate. input object, invisibly. object class \"summary.sac_result\" containing key calibration results.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/sac_calibrate.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Stochastic Approximation Calibration (Algorithm 2: SAC) ‚Äî sac_calibrate","text":"Robbins, H., & Monro, S. (1951). stochastic approximation method. Annals Mathematical Statistics, 22(3), 400‚Äì407. Polyak, B. T., & Juditsky, . B. (1992). Acceleration stochastic approximation averaging. SIAM Journal Control Optimization, 30(4), 838‚Äì855.","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/reference/sac_calibrate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Stochastic Approximation Calibration (Algorithm 2: SAC) ‚Äî sac_calibrate","text":"","code":"if (FALSE) { # \\dontrun{ # Example 1: Basic SAC calibration sac_result <- sac_calibrate(   target_rho = 0.75,   n_items = 20,   model = \"rasch\",   n_iter = 200,   seed = 12345,   verbose = TRUE ) print(sac_result) plot(sac_result)  # Example 2: Warm start from EQC (RECOMMENDED) eqc_result <- eqc_calibrate(   target_rho = 0.80,   n_items = 25,   model = \"2pl\",   M = 10000,   seed = 42 )  sac_result <- sac_calibrate(   target_rho = 0.80,   n_items = 25,   model = \"2pl\",   c_init = eqc_result,  # Direct EQC object passing!   n_iter = 100,   seed = 42 )  # Compare EQC and SAC results cat(sprintf(\"EQC c* = %.4f, SAC c* = %.4f\\n\",             eqc_result$c_star, sac_result$c_star)) } # }"},{"path":"https://joonho112.github.io/IRTsimrel/reference/sim_item_params.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Item Parameters for IRT Studies ‚Äî sim_item_params","title":"Simulate Item Parameters for IRT Studies ‚Äî sim_item_params","text":"sim_item_params() generates item parameters (difficulty \\(\\beta\\) discrimination \\(\\lambda\\)) Item Response Theory (IRT) simulation studies. wraps IRW irw_simu_diff() function realistic difficulty distributions provides multiple methods generating correlated discriminations. function designed four key principles: Realistic difficulties: Integration Item Response Warehouse (IRW) empirically-grounded difficulty distributions. Correlated parameters: Support empirically observed negative correlation difficulty discrimination (Sweeney et al., 2022). Marginal preservation: Copula method preserves exact marginal distributions achieving target correlation. Reliability targeting: Scale factor subsequent calibration.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/sim_item_params.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Item Parameters for IRT Studies ‚Äî sim_item_params","text":"","code":"sim_item_params(   n_items,   model = c(\"rasch\", \"2pl\"),   source = c(\"irw\", \"parametric\", \"hierarchical\", \"custom\"),   method = c(\"copula\", \"conditional\", \"independent\"),   n_forms = 1L,   difficulty_params = list(),   discrimination_params = list(),   hierarchical_params = list(),   custom_params = list(),   scale = 1,   center_difficulties = TRUE,   seed = NULL )  # S3 method for class 'item_params' print(x, ...)  # S3 method for class 'item_params' summary(object, ...)"},{"path":"https://joonho112.github.io/IRTsimrel/reference/sim_item_params.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Item Parameters for IRT Studies ‚Äî sim_item_params","text":"n_items Integer. Number items generate per form. model Character. data-generating model: \"rasch\" \"2pl\". source Character. Source generating difficulties: \"irw\" Use IRW difficulty pool (realistic, empirical) \"parametric\" Generate parametric distribution \"hierarchical\" Joint MVN parameters (Glas & van der Linden) \"custom\" User-supplied parameters function method Character. Method generating discriminations (model = \"2pl\"): \"copula\" Gaussian copula - preserves marginals exactly (RECOMMENDED) \"conditional\" Conditional normal regression difficulty \"independent\" Independent generation (correlation) n_forms Integer. Number test forms generate. Default 1. > 1, returns data frame form_id column. difficulty_params List. Parameters difficulty generation: source = \"irw\": pool - difficulty pool data frame source = \"parametric\": mu, sigma, distribution discrimination_params List. Parameters discrimination generation: mu_log Mean log-discrimination (default: 0) sigma_log SD log-discrimination (default: 0.3) rho Target correlation \\(\\beta\\) \\(\\log(\\lambda)\\) (default: -0.3) hierarchical_params List. source = \"hierarchical\": mu 2-vector: means \\((\\log\\lambda, \\beta)\\) tau 2-vector: SDs rho Correlation custom_params List. source = \"custom\": beta Vector function returning difficulties lambda Vector function returning discriminations scale Numeric. Global discrimination scaling factor reliability targeting. Final discriminations \\(\\lambda_i^* = c \\cdot \\lambda_i\\). Default 1. center_difficulties Logical. TRUE, center difficulties sum zero identification. Default TRUE. seed Integer. Random seed reproducibility. x object class \"item_params\". ... Additional arguments passed methods. object object class \"item_params\".","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/sim_item_params.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Item Parameters for IRT Studies ‚Äî sim_item_params","text":"object class \"item_params\" containing: data Data frame columns: form_id, item_id, beta, lambda, lambda_unscaled model Model type used source Source used generation method Method used discrimination generation n_items Number items per form n_forms Number forms generated scale Scale factor applied centered Whether difficulties centered params Parameters used generation achieved Achieved statistics (correlations, moments) input object, invisibly. object class \"summary.item_params\" containing key parameter summaries.","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/reference/sim_item_params.html","id":"why-copula-method-is-recommended","dir":"Reference","previous_headings":"","what":"Why Copula Method is Recommended","title":"Simulate Item Parameters for IRT Studies ‚Äî sim_item_params","text":"difficulties come IRW pool (realistic, often non-normal marginal distributions), conditional normal method can distort achieved correlation assumes linearity. Gaussian copula method: Transforms difficulties uniform scale via empirical CDF Generates correlated uniforms Gaussian copula Transforms back desired marginals (log-normal discrimination) guarantees: Exact preservation difficulty marginal (whatever IRW provides) Exact log-normal marginal discriminations Spearman correlation \\(\\approx \\rho\\) (rank-based, robust non-normality","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/sim_item_params.html","id":"connection-to-reliability-targeted-framework","dir":"Reference","previous_headings":"","what":"Connection to Reliability-Targeted Framework","title":"Simulate Item Parameters for IRT Studies ‚Äî sim_item_params","text":"scale parameter implements \"separation structure scale\": Structure: Realistic item characteristics IRW + correlation Scale: Global factor \\(c\\) calibrated target reliability","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/sim_item_params.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Simulate Item Parameters for IRT Studies ‚Äî sim_item_params","text":"Glas, C. . W., & van der Linden, W. J. (2003). Computerized adaptive testing item cloning. Applied Psychological Measurement, 27(4), 247-261. Sweeney, S. M., et al. (2022). investigation nature consequence relationship IRT difficulty discrimination. EM:IP, 41(4), 50-67. Zhang, L., et al. (2025). Realistic simulation item difficulties. PsyArXiv.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/sim_item_params.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate Item Parameters for IRT Studies ‚Äî sim_item_params","text":"","code":"# Example 1: Rasch with parametric difficulties items1 <- sim_item_params(n_items = 25, model = \"rasch\",                           source = \"parametric\", seed = 42)  # Example 2: 2PL with copula method (recommended) items2 <- sim_item_params(   n_items = 30, model = \"2pl\", source = \"parametric\",   method = \"copula\",   discrimination_params = list(rho = -0.3),   seed = 42 )  # Example 3: Hierarchical 2PL items3 <- sim_item_params(   n_items = 25, model = \"2pl\", source = \"hierarchical\",   hierarchical_params = list(mu = c(0, 0), tau = c(0.25, 1), rho = -0.3),   seed = 42 )  if (FALSE) { # \\dontrun{ # Example 4: Using IRW difficulty pool (requires irw package) items4 <- sim_item_params(n_items = 25, model = \"rasch\", source = \"irw\")  # Example 5: Multiple forms with IRW items5 <- sim_item_params(   n_items = 20, model = \"2pl\", n_forms = 5,   source = \"irw\", method = \"copula\" ) } # }"},{"path":"https://joonho112.github.io/IRTsimrel/reference/sim_latentG.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Latent Ability Distribution for IRT Studies (G-family) ‚Äî sim_latentG","title":"Simulate Latent Ability Distribution for IRT Studies (G-family) ‚Äî sim_latentG","text":"sim_latentG() generates latent abilities (person parameters \\(\\theta\\)) Item Response Theory (IRT) simulation studies. implements population model \\(\\theta_p \\sim G\\) \\(G\\) flexible distribution family. function designed two key principles: Pre-standardization: distribution shape mathematically constructed mean 0 variance 1, ensuring changing shape inadvertently change scale. Separation Structure Scale: sigma parameter directly controls standard deviation latent trait, independent distributional shape. generated abilities follow: $$\\theta_p = \\mu + X_p^\\top \\beta + \\sigma \\cdot z_p$$ \\(z_p \\sim G_0\\) \\(E[z]=0\\) \\(Var[z]=1\\).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/sim_latentG.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Latent Ability Distribution for IRT Studies (G-family) ‚Äî sim_latentG","text":"","code":"sim_latentG(   n,   shape = c(\"normal\", \"bimodal\", \"trimodal\", \"multimodal\", \"skew_pos\", \"skew_neg\",     \"heavy_tail\", \"light_tail\", \"uniform\", \"floor\", \"ceiling\", \"custom\"),   sigma = 1,   mu = 0,   xcov = NULL,   beta = NULL,   shape_params = list(),   mixture_spec = NULL,   standardize_custom = TRUE,   seed = NULL,   return_z = TRUE )"},{"path":"https://joonho112.github.io/IRTsimrel/reference/sim_latentG.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Latent Ability Distribution for IRT Studies (G-family) ‚Äî sim_latentG","text":"n Integer. Number persons (latent abilities) generate. shape Character. distributional shape standardized component. One : \"normal\" Standard normal \\(N(0,1)\\) \"bimodal\" Symmetric two-component Gaussian mixture analytically standardized parameters \"trimodal\" Symmetric three-component Gaussian mixture \"multimodal\" Four-component Gaussian mixture \"skew_pos\" Right-skewed distribution via standardized Gamma \"skew_neg\" Left-skewed distribution (negated Gamma) \"heavy_tail\" Heavy-tailed distribution via standardized Student-t \"light_tail\" Light-tailed (platykurtic) mixture distribution \"uniform\" Uniform distribution \\([-\\sqrt{3}, \\sqrt{3}]\\) \"floor\" Distribution floor effect (left-truncated feel) \"ceiling\" Distribution ceiling effect (right-truncated feel) \"custom\" User-specified mixture distribution sigma Numeric. Scale (standard deviation) residual latent trait. Since standardized component variance 1, sigma directly equals marginal SD residual term. Default 1. mu Numeric. Grand mean latent ability distribution. Rasch models often fixed 0 identification. Default 0. xcov Matrix data.frame. Optional covariate matrix n rows. supplied, person-specific covariate effects added \\(\\eta = X\\beta\\). beta Numeric vector. Regression coefficients xcov. Must length equal ncol(xcov). Ignored xcov NULL. shape_params List. Additional parameters controlling shape. See Details shape-specific parameters. mixture_spec List. shape = \"custom\", specifies mixture: weights Numeric vector mixing proportions (must sum 1) means Numeric vector component means sds Numeric vector component standard deviations custom mixture automatically standardized mean 0 variance 1. standardize_custom Logical. TRUE (default), custom mixtures post-standardized ensure mean 0 variance 1. FALSE, raw mixture used (user must ensure proper standardization). seed Integer. Random seed reproducibility. NULL (default), current RNG state used. return_z Logical. TRUE, include standardized draws z output. Default TRUE.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/sim_latentG.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Latent Ability Distribution for IRT Studies (G-family) ‚Äî sim_latentG","text":"object class \"latent_G\" (list) containing: theta Numeric vector length n, simulated latent abilities z Standardized draws (return_z = TRUE) eta_cov Covariate linear predictor (0 covariates) mu Grand mean used sigma Scale parameter used shape Shape label shape_params Shape parameters used n Sample size sample_moments List sample mean, sd, skewness, kurtosis","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/reference/sim_latentG.html","id":"pre-standardization-mathematics","dir":"Reference","previous_headings":"","what":"Pre-standardization Mathematics","title":"Simulate Latent Ability Distribution for IRT Studies (G-family) ‚Äî sim_latentG","text":"built-shape constructed exactly mean 0 variance 1: Bimodal: Two-component mixture modes \\(\\pm\\delta\\): $$z = s \\cdot \\delta + \\epsilon, \\quad s \\sim \\text{Rademacher}, \\quad \\epsilon \\sim N(0, 1-\\delta^2)$$ component variance \\(1-\\delta^2\\) ensures \\(Var[z] = \\delta^2 + (1-\\delta^2) = 1\\). Trimodal: Three-component mixture weights \\((w_L, w_0, w_R)\\) means \\((-m, 0, m)\\). Component variance \\(\\sigma_c^2 = 1 - (1-w_0)m^2\\) ensure unit total variance. Skewed: Standardized Gamma distribution: $$z = \\frac{\\Gamma(k, 1) - k}{\\sqrt{k}}$$ \\(E[z]=0\\) \\(Var[z]=1\\) \\(k > 0\\). Heavy-tailed: Standardized Student-t: $$z = \\frac{t_\\nu}{\\sqrt{\\nu/(\\nu-2)}}$$ \\(Var[z]=1\\) \\(\\nu > 2\\).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/sim_latentG.html","id":"shape-specific-parameters","dir":"Reference","previous_headings":"","what":"Shape-Specific Parameters","title":"Simulate Latent Ability Distribution for IRT Studies (G-family) ‚Äî sim_latentG","text":"delta \"bimodal\": mode separation, must satisfy \\(0 < \\delta < 1\\). Default: 0.8 w0 \"trimodal\": weight central component, must satisfy \\(0 < w_0 < 1\\). Default: 1/3 m \"trimodal\": magnitude side component means. Must satisfy \\((1-w_0)m^2 < 1\\). Default: 1.2 k \"skew_pos\"/\"skew_neg\": Gamma shape parameter, controls skewness magnitude. Default: 4 df \"heavy_tail\": degrees freedom, must > 2. Default: 5","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/sim_latentG.html","id":"connection-to-irt-framework","dir":"Reference","previous_headings":"","what":"Connection to IRT Framework","title":"Simulate Latent Ability Distribution for IRT Studies (G-family) ‚Äî sim_latentG","text":"Rasch/2PL model, latent distribution \\(G\\) affects: Marginal reliability: \\(\\bar{w} = \\sigma_\\theta^2 / (\\sigma_\\theta^2 + \\text{MSEM})\\) Expected test information: \\(\\bar{\\mathcal{J}} = E_G[\\mathcal{J}(\\theta)]\\) Identifiability (see Appendix F manuscript) function serves generator \\(G\\) reliability-targeted simulation studies, allowing researchers examine distributional shape affects model performance holding scale constant.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/sim_latentG.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Simulate Latent Ability Distribution for IRT Studies (G-family) ‚Äî sim_latentG","text":"Baker, F. B., & Kim, S.-H. (2004). Item Response Theory: Parameter Estimation Techniques (2nd ed.). Marcel Dekker. Paganin, S., et al. (2022). Computational strategies estimation performance Bayesian semiparametric item response theory models. Journal Educational Behavioral Statistics, 48(2), 147-188.","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/reference/sim_latentG.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate Latent Ability Distribution for IRT Studies (G-family) ‚Äî sim_latentG","text":"","code":"# Basic usage: standard normal abilities sim1 <- sim_latentG(n = 1000, shape = \"normal\") mean(sim1$theta)  # approximately 0 #> [1] -0.01441477 sd(sim1$theta)    # approximately 1 #> [1] 1.040669  # Bimodal distribution for heterogeneous population sim2 <- sim_latentG(n = 1000, shape = \"bimodal\",                     shape_params = list(delta = 0.9))  # Skewed distribution with larger scale sim3 <- sim_latentG(n = 1000, shape = \"skew_pos\", sigma = 1.5)  # With covariate effects (e.g., group differences) group <- rbinom(1000, 1, 0.5) sim4 <- sim_latentG(n = 1000, shape = \"normal\",                     xcov = data.frame(group = group),                     beta = 0.5)  # Custom mixture distribution sim5 <- sim_latentG(n = 1000, shape = \"custom\",                     mixture_spec = list(                       weights = c(0.3, 0.5, 0.2),                       means = c(-1.5, 0, 2),                       sds = c(0.5, 0.7, 0.5)                     ))"},{"path":"https://joonho112.github.io/IRTsimrel/reference/simulate_response_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Item Response Data from Calibration Results ‚Äî simulate_response_data","title":"Simulate Item Response Data from Calibration Results ‚Äî simulate_response_data","text":"Generates item response data using calibrated parameters eqc_calibrate() sac_calibrate() (formerly spc_calibrate()).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/simulate_response_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Item Response Data from Calibration Results ‚Äî simulate_response_data","text":"","code":"simulate_response_data(   result,   n_persons,   latent_shape = \"normal\",   latent_params = list(),   seed = NULL )"},{"path":"https://joonho112.github.io/IRTsimrel/reference/simulate_response_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Item Response Data from Calibration Results ‚Äî simulate_response_data","text":"result calibration result object class \"eqc_result\", \"sac_result\", \"spc_result\" (backward compatibility), returned eqc_calibrate() sac_calibrate(). n_persons Integer. Number persons simulate. latent_shape Character. Shape argument sim_latentG(). latent_params List. Additional arguments sim_latentG(). seed Optional integer reproducibility.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/simulate_response_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Item Response Data from Calibration Results ‚Äî simulate_response_data","text":"list containing: response_matrix N x matrix binary responses theta True abilities (N x 1) beta Item difficulties (x 1) lambda Item discriminations (x 1)","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/reference/simulate_response_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate Item Response Data from Calibration Results ‚Äî simulate_response_data","text":"","code":"if (FALSE) { # \\dontrun{ # Example 1: Using EQC calibration result eqc_result <- eqc_calibrate(   target_rho = 0.80,   n_items = 25,   model = \"rasch\",   seed = 42 )  sim_data <- simulate_response_data(   result = eqc_result,   n_persons = 1000,   latent_shape = \"normal\",   seed = 123 )  # Example 2: Using SAC calibration result sac_result <- sac_calibrate(   target_rho = 0.80,   n_items = 25,   model = \"rasch\",   n_iter = 200,   seed = 42 )  sim_data2 <- simulate_response_data(   result = sac_result,   n_persons = 1000,   latent_shape = \"normal\",   seed = 123 )  # Use with TAM for validation tam_rel <- compute_reliability_tam(sim_data$response_matrix, model = \"rasch\") } # }"},{"path":"https://joonho112.github.io/IRTsimrel/reference/summary.latent_G.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary Method for latent_G Objects ‚Äî summary.latent_G","title":"Summary Method for latent_G Objects ‚Äî summary.latent_G","text":"Summary Method latent_G Objects","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/summary.latent_G.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary Method for latent_G Objects ‚Äî summary.latent_G","text":"","code":"# S3 method for class 'latent_G' summary(object, ...)"},{"path":"https://joonho112.github.io/IRTsimrel/reference/summary.latent_G.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary Method for latent_G Objects ‚Äî summary.latent_G","text":"object latent_G object sim_latentG(). ... Additional arguments (ignored).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/reference/summary.latent_G.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summary Method for latent_G Objects ‚Äî summary.latent_G","text":"list summary statistics.","code":""},{"path":[]},{"path":"https://joonho112.github.io/IRTsimrel/news/index.html","id":"breaking-changes-0-2-0","dir":"Changelog","previous_headings":"","what":"Breaking Changes","title":"IRTsimrel 0.2.0","text":"sac_calibrate() now primary function name Stochastic Approximation Calibration (spc_calibrate()). spc_calibrate() remains available deprecated alias. eqc_calibrate() default reliability metric changed \"msem\" \"info\" (see Lee, 2025, Section 4.3 non-monotone MSEM objective EQC). simulate_response_data() first parameter renamed eqc_result result now accepts eqc_result sac_result objects. Default item_source eqc_calibrate() sac_calibrate() changed \"irw\" \"parametric\" (since irw optional Suggests dependency).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/news/index.html","id":"new-features-0-2-0","dir":"Changelog","previous_headings":"","what":"New Features","title":"IRTsimrel 0.2.0","text":"sac_calibrate() now stores calibrated item parameters (beta_vec, lambda_base, lambda_scaled, items_base, items_calib, theta_quad) result object, enabling direct use simulate_response_data(). compare_eqc_sac() replaces compare_eqc_spc() primary comparison function (old name remains deprecated alias).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/news/index.html","id":"bug-fixes-0-2-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"IRTsimrel 0.2.0","text":"Fixed library() calls inside package functions (plot.item_params(), plot.spc_result()) ‚Äî now use proper namespace qualification. Fixed S3 method signatures: .numeric.latent_G() .data.frame.item_params() now include required ... parameter. Fixed set.seed() side effects ‚Äî 6 instances now properly save restore .Random.seed via .exit(). Fixed par() side effects base R plot methods. Fixed non-ASCII characters (Œº, œÉ) sim_latentG.R.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/news/index.html","id":"documentation-0-2-0","dir":"Changelog","previous_headings":"","what":"Documentation","title":"IRTsimrel 0.2.0","text":"Getting Started: introduction, quick-start Applied Researchers Track: applied-guide, latent-distributions, item-parameters, simulation-design, case-studies Methodological Researchers Track: theory-reliability, algorithm-eqc, algorithm-sac, validation, api-reference vignettes use eval=TRUE code chunks working examples. Added comprehensive roxygen documentation S3 methods. Created NEWS.md. Updated README.Rmd correct function names, metrics table, arXiv reference. Added hex sticker logo (man/figures/logo.png). Updated pkgdown site two-track article navigation comprehensive reference index.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/news/index.html","id":"design-improvements-0-2-0","dir":"Changelog","previous_headings":"","what":"Design Improvements","title":"IRTsimrel 0.2.0","text":"Proper summary() objects eqc_result, sac_result, item_params, latent_G (dedicated print.summary.* method). Verbose output now uses message() instead cat() (suppressible suppressMessages()). compare_eqc_sac() now validates matching target_rho, warns model/n_items/metric differences. Convenience auto-wrapping latent_params shape parameters. Full uniroot() diagnostics stored misc$uniroot_result.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/news/index.html","id":"new-utilities-0-2-0","dir":"Changelog","previous_headings":"","what":"New Utilities","title":"IRTsimrel 0.2.0","text":"check_feasibility() screens achievable reliability ranges calibration. rho_curve() computes plots reliability function scaling factor. compute_rho_both() computes reliability metrics single pass. coef() predict() S3 methods eqc_result sac_result.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/news/index.html","id":"testing-0-2-0","dir":"Changelog","previous_headings":"","what":"Testing","title":"IRTsimrel 0.2.0","text":"Added comprehensive test suite testthat (519 tests covering core functions, S3 methods, edge cases, error handling).","code":""},{"path":"https://joonho112.github.io/IRTsimrel/news/index.html","id":"infrastructure-0-2-0","dir":"Changelog","previous_headings":"","what":"Infrastructure","title":"IRTsimrel 0.2.0","text":"Fixed .Rbuildignore exclude dev/, pkg.lock, .claude/. Fixed DESCRIPTION: removed LazyData, Remotes; added graphics, grDevices, utils Imports; added MASS Suggests. Removed unused imports (stats::ecdf, stats::setNames) NAMESPACE. Updated _pkgdown.yml new function references S3 method sections. Updated README.Rmd Phase 6 features, corrected metrics table, arXiv URL. Version bumped 0.2.0. R CMD check passes 0 errors, 0 warnings, 0 notes.","code":""},{"path":"https://joonho112.github.io/IRTsimrel/news/index.html","id":"irtsimrel-010","dir":"Changelog","previous_headings":"","what":"IRTsimrel 0.1.0","title":"IRTsimrel 0.1.0","text":"Initial release EQC SPC calibration algorithms. 12 built-latent distribution shapes pre-standardization. IRW integration realistic item difficulty generation. Copula method correlated difficulty-discrimination generation. TAM-based validation utilities.","code":""}]
